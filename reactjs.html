<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Ampersand Academy - React.js Notes</title>

    <!-- Meta -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta name="description" content="React.js Guide and Notes" />
    <meta name="author" content="Ampersand Academy" />
    <link rel="shortcut icon" href="favicon.ico" />

    <!-- Google Font -->
    <link
      href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap"
      rel="stylesheet"
    />

    <!-- FontAwesome JS-->
    <script defer src="assets/fontawesome/js/all.min.js"></script>

    <!-- Prism.js CSS Theme -->
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="assets/plugins/simplelightbox/simple-lightbox.min.css"
    />

    <!-- Dark Github Gist CSS -->
    <link
      id="theme-style"
      rel="stylesheet"
      href="assets/css/darkGist.min.css"
    />

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/theme.css" />
  </head>

  <body class="docs-page">
    <header class="header fixed-top">
      <div class="branding docs-branding">
        <div class="container-fluid position-relative py-2">
          <div class="docs-logo-wrapper">
            <button
              id="docs-sidebar-toggler"
              class="docs-sidebar-toggler docs-sidebar-visible me-2 d-xl-none"
              type="button"
            >
              <span></span>
              <span></span>
              <span></span>
            </button>
            <div class="site-logo">
              <a class="navbar-brand" href="index.html"
                ><img
                  class="logo me-2"
                  src="assets/images/Ampersand_Academy_Logo.svg"
                  alt="logo"
                  height="50"
              /></a>
            </div>
          </div>
          <!--//docs-logo-wrapper-->
          <div
            class="docs-top-utilities d-flex justify-content-end align-items-center"
          >
            <ul
              class="social-list list-unstyled mx-md-3 mx-lg-5 mb-0 d-none d-lg-flex"
            >
              <li class="list-inline-item">
                <a
                  href="https://www.facebook.com/AmpersandAcademy"
                  target="_blank"
                  ><i class="fab fa-facebook-f fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a
                  href="https://www.linkedin.com/company/ampersandacademy/"
                  target="_blank"
                  ><i class="fab fa-linkedin fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a
                  href="https://www.instagram.com/ampersandacad/"
                  target="_blank"
                  ><i class="fab fa-instagram fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a
                  href="https://whatsapp.com/channel/0029Va9uvHh4Ui2ZTI70bH2w"
                  target="_blank"
                  ><i class="fab fa-whatsapp fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a href="https://t.me/ampersandacad" target="_blank"
                  ><i class="fab fa-telegram fa-fw"></i
                ></a>
              </li>
            </ul>
            <!--//social-list-->
          </div>
          <!--//docs-top-utilities-->
        </div>
        <!--//container-->
      </div>
      <!--//branding-->
    </header>
    <!--//header-->

    <div class="docs-wrapper">
      <div id="docs-sidebar" class="docs-sidebar">
        <div class="top-search-box d-lg-none p-3">
          <form class="search-form">
            <input
              type="text"
              placeholder="Search the docs..."
              name="search"
              class="form-control search-input"
            />
            <button type="submit" class="btn search-btn" value="Search">
              <i class="fas fa-search"></i>
            </button>
          </form>
        </div>
        <nav id="docs-nav" class="docs-nav navbar">
          <ul class="section-items list-unstyled nav flex-column pb-3">
            <!-- Introduction Section -->
            <li class="nav-item section-title">
              <a class="nav-link scrollto" href="#section-1">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-info-circle"></i>
                </span>
                Introduction
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-1-1">What is React?</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-1-2">Why React?</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-1-3">React Ecosystem</a>
            </li>

            <!-- Getting Started Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-2">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-rocket"></i>
                </span>
                Getting Started
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-2-1"
                >Development Environment</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-2-2"
                >Creating a Vite Project</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-2-3"
                >Project Structure</a
              >
            </li>

            <!-- Elements & Rendering Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-3">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-code-branch"></i>
                </span>
                Elements & Rendering
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-3-1"
                >Rendering Elements</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-3-2">React DOM</a>
            </li>

            <!-- JSX & TSX Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-4">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-file-code"></i>
                </span>
                JSX & TSX
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-4-1"
                >Introduction to JSX/TSX</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-4-2"
                >JSX vs TSX Syntax</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-4-3"
                >Expressions in TSX</a
              >
            </li>

            <!-- Components Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-5">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-puzzle-piece"></i>
                </span>
                Components
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-5-1"
                >Functional Components</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-5-2">Component Props</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-5-3"
                >Component Composition</a
              >
            </li>

            <!-- Hooks Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-6">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-magic"></i>
                </span>
                Hooks
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-6-1">useState Hook</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-6-2">useEffect Hook</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-6-3">useContext Hook</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-6-4">useReducer Hook</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-6-5">Custom Hooks</a>
            </li>

            <!-- State Management Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-7">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-database"></i>
                </span>
                State Management
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-7-1">Local State</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-7-2">Lifting State Up</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-7-3">Context API</a>
            </li>

            <!-- Event Handling Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-8">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-mouse-pointer"></i>
                </span>
                Event Handling
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-8-1">Event Basics</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-8-2">Form Handling</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-8-3">Synthetic Events</a>
            </li>

            <!-- Lists & Keys Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-9">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-list"></i>
                </span>
                Lists & Keys
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-9-1">Rendering Lists</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-9-2">Keys in React</a>
            </li>

            <!-- Conditional Rendering Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-10">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-code-branch"></i>
                </span>
                Conditional Rendering
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-10-1">If Statements</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-10-2"
                >Ternary Operators</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-10-3"
                >Logical Operators</a
              >
            </li>
            <!-- Forms Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-11">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-edit"></i>
                </span>
                Forms
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-11-1"
                >Controlled Components</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-11-2">Form Validation</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-11-3">Form Libraries</a>
            </li>

            <!-- Styling Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-12">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-paint-brush"></i>
                </span>
                Styling
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-12-1">CSS Modules</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-12-2"
                >Styled Components</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-12-3">Tailwind CSS</a>
            </li>

            <!-- Performance Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-13">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-tachometer-alt"></i>
                </span>
                Performance
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-13-1">React.memo</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-13-2"
                >useMemo & useCallback</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-13-3">Code Splitting</a>
            </li>

            <!-- Testing Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-14">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-vial"></i>
                </span>
                Testing
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-14-1"
                >React Testing Library</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-14-2"
                >Component Testing</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-14-3">Mocking</a>
            </li>

            <!-- Best Practices Section -->
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-15">
                <span class="theme-icon-holder me-2">
                  <i class="fas fa-star"></i>
                </span>
                Best Practices
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-15-1"
                >Component Design</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-15-2"
                >Code Organization</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-15-3"
                >Error Boundaries</a
              >
            </li>
          </ul>
        </nav>
        <!--//docs-nav-->
      </div>
      <!--//docs-sidebar-->

      <!-- MAIN CONTENT AREA - PROPERLY WRAPPED -->
      <div class="docs-content">
        <div class="container">
          <!-- Introduction Section -->
          <article class="docs-article" id="section-1">
            <header class="docs-header">
              <h1 class="docs-heading">Introduction to React</h1>
              <section class="docs-intro">
                <p>
                  React is a powerful JavaScript library for building user
                  interfaces, particularly web applications. Developed by
                  Facebook (now Meta), React has revolutionized how we think
                  about building interactive UIs with its component-based
                  architecture and declarative programming model.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-1-1">
              <h2 class="section-heading">What is React?</h2>
              <p>
                React is a JavaScript library for building user interfaces. It
                allows developers to create large web applications that can
                change data, without reloading the page. React's main goal is to
                be fast, scalable, and simple.
              </p>

              <h4>Key Characteristics</h4>
              <ul>
                <li>
                  <strong>Component-Based</strong>: Build encapsulated
                  components that manage their own state
                </li>
                <li>
                  <strong>Declarative</strong>: React makes it painless to
                  create interactive UIs
                </li>
                <li>
                  <strong>Learn Once, Write Anywhere</strong>: React can be used
                  for web, mobile (React Native), and even desktop applications
                </li>
                <li>
                  <strong>Virtual DOM</strong>: React uses a virtual DOM for
                  efficient updates
                </li>
                <li>
                  <strong>One-Way Data Flow</strong>: Data flows down from
                  parent to child components
                </li>
              </ul>

              <div class="callout-block callout-block-success">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-thumbs-up"></i>
                    </span>
                    Industry Adoption
                  </h4>
                  <p>
                    React is used by many Fortune 500 companies including
                    Facebook, Netflix, Airbnb, Instagram, Uber, WhatsApp, and
                    thousands of other companies. This widespread adoption means
                    abundant job opportunities and community support.
                  </p>
                </div>
              </div>
            </section>

            <section class="docs-section" id="item-1-2">
              <h2 class="section-heading">Why React?</h2>
              <p>
                React has gained immense popularity among developers and
                companies worldwide. Here's why React is an excellent choice for
                modern web development:
              </p>

              <h4>Developer Experience</h4>
              <ul>
                <li>
                  <strong>Component Reusability</strong>: Write once, use
                  anywhere approach
                </li>
                <li>
                  <strong>Rich Ecosystem</strong>: Vast collection of libraries
                  and tools
                </li>
                <li>
                  <strong>Great Developer Tools</strong>: React DevTools, hot
                  reloading, time-travel debugging
                </li>
                <li>
                  <strong>Strong TypeScript Support</strong>: Excellent
                  integration with TypeScript
                </li>
                <li>
                  <strong>Excellent Documentation</strong>: Comprehensive and
                  well-maintained docs
                </li>
              </ul>

              <h4>Performance Benefits</h4>
              <ul>
                <li>
                  <strong>Virtual DOM</strong>: Minimizes expensive DOM
                  manipulations
                </li>
                <li>
                  <strong>Efficient Rendering</strong>: Only updates what has
                  changed
                </li>
                <li>
                  <strong>Code Splitting</strong>: Load only what's needed
                </li>
                <li>
                  <strong>Server-Side Rendering</strong>: Better SEO and initial
                  load times
                </li>
              </ul>
            </section>

            <section class="docs-section" id="item-1-3">
              <h2 class="section-heading">React Ecosystem</h2>
              <p>
                React's ecosystem is one of its strongest points. The community
                has built an extensive collection of tools, libraries, and
                frameworks that work seamlessly with React.
              </p>

              <h4>Build Tools & Bundlers</h4>
              <ul>
                <li>
                  <strong>Vite</strong>: Fast build tool with instant server
                  start
                </li>
                <li>
                  <strong>Create React App</strong>: Official way to set up
                  React projects
                </li>
                <li><strong>Webpack</strong>: Powerful module bundler</li>
                <li><strong>Parcel</strong>: Zero-configuration build tool</li>
              </ul>

              <h4>Frameworks Built on React</h4>
              <ul>
                <li>
                  <strong>Next.js</strong>: Full-stack React framework with
                  SSR/SSG
                </li>
                <li>
                  <strong>Gatsby</strong>: Static site generator for React
                </li>
                <li>
                  <strong>Remix</strong>: Full-stack web framework focused on
                  web standards
                </li>
              </ul>
            </section>
          </article>

          <!-- Getting Started Section -->
          <article class="docs-article" id="section-2">
            <header class="docs-header">
              <h1 class="docs-heading">Getting Started</h1>
              <section class="docs-intro">
                <p>
                  This section will help you set up your development environment
                  and create your first React application. We'll use Vite, a
                  next-generation build tool that provides a faster and leaner
                  development experience.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-2-1">
              <h2 class="section-heading">Development Environment</h2>
              <p>
                Before starting with React development, make sure you have the
                following prerequisites installed:
              </p>

              <ul>
                <li>
                  <strong>Node.js and npm</strong>: React development requires
                  Node.js version 18.0 or higher
                </li>
                <li>
                  <strong>Code Editor</strong>: Visual Studio Code is
                  recommended for its excellent TypeScript and React support
                </li>
                <li>
                  <strong>Browser</strong>: Chrome, Firefox, or Edge with React
                  DevTools extension installed
                </li>
              </ul>

              <h4>Installing Node.js</h4>
              <p>Download and install Node.js from the official website:</p>
              <pre><code class="language-bash"># Check if Node.js is installed
node --version

# Check npm version
npm --version</code></pre>

              <h4>Recommended VS Code Extensions</h4>
              <ul>
                <li>
                  <strong>ES7+ React/Redux/React-Native snippets</strong>:
                  Provides React code snippets
                </li>
                <li>
                  <strong>ESLint</strong>: Integrates ESLint into VS Code for
                  linting
                </li>
                <li>
                  <strong>Prettier</strong>: Code formatter to maintain
                  consistent coding style
                </li>
                <li>
                  <strong>TypeScript React code snippets</strong>: TypeScript
                  snippets for React development
                </li>
                <li>
                  <strong>Auto Rename Tag</strong>: Automatically rename paired
                  HTML/JSX tags
                </li>
                <li>
                  <strong>Bracket Pair Colorizer</strong>: Colorizes matching
                  brackets
                </li>
                <li>
                  <strong>Thunder Client</strong>: REST API client for testing
                  APIs
                </li>
              </ul>

              <div class="callout-block callout-block-info">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-info-circle"></i>
                    </span>
                    Node Version Manager
                  </h4>
                  <p>
                    Consider using NVM (Node Version Manager) to easily switch
                    between Node.js versions, which is helpful when working on
                    different projects with different Node.js requirements.
                  </p>
                </div>
              </div>
            </section>

            <section class="docs-section" id="item-2-2">
              <h2 class="section-heading">Creating a Vite Project</h2>
              <p>
                Vite (French for "quick") is a modern build tool that offers a
                faster and simpler development experience. It leverages native
                ES modules to provide instantaneous server start and fast HMR
                (Hot Module Replacement).
              </p>

              <h4>Creating a New React Project</h4>
              <p>
                Use the following command to create a new React project with
                TypeScript:
              </p>
              <pre><code class="language-bash"># Create a new React project with TypeScript
npm create vite@latest my-react-app -- --template react-ts

# Navigate to the project directory
cd my-react-app

# Install dependencies
npm install

# Start the development server
npm run dev</code></pre>

              <div class="callout-block callout-block-success">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-rocket"></i>
                    </span>
                    Lightning Fast Development
                  </h4>
                  <p>
                    Vite uses native ES modules during development, which allows
                    it to start the dev server instantly regardless of app size.
                    Changes are reflected immediately in the browser without
                    full page reloads.
                  </p>
                </div>
              </div>
            </section>

            <section class="docs-section" id="item-2-3">
              <h2 class="section-heading">Project Structure</h2>
              <p>
                After creating a project with Vite and React-TypeScript
                template, you'll see a folder structure similar to this:
              </p>

              <pre><code class="language-text">my-react-app/
├── node_modules/
├── public/
│   └── vite.svg
├── src/
│   ├── assets/
│   │   └── react.svg
│   ├── App.css
│   ├── App.tsx
│   ├── index.css
│   ├── main.tsx
│   └── vite-env.d.ts
├── .gitignore
├── index.html
├── package.json
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts</code></pre>

              <h4>Key Files and Directories</h4>
              <ul>
                <li>
                  <strong>index.html</strong>: The main HTML file that serves as
                  the entry point for your app
                </li>
                <li>
                  <strong>src/</strong>: Contains your React application source
                  code
                </li>
                <li>
                  <strong>public/</strong>: Contains static files that will be
                  served directly
                </li>
                <li>
                  <strong>package.json</strong>: Lists dependencies and contains
                  scripts
                </li>
                <li>
                  <strong>tsconfig.json</strong>: TypeScript configuration
                </li>
                <li>
                  <strong>vite.config.ts</strong>: Vite-specific configuration
                </li>
              </ul>
            </section>
          </article>

          <!-- Elements & Rendering Section -->
          <article class="docs-article" id="section-3">
            <header class="docs-header">
              <h1 class="docs-heading">Elements & Rendering</h1>
              <section class="docs-intro">
                <p>
                  React elements are the smallest building blocks of React
                  applications. Understanding how React elements are created and
                  rendered is fundamental to working with React.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-3-1">
              <h2 class="section-heading">Rendering Elements</h2>
              <p>
                React elements are the smallest building blocks of React
                applications. An element describes what you want to see on the
                screen.
              </p>

              <p><strong>Using JSX/TSX (Preferred Method):</strong></p>
              <pre><code class="language-tsx">// Using JSX/TSX
const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</code></pre>

              <h4>Rendering Elements to the DOM</h4>
              <pre><code class="language-tsx">import React from 'react';
import ReactDOM from 'react-dom/client';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
root.render(element);</code></pre>
            </section>

            <section class="docs-section" id="item-3-2">
              <h2 class="section-heading">React DOM</h2>
              <p>
                React DOM is the bridge between React elements and the browser
                DOM. It provides DOM-specific methods that can be used at the
                top level of your app.
              </p>

              <h4>ReactDOM.createRoot()</h4>
              <pre><code class="language-tsx">import { createRoot } from 'react-dom/client';

const container = document.getElementById('root')!;
const root = createRoot(container);
root.render(&lt;App /&gt;);</code></pre>
            </section>
          </article>

          <!-- JSX & TSX Section -->
          <article class="docs-article" id="section-4">
            <header class="docs-header">
              <h1 class="docs-heading">JSX & TSX</h1>
              <section class="docs-intro">
                <p>
                  JSX (JavaScript XML) and TSX (TypeScript XML) are syntax
                  extensions that allow you to write HTML-like code in your
                  JavaScript/TypeScript files. They make React code more
                  readable and expressive.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-4-1">
              <h2 class="section-heading">Introduction to JSX/TSX</h2>
              <p>
                JSX and TSX are syntax extensions for JavaScript and TypeScript
                respectively. They allow you to describe what the UI should look
                like using syntax that resembles HTML.
              </p>

              <pre><code class="language-tsx">// TSX code
const element = &lt;h1 className="greeting"&gt;Hello, world!&lt;/h1&gt;;

// Compiled JavaScript (after transformation)
const element = React.createElement(
  'h1',
  { className: 'greeting' },
  'Hello, world!'
);</code></pre>
            </section>

            <section class="docs-section" id="item-4-2">
              <h2 class="section-heading">JSX vs TSX Syntax</h2>
              <p>
                TSX extends JSX with TypeScript's type system, allowing you to
                define props types, state types, and more.
              </p>

              <h4>TSX Example (TypeScript)</h4>
              <pre><code class="language-tsx">import React from 'react';

interface GreetingProps {
  name: string;
  age?: number; // Optional prop
}

function Greeting(props: GreetingProps) {
  return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
}

export default Greeting;</code></pre>
            </section>

            <section class="docs-section" id="item-4-3">
              <h2 class="section-heading">Expressions in TSX</h2>
              <p>
                You can embed any JavaScript expression in TSX by wrapping it
                with curly braces <code>{}</code>.
              </p>

              <pre><code class="language-tsx">function Welcome({ name, age }: { name: string; age: number }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Welcome, {name}!&lt;/h1&gt;
      &lt;p&gt;You are {age} years old.&lt;/p&gt;
      &lt;p&gt;Next year you'll be {age + 1}.&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </section>
          </article>

          <!-- Components Section -->
          <article class="docs-article" id="section-5">
            <header class="docs-header">
              <h1 class="docs-heading">Components</h1>
              <section class="docs-intro">
                <p>
                  Components are the building blocks of React applications. They
                  let you split the UI into independent, reusable pieces, and
                  think about each piece in isolation.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-5-1">
              <h2 class="section-heading">Functional Components</h2>
              <p>
                Functional components are JavaScript functions that return JSX.
                They are the preferred way to write components in modern React
                applications.
              </p>

              <pre><code class="language-tsx">// Simple component without props
function Welcome() {
  return &lt;h1&gt;Hello, World!&lt;/h1&gt;;
}

// Component using props
interface WelcomeProps {
  name: string;
  age?: number;
}

function Welcome({ name, age }: WelcomeProps) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Hello, {name}!&lt;/h1&gt;
      {age && &lt;p&gt;You are {age} years old.&lt;/p&gt;}
    &lt;/div&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-5-2">
              <h2 class="section-heading">Component Props</h2>
              <p>
                Props are read-only and help you pass data from parent to child
                components.
              </p>

              <pre><code class="language-tsx">interface UserCardProps {
  name: string;
  email: string;
  avatar?: string;
  isOnline: boolean;
}

function UserCard({ name, email, avatar, isOnline }: UserCardProps) {
  return (
    &lt;div className="user-card"&gt;
      &lt;img src={avatar || '/default-avatar.png'} alt={`${name}'s avatar`} /&gt;
      &lt;h3&gt;{name}&lt;/h3&gt;
      &lt;p&gt;{email}&lt;/p&gt;
      &lt;span className={`status ${isOnline ? 'online' : 'offline'}`}&gt;
        {isOnline ? 'Online' : 'Offline'}
      &lt;/span&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-5-3">
              <h2 class="section-heading">Component Composition</h2>
              <p>
                Component composition is a powerful pattern in React that allows
                you to build complex UIs by combining simpler components.
              </p>

              <pre><code class="language-tsx">// Small, focused components
function Avatar({ src, alt }: { src: string; alt: string }) {
  return &lt;img src={src} alt={alt} className="avatar" /&gt;;
}

function UserInfo({ name, email }: { name: string; email: string }) {
  return (
    &lt;div className="user-info"&gt;
      &lt;h3&gt;{name}&lt;/h3&gt;
      &lt;p&gt;{email}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Composed component
function UserProfile({ user }: { user: { name: string; email: string; avatar: string } }) {
  return (
    &lt;div className="user-profile"&gt;
      &lt;Avatar src={user.avatar} alt={user.name} /&gt;
      &lt;UserInfo name={user.name} email={user.email} /&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </section>
          </article>

          <!-- Hooks Section -->
          <article class="docs-article" id="section-6">
            <header class="docs-header">
              <h1 class="docs-heading">Hooks</h1>
              <section class="docs-intro">
                <p>
                  Hooks are functions that let you "hook into" React state and
                  lifecycle features from functional components. They were
                  introduced in React 16.8 and have revolutionized how we write
                  React components.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-6-1">
              <h2 class="section-heading">useState Hook</h2>
              <p>
                The useState hook lets you add state to functional components.
              </p>

              <pre><code class="language-tsx">import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// With TypeScript types
function UserForm() {
  const [user, setUser] = useState&lt;{ name: string; email: string }&gt;({
    name: '',
    email: ''
  });

  const handleChange = (field: keyof typeof user, value: string) =&gt; {
    setUser(prev =&gt; ({ ...prev, [field]: value }));
  };

  return (
    &lt;form&gt;
      &lt;input 
        value={user.name}
        onChange={(e) =&gt; handleChange('name', e.target.value)}
        placeholder="Name"
      /&gt;
      &lt;input 
        value={user.email}
        onChange={(e) =&gt; handleChange('email', e.target.value)}
        placeholder="Email"
      /&gt;
    &lt;/form&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-6-2">
              <h2 class="section-heading">useEffect Hook</h2>
              <p>
                The useEffect hook lets you perform side effects in functional
                components. It serves the same purpose as componentDidMount,
                componentDidUpdate, and componentWillUnmount combined.
              </p>

              <pre><code class="language-tsx">import { useState, useEffect } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() =&gt; {
    const interval = setInterval(() =&gt; {
      setSeconds(prev =&gt; prev + 1);
    }, 1000);

    // Cleanup function
    return () =&gt; clearInterval(interval);
  }, []); // Empty dependency array = run once on mount

  return &lt;div&gt;Seconds: {seconds}&lt;/div&gt;;
}

// Effect with dependencies
function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState&lt;any&gt;(null);
  const [loading, setLoading] = useState(true);

  useEffect(() =&gt; {
    setLoading(true);
    fetch(`/api/users/${userId}`)
      .then(response =&gt; response.json())
      .then(userData =&gt; {
        setUser(userData);
        setLoading(false);
      });
  }, [userId]); // Re-run when userId changes

  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (!user) return &lt;div&gt;User not found&lt;/div&gt;;

  return &lt;div&gt;Welcome, {user.name}!&lt;/div&gt;;
}</code></pre>
            </section>

            <section class="docs-section" id="item-6-3">
              <h2 class="section-heading">useContext Hook</h2>
              <p>
                The useContext hook lets you subscribe to React context without
                introducing nesting.
              </p>

              <pre><code class="language-tsx">import { createContext, useContext, useState } from 'react';

// Create context
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () =&gt; void;
}

const ThemeContext = createContext&lt;ThemeContextType | undefined&gt;(undefined);

// Provider component
function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState&lt;'light' | 'dark'&gt;('light');
  
  const toggleTheme = () =&gt; {
    setTheme(prev =&gt; prev === 'light' ? 'dark' : 'light');
  };

  return (
    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// Custom hook to use theme
function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// Component using context
function Header() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    &lt;header className={`header ${theme}`}&gt;
      &lt;h1&gt;My App&lt;/h1&gt;
      &lt;button onClick={toggleTheme}&gt;
        Switch to {theme === 'light' ? 'dark' : 'light'} mode
      &lt;/button&gt;
    &lt;/header&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-6-4">
              <h2 class="section-heading">useReducer Hook</h2>
              <p>
                useReducer is usually preferable to useState when you have
                complex state logic that involves multiple sub-values or when
                the next state depends on the previous one.
              </p>

              <pre><code class="language-tsx">import { useReducer } from 'react';

// Define state and action types
interface State {
  count: number;
  step: number;
}

type Action = 
  | { type: 'increment' }
  | { type: 'decrement' }
  | { type: 'reset' }
  | { type: 'setStep'; payload: number };

// Reducer function
function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'increment':
      return { ...state, count: state.count + state.step };
    case 'decrement':
      return { ...state, count: state.count - state.step };
    case 'reset':
      return { ...state, count: 0 };
    case 'setStep':
      return { ...state, step: action.payload };
    default:
      throw new Error('Unknown action type');
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0, step: 1 });

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {state.count}&lt;/p&gt;
      &lt;p&gt;Step: {state.step}&lt;/p&gt;
      
      &lt;button onClick={() =&gt; dispatch({ type: 'increment' })}&gt;
        +{state.step}
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: 'decrement' })}&gt;
        -{state.step}
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: 'reset' })}&gt;
        Reset
      &lt;/button&gt;
      
      &lt;input 
        type="number" 
        value={state.step}
        onChange={(e) =&gt; dispatch({ 
          type: 'setStep', 
          payload: parseInt(e.target.value) || 1 
        })}
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-6-5">
              <h2 class="section-heading">Custom Hooks</h2>
              <p>
                Custom hooks allow you to extract component logic into reusable
                functions. A custom hook is a JavaScript function whose name
                starts with "use" and that may call other hooks.
              </p>

              <pre><code class="language-tsx">import { useState, useEffect } from 'react';

// Custom hook for fetching data
function useFetch&lt;T&gt;(url: string) {
  const [data, setData] = useState&lt;T | null&gt;(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;string | null&gt;(null);

  useEffect(() =&gt; {
    const fetchData = async () =&gt; {
      try {
        setLoading(true);
        setError(null);
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
}

// Custom hook for local storage
function useLocalStorage&lt;T&gt;(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState&lt;T&gt;(() =&gt; {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error('Error reading from localStorage:', error);
      return initialValue;
    }
  });

  const setValue = (value: T | ((val: T) =&gt; T)) =&gt; {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error('Error writing to localStorage:', error);
    }
  };

  return [storedValue, setValue] as const;
}

// Using custom hooks
function UserList() {
  const { data: users, loading, error } = useFetch&lt;any[]&gt;('/api/users');
  const [favorites, setFavorites] = useLocalStorage&lt;string[]&gt;('favoriteUsers', []);

  if (loading) return &lt;div&gt;Loading users...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  if (!users) return &lt;div&gt;No users found&lt;/div&gt;;

  const toggleFavorite = (userId: string) =&gt; {
    setFavorites(prev =&gt; 
      prev.includes(userId) 
        ? prev.filter(id =&gt; id !== userId)
        : [...prev, userId]
    );
  };

  return (
    &lt;div&gt;
      {users.map(user =&gt; (
        &lt;div key={user.id}&gt;
          &lt;span&gt;{user.name}&lt;/span&gt;
          &lt;button onClick={() =&gt; toggleFavorite(user.id)}&gt;
            {favorites.includes(user.id) ? '❤️' : '🤍'}
          &lt;/button&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-success">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-lightbulb"></i>
                    </span>
                    Hook Rules
                  </h4>
                  <p>
                    Remember the two main rules of hooks: 1) Only call hooks at
                    the top level of your React functions, never inside loops,
                    conditions, or nested functions. 2) Only call hooks from
                    React functional components or custom hooks.
                  </p>
                </div>
              </div>
            </section>
          </article>

          <!-- State Management Section -->
          <article class="docs-article" id="section-7">
            <header class="docs-header">
              <h1 class="docs-heading">State Management</h1>
              <section class="docs-intro">
                <p>
                  State management is crucial in React applications. As your app
                  grows, managing state becomes more complex. This section
                  covers local state, lifting state up, and using Context API
                  for global state management.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-7-1">
              <h2 class="section-heading">Local State</h2>
              <p>
                Local state is state that belongs to a single component. It's
                managed using the useState hook and is perfect for
                component-specific data like form inputs, toggles, or counters.
              </p>

              <h4>Basic Local State</h4>
              <pre><code class="language-tsx">import { useState } from 'react';

function TodoForm() {
  const [text, setText] = useState('');
  const [priority, setPriority] = useState<'low' | 'medium' | 'high'>('medium');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!text.trim()) return;

    setIsSubmitting(true);
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      console.log('Todo created:', { text, priority });
      setText('');
      setPriority('medium');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        type="text"
        value={text}
        onChange={(e) =&gt; setText(e.target.value)}
        placeholder="Enter todo..."
        disabled={isSubmitting}
      /&gt;
      
      &lt;select 
        value={priority} 
        onChange={(e) =&gt; setPriority(e.target.value as any)}
        disabled={isSubmitting}
      &gt;
        &lt;option value="low"&gt;Low Priority&lt;/option&gt;
        &lt;option value="medium"&gt;Medium Priority&lt;/option&gt;
        &lt;option value="high"&gt;High Priority&lt;/option&gt;
      &lt;/select&gt;
      
      &lt;button type="submit" disabled={isSubmitting || !text.trim()}&gt;
        {isSubmitting ? 'Adding...' : 'Add Todo'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

              <h4>Complex Local State with useReducer</h4>
              <pre><code class="language-tsx">import { useReducer } from 'react';

interface FormState {
  values: Record&lt;string, string&gt;;
  errors: Record&lt;string, string&gt;;
  touched: Record&lt;string, boolean&gt;;
  isSubmitting: boolean;
}

type FormAction = 
  | { type: 'SET_FIELD'; field: string; value: string }
  | { type: 'SET_ERROR'; field: string; error: string }
  | { type: 'SET_TOUCHED'; field: string }
  | { type: 'SET_SUBMITTING'; isSubmitting: boolean }
  | { type: 'RESET_FORM' };

function formReducer(state: FormState, action: FormAction): FormState {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        values: { ...state.values, [action.field]: action.value },
        errors: { ...state.errors, [action.field]: '' }
      };
    case 'SET_ERROR':
      return {
        ...state,
        errors: { ...state.errors, [action.field]: action.error }
      };
    case 'SET_TOUCHED':
      return {
        ...state,
        touched: { ...state.touched, [action.field]: true }
      };
    case 'SET_SUBMITTING':
      return { ...state, isSubmitting: action.isSubmitting };
    case 'RESET_FORM':
      return {
        values: {},
        errors: {},
        touched: {},
        isSubmitting: false
      };
    default:
      return state;
  }
}

function ContactForm() {
  const [state, dispatch] = useReducer(formReducer, {
    values: {},
    errors: {},
    touched: {},
    isSubmitting: false
  });

  const validateField = (field: string, value: string) =&gt; {
    if (field === 'email' && !value.includes('@')) {
      dispatch({ type: 'SET_ERROR', field, error: 'Invalid email address' });
    } else if (field === 'name' && value.length &lt; 2) {
      dispatch({ type: 'SET_ERROR', field, error: 'Name must be at least 2 characters' });
    }
  };

  const handleFieldChange = (field: string, value: string) =&gt; {
    dispatch({ type: 'SET_FIELD', field, value });
    validateField(field, value);
  };

  return (
    &lt;form&gt;
      &lt;input
        type="text"
        placeholder="Name"
        value={state.values.name || ''}
        onChange={(e) =&gt; handleFieldChange('name', e.target.value)}
        onBlur={() =&gt; dispatch({ type: 'SET_TOUCHED', field: 'name' })}
      /&gt;
      {state.touched.name && state.errors.name && (
        &lt;span className="error"&gt;{state.errors.name}&lt;/span&gt;
      )}
      
      &lt;input
        type="email"
        placeholder="Email"
        value={state.values.email || ''}
        onChange={(e) =&gt; handleFieldChange('email', e.target.value)}
        onBlur={() =&gt; dispatch({ type: 'SET_TOUCHED', field: 'email' })}
      /&gt;
      {state.touched.email && state.errors.email && (
        &lt;span className="error"&gt;{state.errors.email}&lt;/span&gt;
      )}
    &lt;/form&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-info">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-info-circle"></i>
                    </span>
                    When to Use Local State
                  </h4>
                  <p>
                    Use local state when the data is only needed by one
                    component and its direct children. Examples include form
                    inputs, toggles, modal open/close state, and
                    component-specific UI state.
                  </p>
                </div>
              </div>
            </section>

            <section class="docs-section" id="item-7-2">
              <h2 class="section-heading">Lifting State Up</h2>
              <p>
                When multiple components need to share state, you should lift
                the state up to their closest common ancestor. This allows data
                to flow down through props and events to flow up through
                callbacks.
              </p>

              <h4>Shared State Example</h4>
              <pre><code class="language-tsx">import { useState } from 'react';

interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

// Child component that displays todos
function TodoList({ 
  todos, 
  onToggle, 
  onDelete 
}: { 
  todos: Todo[]; 
  onToggle: (id: number) =&gt; void;
  onDelete: (id: number) =&gt; void;
}) {
  return (
    &lt;ul&gt;
      {todos.map(todo =&gt; (
        &lt;li key={todo.id}&gt;
          &lt;input
            type="checkbox"
            checked={todo.completed}
            onChange={() =&gt; onToggle(todo.id)}
          /&gt;
          &lt;span style={{ 
            textDecoration: todo.completed ? 'line-through' : 'none' 
          }}&gt;
            {todo.text}
          &lt;/span&gt;
          &lt;button onClick={() =&gt; onDelete(todo.id)}&gt;Delete&lt;/button&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// Child component for adding todos
function AddTodo({ onAdd }: { onAdd: (text: string) =&gt; void }) {
  const [text, setText] = useState('');

  const handleSubmit = (e: React.FormEvent) =&gt; {
    e.preventDefault();
    if (text.trim()) {
      onAdd(text.trim());
      setText('');
    }
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        type="text"
        value={text}
        onChange={(e) =&gt; setText(e.target.value)}
        placeholder="Add a todo..."
      /&gt;
      &lt;button type="submit"&gt;Add&lt;/button&gt;
    &lt;/form&gt;
  );
}

// Parent component that manages shared state
function TodoApp() {
  const [todos, setTodos] = useState&lt;Todo[]&gt;([
    { id: 1, text: 'Learn React', completed: false },
    { id: 2, text: 'Build an app', completed: true },
  ]);
  const [nextId, setNextId] = useState(3);

  const addTodo = (text: string) =&gt; {
    setTodos(prev =&gt; [...prev, { id: nextId, text, completed: false }]);
    setNextId(prev =&gt; prev + 1);
  };

  const toggleTodo = (id: number) =&gt; {
    setTodos(prev =&gt; prev.map(todo =&gt; 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const deleteTodo = (id: number) =&gt; {
    setTodos(prev =&gt; prev.filter(todo =&gt; todo.id !== id));
  };

  const completedCount = todos.filter(todo =&gt; todo.completed).length;

  return (
    &lt;div&gt;
      &lt;h1&gt;Todo App&lt;/h1&gt;
      &lt;p&gt;{completedCount} of {todos.length} todos completed&lt;/p&gt;
      
      &lt;AddTodo onAdd={addTodo} /&gt;
      &lt;TodoList 
        todos={todos} 
        onToggle={toggleTodo} 
        onDelete={deleteTodo} 
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>State Lifting Patterns</h4>
              <pre><code class="language-tsx">// Pattern 1: Sibling Communication
function ShoppingCart() {
  const [items, setItems] = useState&lt;CartItem[]&gt;([]);
  const [total, setTotal] = useState(0);

  const addItem = (item: CartItem) =&gt; {
    setItems(prev =&gt; [...prev, item]);
    setTotal(prev =&gt; prev + item.price);
  };

  const removeItem = (id: string) =&gt; {
    const item = items.find(i =&gt; i.id === id);
    if (item) {
      setItems(prev =&gt; prev.filter(i =&gt; i.id !== id));
      setTotal(prev =&gt; prev - item.price);
    }
  };

  return (
    &lt;div&gt;
      &lt;ProductList onAddToCart={addItem} /&gt;
      &lt;CartSummary items={items} total={total} onRemove={removeItem} /&gt;
    &lt;/div&gt;
  );
}

// Pattern 2: Grandparent-Grandchild Communication
function App() {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const [theme, setTheme] = useState&lt;'light' | 'dark'&gt;('light');

  return (
    &lt;div className={`app ${theme}`}&gt;
      &lt;Header 
        user={user} 
        theme={theme} 
        onThemeChange={setTheme}
        onLogout={() =&gt; setUser(null)}
      /&gt;
      &lt;Main user={user} /&gt;
      &lt;Footer theme={theme} /&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-warning">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-exclamation-triangle"></i>
                    </span>
                    Prop Drilling Problem
                  </h4>
                  <p>
                    When you need to pass state through many levels of
                    components, you might experience "prop drilling." This is
                    when you pass props through components that don't need them,
                    just to get them to deeply nested children. Context API can
                    help solve this problem.
                  </p>
                </div>
              </div>
            </section>

            <section class="docs-section" id="item-7-3">
              <h2 class="section-heading">Context API</h2>
              <p>
                The Context API provides a way to share values between
                components without having to explicitly pass props through every
                level of the tree. It's perfect for global state like themes,
                user authentication, or language preferences.
              </p>

              <h4>Creating and Using Context</h4>
              <pre><code class="language-tsx">import { createContext, useContext, useReducer, ReactNode } from 'react';

// Define the shape of our state
interface AppState {
  user: User | null;
  theme: 'light' | 'dark';
  language: 'en' | 'es' | 'fr';
  notifications: Notification[];
}

// Define actions
type AppAction = 
  | { type: 'LOGIN'; user: User }
  | { type: 'LOGOUT' }
  | { type: 'SET_THEME'; theme: 'light' | 'dark' }
  | { type: 'SET_LANGUAGE'; language: 'en' | 'es' | 'fr' }
  | { type: 'ADD_NOTIFICATION'; notification: Notification }
  | { type: 'REMOVE_NOTIFICATION'; id: string };

// Reducer function
function appReducer(state: AppState, action: AppAction): AppState {
  switch (action.type) {
    case 'LOGIN':
      return { ...state, user: action.user };
    case 'LOGOUT':
      return { ...state, user: null };
    case 'SET_THEME':
      return { ...state, theme: action.theme };
    case 'SET_LANGUAGE':
      return { ...state, language: action.language };
    case 'ADD_NOTIFICATION':
      return { 
        ...state, 
        notifications: [...state.notifications, action.notification] 
      };
    case 'REMOVE_NOTIFICATION':
      return {
        ...state,
        notifications: state.notifications.filter(n =&gt; n.id !== action.id)
      };
    default:
      return state;
  }
}

// Create context
interface AppContextType {
  state: AppState;
  dispatch: React.Dispatch&lt;AppAction&gt;;
}

const AppContext = createContext&lt;AppContextType | undefined&gt;(undefined);

// Provider component
function AppProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(appReducer, {
    user: null,
    theme: 'light',
    language: 'en',
    notifications: []
  });

  return (
    &lt;AppContext.Provider value={{ state, dispatch }}&gt;
      {children}
    &lt;/AppContext.Provider&gt;
  );
}

// Custom hook to use the context
function useApp() {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useApp must be used within an AppProvider');
  }
  return context;
}

// Helper hooks for specific pieces of state
function useAuth() {
  const { state, dispatch } = useApp();
  
  const login = (user: User) =&gt; {
    dispatch({ type: 'LOGIN', user });
  };
  
  const logout = () =&gt; {
    dispatch({ type: 'LOGOUT' });
  };
  
  return {
    user: state.user,
    isAuthenticated: !!state.user,
    login,
    logout
  };
}

function useTheme() {
  const { state, dispatch } = useApp();
  
  const setTheme = (theme: 'light' | 'dark') =&gt; {
    dispatch({ type: 'SET_THEME', theme });
  };
  
  const toggleTheme = () =&gt; {
    setTheme(state.theme === 'light' ? 'dark' : 'light');
  };
  
  return {
    theme: state.theme,
    setTheme,
    toggleTheme
  };
}</code></pre>

              <h4>Using Context in Components</h4>
              <pre><code class="language-tsx">// App component with provider
function App() {
  return (
    &lt;AppProvider&gt;
      &lt;Router&gt;
        &lt;Header /&gt;
        &lt;Main /&gt;
        &lt;NotificationContainer /&gt;
      &lt;/Router&gt;
    &lt;/AppProvider&gt;
  );
}

// Header component using auth and theme
function Header() {
  const { user, logout } = useAuth();
  const { theme, toggleTheme } = useTheme();

  return (
    &lt;header className={`header ${theme}`}&gt;
      &lt;h1&gt;My App&lt;/h1&gt;
      
      &lt;div&gt;
        &lt;button onClick={toggleTheme}&gt;
          {theme === 'light' ? '🌙' : '☀️'}
        &lt;/button&gt;
        
        {user ? (
          &lt;div&gt;
            &lt;span&gt;Welcome, {user.name}!&lt;/span&gt;
            &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
          &lt;/div&gt;
        ) : (
          &lt;LoginButton /&gt;
        )}
      &lt;/div&gt;
    &lt;/header&gt;
  );
}

// Deeply nested component that needs user data
function UserProfile() {
  const { user } = useAuth();
  const { theme } = useTheme();

  if (!user) {
    return &lt;div&gt;Please log in to view your profile&lt;/div&gt;;
  }

  return (
    &lt;div className={`profile ${theme}`}&gt;
      &lt;img src={user.avatar} alt={user.name} /&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Multiple Contexts</h4>
              <pre><code class="language-tsx">// Separate contexts for different concerns
const AuthContext = createContext&lt;AuthContextType | undefined&gt;(undefined);
const ThemeContext = createContext&lt;ThemeContextType | undefined&gt;(undefined);
const CartContext = createContext&lt;CartContextType | undefined&gt;(undefined);

// Compose multiple providers
function AppProviders({ children }: { children: ReactNode }) {
  return (
    &lt;AuthProvider&gt;
      &lt;ThemeProvider&gt;
        &lt;CartProvider&gt;
          {children}
        &lt;/CartProvider&gt;
      &lt;/ThemeProvider&gt;
    &lt;/AuthProvider&gt;
  );
}

// Or use a provider composition component
function ProviderComposer({ 
  contexts, 
  children 
}: { 
  contexts: Array&lt;React.ComponentType&lt;{ children: ReactNode }&gt;&gt;;
  children: ReactNode;
}) {
  return contexts.reduceRight(
    (children, Context) =&gt; &lt;Context&gt;{children}&lt;/Context&gt;,
    children
  );
}

function App() {
  return (
    &lt;ProviderComposer contexts={[AuthProvider, ThemeProvider, CartProvider]}&gt;
      &lt;Router&gt;
        &lt;Routes&gt;
          {/* Your routes */}
        &lt;/Routes&gt;
      &lt;/Router&gt;
    &lt;/ProviderComposer&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-success">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-lightbulb"></i>
                    </span>
                    Context Best Practices
                  </h4>
                  <ul class="mb-0">
                    <li>
                      Create separate contexts for different concerns (auth,
                      theme, cart)
                    </li>
                    <li>Use custom hooks to encapsulate context logic</li>
                    <li>Always provide default values and error boundaries</li>
                    <li>
                      Consider performance implications - context changes
                      re-render all consumers
                    </li>
                    <li>
                      For frequently changing state, consider alternative state
                      management solutions
                    </li>
                  </ul>
                </div>
              </div>
            </section>
          </article>

          <!-- Event Handling Section -->
          <article class="docs-article" id="section-8">
            <header class="docs-header">
              <h1 class="docs-heading">Event Handling</h1>
              <section class="docs-intro">
                <p>
                  React provides a powerful event system that normalizes events
                  across different browsers. Understanding how to handle events
                  properly is essential for building interactive React
                  applications.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-8-1">
              <h2 class="section-heading">Event Basics</h2>
              <p>
                React events are SyntheticEvents that wrap native events. They
                provide a consistent interface across all browsers and include
                all the standard event properties and methods.
              </p>

              <h4>Basic Event Handling</h4>
              <pre><code class="language-tsx">import { useState } from 'react';

function ButtonEvents() {
  const [clickCount, setClickCount] = useState(0);
  const [message, setMessage] = useState('');

  // Basic click handler
  const handleClick = () =&gt; {
    setClickCount(prev =&gt; prev + 1);
    setMessage('Button clicked!');
  };

  // Event handler with event parameter
  const handleClickWithEvent = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; {
    console.log('Event type:', event.type);
    console.log('Button clicked:', event.currentTarget.textContent);
    console.log('Mouse position:', { x: event.clientX, y: event.clientY });
    
    // Prevent default behavior (useful for links, forms)
    // event.preventDefault();
    
    // Stop event propagation
    // event.stopPropagation();
    
    setClickCount(prev =&gt; prev + 1);
  };

  // Double click handler
  const handleDoubleClick = () =&gt; {
    setMessage('Double clicked!');
    setClickCount(0); // Reset count
  };

  // Mouse enter/leave handlers
  const handleMouseEnter = () =&gt; setMessage('Mouse entered!');
  const handleMouseLeave = () =&gt; setMessage('Mouse left!');

  return (
    &lt;div&gt;
      &lt;p&gt;Click count: {clickCount}&lt;/p&gt;
      &lt;p&gt;Message: {message}&lt;/p&gt;
      
      &lt;button onClick={handleClick}&gt;
        Simple Click
      &lt;/button&gt;
      
      &lt;button onClick={handleClickWithEvent}&gt;
        Click with Event
      &lt;/button&gt;
      
      &lt;button 
        onDoubleClick={handleDoubleClick}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
      &gt;
        Multiple Events
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Keyboard Events</h4>
              <pre><code class="language-tsx">function KeyboardEvents() {
  const [input, setInput] = useState('');
  const [keys, setKeys] = useState&lt;string[]&gt;([]);

  const handleKeyDown = (event: React.KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; {
    console.log('Key pressed:', event.key);
    console.log('Key code:', event.keyCode);
    console.log('Modifiers:', {
      ctrl: event.ctrlKey,
      shift: event.shiftKey,
      alt: event.altKey,
      meta: event.metaKey
    });

    // Handle specific keys
    if (event.key === 'Enter') {
      console.log('Enter pressed! Input value:', input);
    }
    
    if (event.key === 'Escape') {
      setInput('');
      event.currentTarget.blur();
    }
    
    // Handle key combinations
    if (event.ctrlKey && event.key === 's') {
      event.preventDefault(); // Prevent browser save
      console.log('Ctrl+S pressed - saving...');
    }

    // Track pressed keys
    setKeys(prev =&gt; [...prev.slice(-9), event.key]); // Keep last 10 keys
  };

  const handleKeyUp = (event: React.KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; {
    console.log('Key released:', event.key);
  };

  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={input}
        onChange={(e) =&gt; setInput(e.target.value)}
        onKeyDown={handleKeyDown}
        onKeyUp={handleKeyUp}
        placeholder="Type something... (Try Enter, Escape, Ctrl+S)"
      /&gt;
      
      &lt;p&gt;Input value: {input}&lt;/p&gt;
      &lt;p&gt;Recent keys: {keys.join(' → ')}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Event Delegation and Bubbling</h4>
              <pre><code class="language-tsx">function EventBubbling() {
  const [log, setLog] = useState&lt;string[]&gt;([]);

  const addToLog = (message: string) =&gt; {
    setLog(prev =&gt; [...prev, `${new Date().toLocaleTimeString()}: ${message}`]);
  };

  const handleContainerClick = (event: React.MouseEvent) =&gt; {
    addToLog(`Container clicked (target: ${(event.target as HTMLElement).tagName})`);
  };

  const handleButtonClick = (event: React.MouseEvent) =&gt; {
    addToLog('Button clicked');
    // Uncomment to stop propagation
    // event.stopPropagation();
  };

  const handleStopPropagation = (event: React.MouseEvent) =&gt; {
    event.stopPropagation();
    addToLog('Button clicked (propagation stopped)');
  };

  const handlePreventDefault = (event: React.MouseEvent&lt;HTMLAnchorElement&gt;) =&gt; {
    event.preventDefault();
    addToLog('Link clicked (default prevented)');
  };

  const clearLog = () =&gt; setLog([]);

  return (
    &lt;div&gt;
      &lt;div 
        onClick={handleContainerClick}
        style={{ 
          padding: '20px', 
          border: '2px solid #ccc', 
          margin: '10px 0' 
        }}
      &gt;
        Container (click anywhere)
        
        &lt;div style={{ margin: '10px 0' }}&gt;
          &lt;button onClick={handleButtonClick}&gt;
            Normal Button (bubbles)
          &lt;/button&gt;
          
          &lt;button onClick={handleStopPropagation}&gt;
            Stop Propagation
          &lt;/button&gt;
          
          &lt;a href="#" onClick={handlePreventDefault}&gt;
            Prevented Link
          &lt;/a&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      
      &lt;button onClick={clearLog}&gt;Clear Log&lt;/button&gt;
      
      &lt;div&gt;
        &lt;h4&gt;Event Log:&lt;/h4&gt;
        &lt;ul&gt;
          {log.map((entry, index) =&gt; (
            &lt;li key={index}&gt;{entry}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-info">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-info-circle"></i>
                    </span>
                    Event Handler Naming
                  </h4>
                  <p>
                    Follow React conventions: event handlers should start with
                    "handle" followed by the event type (handleClick,
                    handleSubmit, handleChange). For props that accept event
                    handlers, use "on" prefix (onClick, onSubmit, onChange).
                  </p>
                </div>
              </div>
            </section>

            <section class="docs-section" id="item-8-2">
              <h2 class="section-heading">Form Handling</h2>
              <p>
                Form handling in React involves managing form state, validation,
                and submission. React provides controlled components where form
                data is handled by React state.
              </p>

              <h4>Controlled Form Components</h4>
              <pre><code class="language-tsx">import { useState, FormEvent } from 'react';

interface FormData {
  name: string;
  email: string;
  age: number;
  country: string;
  interests: string[];
  subscribe: boolean;
  comments: string;
}

function ContactForm() {
  const [formData, setFormData] = useState&lt;FormData&gt;({
    name: '',
    email: '',
    age: 18,
    country: '',
    interests: [],
    subscribe: false,
    comments: ''
  });

  const [errors, setErrors] = useState&lt;Partial&lt;FormData&gt;&gt;({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Generic handler for text inputs
  const handleInputChange = (event: React.ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement&gt;) =&gt; {
    const { name, value, type } = event.target;
    
    setFormData(prev =&gt; ({
      ...prev,
      [name]: type === 'number' ? parseFloat(value) || 0 : value
    }));
    
    // Clear error when user starts typing
    if (errors[name as keyof FormData]) {
      setErrors(prev =&gt; ({ ...prev, [name]: undefined }));
    }
  };

  // Handler for select dropdown
  const handleSelectChange = (event: React.ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; {
    const { name, value } = event.target;
    setFormData(prev =&gt; ({ ...prev, [name]: value }));
  };

  // Handler for checkboxes
  const handleCheckboxChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    const { name, checked } = event.target;
    setFormData(prev =&gt; ({ ...prev, [name]: checked }));
  };

  // Handler for checkbox groups (interests)
  const handleInterestChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    const { value, checked } = event.target;
    
    setFormData(prev =&gt; ({
      ...prev,
      interests: checked 
        ? [...prev.interests, value]
        : prev.interests.filter(interest =&gt; interest !== value)
    }));
  };

  // Form validation
  const validateForm = (): boolean =&gt; {
    const newErrors: Partial&lt;FormData&gt; = {};

    if (!formData.name.trim()) {
      newErrors.name = 'Name is required';
    } else if (formData.name.length &lt; 2) {
      newErrors.name = 'Name must be at least 2 characters';
    }

    if (!formData.email.trim()) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }

    if (formData.age &lt; 13) {
      newErrors.age = 'Must be at least 13 years old';
    } else if (formData.age &gt; 120) {
      newErrors.age = 'Please enter a valid age';
    }

    if (!formData.country) {
      newErrors.country = 'Please select a country';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Form submission
  const handleSubmit = async (event: FormEvent&lt;HTMLFormElement&gt;) =&gt; {
    event.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    setIsSubmitting(true);
    
    try {
      // Simulate API call
      await new Promise(resolve =&gt; setTimeout(resolve, 2000));
      console.log('Form submitted:', formData);
      
      // Reset form after successful submission
      setFormData({
        name: '',
        email: '',
        age: 18,
        country: '',
        interests: [],
        subscribe: false,
        comments: ''
      });
      
      alert('Form submitted successfully!');
    } catch (error) {
      console.error('Submission error:', error);
      alert('Submission failed. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label htmlFor="name"&gt;Name: &lt;/label&gt;
        &lt;input
          type="text"
          id="name"
          name="name"
          value={formData.name}
          onChange={handleInputChange}
          disabled={isSubmitting}
        /&gt;
        {errors.name && &lt;span className="error"&gt;{errors.name}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email: &lt;/label&gt;
        &lt;input
          type="email"
          id="email"
          name="email"
          value={formData.email}
          onChange={handleInputChange}
          disabled={isSubmitting}
        /&gt;
        {errors.email && &lt;span className="error"&gt;{errors.email}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="age"&gt;Age: &lt;/label&gt;
        &lt;input
          type="number"
          id="age"
          name="age"
          value={formData.age}
          onChange={handleInputChange}
          min="13"
          max="120"
          disabled={isSubmitting}
        /&gt;
        {errors.age && &lt;span className="error"&gt;{errors.age}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="country"&gt;Country: &lt;/label&gt;
        &lt;select
          id="country"
          name="country"
          value={formData.country}
          onChange={handleSelectChange}
          disabled={isSubmitting}
        &gt;
          &lt;option value=""&gt;Select a country&lt;/option&gt;
          &lt;option value="us"&gt;United States&lt;/option&gt;
          &lt;option value="uk"&gt;United Kingdom&lt;/option&gt;
          &lt;option value="ca"&gt;Canada&lt;/option&gt;
          &lt;option value="au"&gt;Australia&lt;/option&gt;
        &lt;/select&gt;
        {errors.country && &lt;span className="error"&gt;{errors.country}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;fieldset&gt;
          &lt;legend&gt;Interests:&lt;/legend&gt;
          {['Technology', 'Sports', 'Music', 'Travel', 'Food'].map(interest =&gt; (
            &lt;label key={interest}&gt;
              &lt;input
                type="checkbox"
                value={interest}
                checked={formData.interests.includes(interest)}
                onChange={handleInterestChange}
                disabled={isSubmitting}
              /&gt;
              {interest}
            &lt;/label&gt;
          ))}
        &lt;/fieldset&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;
          &lt;input
            type="checkbox"
            name="subscribe"
            checked={formData.subscribe}
            onChange={handleCheckboxChange}
            disabled={isSubmitting}
          /&gt;
          Subscribe to newsletter
        &lt;/label&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="comments"&gt;Comments: &lt;/label&gt;
        &lt;textarea
          id="comments"
          name="comments"
          value={formData.comments}
          onChange={handleInputChange}
          rows={4}
          disabled={isSubmitting}
        /&gt;
      &lt;/div&gt;

      &lt;button type="submit" disabled={isSubmitting}&gt;
        {isSubmitting ? 'Submitting...' : 'Submit'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

              <h4>File Upload Handling</h4>
              <pre><code class="language-tsx">function FileUpload() {
  const [selectedFiles, setSelectedFiles] = useState&lt;FileList | null&gt;(null);
  const [uploading, setUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);

  const handleFileChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    const files = event.target.files;
    setSelectedFiles(files);
    
    // Validate files
    if (files) {
      for (let i = 0; i &lt; files.length; i++) {
        const file = files[i];
        
        // Check file size (5MB limit)
        if (file.size &gt; 5 * 1024 * 1024) {
          alert(`File ${file.name} is too large. Maximum size is 5MB.`);
          event.target.value = ''; // Clear the input
          setSelectedFiles(null);
          return;
        }
        
        // Check file type
        const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'];
        if (!allowedTypes.includes(file.type)) {
          alert(`File ${file.name} is not allowed. Only JPEG, PNG, GIF, and PDF files are accepted.`);
          event.target.value = '';
          setSelectedFiles(null);
          return;
        }
      }
    }
  };

  const handleUpload = async () =&gt; {
    if (!selectedFiles) return;

    setUploading(true);
    setUploadProgress(0);

    try {
      for (let i = 0; i &lt; selectedFiles.length; i++) {
        const file = selectedFiles[i];
        const formData = new FormData();
        formData.append('file', file);

        // Simulate upload progress
        for (let progress = 0; progress &lt;= 100; progress += 10) {
          setUploadProgress(progress);
          await new Promise(resolve =&gt; setTimeout(resolve, 100));
        }

        console.log(`Uploaded: ${file.name}`);
      }
      
      alert('All files uploaded successfully!');
      setSelectedFiles(null);
      // Clear the input
      const input = document.querySelector('input[type="file"]') as HTMLInputElement;
      if (input) input.value = '';
    } catch (error) {
      console.error('Upload error:', error);
      alert('Upload failed. Please try again.');
    } finally {
      setUploading(false);
      setUploadProgress(0);
    }
  };

  const handleDrop = (event: React.DragEvent&lt;HTMLDivElement&gt;) =&gt; {
    event.preventDefault();
    const files = event.dataTransfer.files;
    setSelectedFiles(files);
  };

  const handleDragOver = (event: React.DragEvent&lt;HTMLDivElement&gt;) =&gt; {
    event.preventDefault();
  };

  return (
    &lt;div&gt;
      &lt;div
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        style={{
          border: '2px dashed #ccc',
          padding: '20px',
          textAlign: 'center',
          marginBottom: '20px'
        }}
      &gt;
        &lt;p&gt;Drag and drop files here or&lt;/p&gt;
        &lt;input
          type="file"
          multiple
          onChange={handleFileChange}
          accept=".jpg,.jpeg,.png,.gif,.pdf"
        /&gt;
      &lt;/div&gt;

      {selectedFiles && (
        &lt;div&gt;
          &lt;h4&gt;Selected Files:&lt;/h4&gt;
          &lt;ul&gt;
            {Array.from(selectedFiles).map((file, index) =&gt; (
              &lt;li key={index}&gt;
                {file.name} ({(file.size / 1024).toFixed(2)} KB)
              &lt;/li&gt;
            ))}
          &lt;/ul&gt;
          
          &lt;button onClick={handleUpload} disabled={uploading}&gt;
            {uploading ? 'Uploading...' : 'Upload Files'}
          &lt;/button&gt;
          
          {uploading && (
            &lt;div&gt;
              &lt;progress value={uploadProgress} max="100"&gt;
                {uploadProgress}%
              &lt;/progress&gt;
              &lt;span&gt;{uploadProgress}%&lt;/span&gt;
            &lt;/div&gt;
          )}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-8-3">
              <h2 class="section-heading">Synthetic Events</h2>
              <p>
                React wraps native events in SyntheticEvent objects. These
                provide a consistent interface across different browsers and
                include additional functionality while maintaining compatibility
                with native events.
              </p>

              <h4>SyntheticEvent Properties</h4>
              <pre><code class="language-tsx">function EventExplorer() {
  const [eventInfo, setEventInfo] = useState&lt;any&gt;(null);

  const handleEvent = (event: React.SyntheticEvent) =&gt; {
    // SyntheticEvent properties
    const info = {
      // Basic properties
      type: event.type,
      bubbles: event.bubbles,
      cancelable: event.cancelable,
      defaultPrevented: event.defaultPrevented,
      
      // Targets
      target: (event.target as HTMLElement).tagName,
      currentTarget: (event.currentTarget as HTMLElement).tagName,
      
      // Timing
      timeStamp: event.timeStamp,
      
      // Native event access
      nativeEvent: event.nativeEvent.constructor.name
    };

    // Mouse-specific properties (if it's a mouse event)
    if ('clientX' in event) {
      const mouseEvent = event as React.MouseEvent;
      info.mouse = {
        clientX: mouseEvent.clientX,
        clientY: mouseEvent.clientY,
        screenX: mouseEvent.screenX,
        screenY: mouseEvent.screenY,
        button: mouseEvent.button,
        buttons: mouseEvent.buttons,
        detail: mouseEvent.detail
      };
    }

    // Keyboard-specific properties (if it's a keyboard event)
    if ('key' in event) {
      const keyEvent = event as React.KeyboardEvent;
      info.keyboard = {
        key: keyEvent.key,
        code: keyEvent.code,
        keyCode: keyEvent.keyCode,
        charCode: keyEvent.charCode,
        ctrlKey: keyEvent.ctrlKey,
        shiftKey: keyEvent.shiftKey,
        altKey: keyEvent.altKey,
        metaKey: keyEvent.metaKey
      };
    }

    setEventInfo(info);
  };

  const clearInfo = () =&gt; setEventInfo(null);

  return (
    &lt;div&gt;
      &lt;h3&gt;Event Explorer&lt;/h3&gt;
      
      &lt;div style={{ margin: '20px 0' }}&gt;
        &lt;button 
          onClick={handleEvent}
          onMouseEnter={handleEvent}
          onMouseLeave={handleEvent}
          onFocus={handleEvent}
          onBlur={handleEvent}
        &gt;
          Click or Hover Me
        &lt;/button&gt;
        
        &lt;input 
          type="text"
          placeholder="Type here..."
          onKeyDown={handleEvent}
          onKeyUp={handleEvent}
          onChange={handleEvent}
          onFocus={handleEvent}
          onBlur={handleEvent}
        /&gt;
        
        &lt;button onClick={clearInfo}&gt;Clear Info&lt;/button&gt;
      &lt;/div&gt;

      {eventInfo && (
        &lt;div style={{ backgroundColor: '#f5f5f5', padding: '10px' }}&gt;
          &lt;h4&gt;Last Event Info:&lt;/h4&gt;
          &lt;pre&gt;{JSON.stringify(eventInfo, null, 2)}&lt;/pre&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Event Pooling and Persistence</h4>
              <pre><code class="language-tsx">function EventPersistence() {
  const [log, setLog] = useState&lt;string[]&gt;([]);

  const handleAsyncEvent = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; {
    // In React 17+, event pooling is removed, but it's still good practice
    // to understand how events work with async operations
    
    console.log('Immediate access:', event.type); // Works fine
    
    // For async operations, you might want to extract event data first
    const eventData = {
      type: event.type,
      target: event.currentTarget.textContent,
      timestamp: Date.now()
    };
    
    // Simulate async operation
    setTimeout(() =&gt; {
      // This would have failed in older React versions due to event pooling
      // console.log('Async access:', event.type); // Don't do this in older React
      
      // Instead, use the extracted data
      setLog(prev =&gt; [...prev, `Async: ${eventData.type} on ${eventData.target}`]);
    }, 1000);
    
    setLog(prev =&gt; [...prev, `Immediate: ${event.type} on ${event.currentTarget.textContent}`]);
  };

  const handlePersistEvent = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; {
    // In older React versions, you would call event.persist()
    // to prevent the event from being pooled
    // event.persist(); // Not needed in React 17+
    
    setTimeout(() =&gt; {
      setLog(prev =&gt; [...prev, `Persisted: ${event.type} on ${event.currentTarget.textContent}`]);
    }, 1000);
  };

  return (
    &lt;div&gt;
      &lt;h3&gt;Event Persistence Example&lt;/h3&gt;
      
      &lt;button onClick={handleAsyncEvent}&gt;
        Async Event Handler
      &lt;/button&gt;
      
      &lt;button onClick={handlePersistEvent}&gt;
        Persisted Event Handler
      &lt;/button&gt;
      
      &lt;button onClick={() =&gt; setLog([])}&gt;
        Clear Log
      &lt;/button&gt;
      
      &lt;div&gt;
        &lt;h4&gt;Event Log:&lt;/h4&gt;
        &lt;ul&gt;
          {log.map((entry, index) =&gt; (
            &lt;li key={index}&gt;{entry}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Custom Event Handlers</h4>
              <pre><code class="language-tsx">// Custom hook for handling outside clicks
function useOutsideClick(ref: React.RefObject&lt;HTMLElement&gt;, handler: () =&gt; void) {
  useEffect(() =&gt; {
    const handleClickOutside = (event: MouseEvent) =&gt; {
      if (ref.current && !ref.current.contains(event.target as Node)) {
        handler();
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () =&gt; document.removeEventListener('mousedown', handleClickOutside);
  }, [ref, handler]);
}

// Custom hook for keyboard shortcuts
function useKeyboardShortcuts(shortcuts: Record&lt;string, () =&gt; void&gt;) {
  useEffect(() =&gt; {
    const handleKeyDown = (event: KeyboardEvent) =&gt; {
      const key = [
        event.ctrlKey && 'ctrl',
        event.shiftKey && 'shift',
        event.altKey && 'alt',
        event.metaKey && 'meta',
        event.key.toLowerCase()
      ].filter(Boolean).join('+');

      if (shortcuts[key]) {
        event.preventDefault();
        shortcuts[key]();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () =&gt; window.removeEventListener('keydown', handleKeyDown);
  }, [shortcuts]);
}

// Component using custom event handlers
function Modal({ isOpen, onClose, children }: {
  isOpen: boolean;
  onClose: () =&gt; void;
  children: React.ReactNode;
}) {
  const modalRef = useRef&lt;HTMLDivElement&gt;(null);

  // Close modal when clicking outside
  useOutsideClick(modalRef, onClose);

  // Close modal with keyboard shortcuts
  useKeyboardShortcuts({
    'escape': onClose,
    'ctrl+w': onClose
  });

  if (!isOpen) return null;

  return (
    &lt;div className="modal-overlay"&gt;
      &lt;div ref={modalRef} className="modal-content"&gt;
        &lt;button onClick={onClose}&gt;×&lt;/button&gt;
        {children}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-success">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-lightbulb"></i>
                    </span>
                    Event Best Practices
                  </h4>
                  <ul class="mb-0">
                    <li>
                      Use TypeScript to get proper event typing and IntelliSense
                    </li>
                    <li>
                      Prevent default behavior and stop propagation only when
                      necessary
                    </li>
                    <li>
                      Extract event data before using it in async operations
                    </li>
                    <li>Use custom hooks to encapsulate complex event logic</li>
                    <li>
                      Always clean up event listeners in useEffect cleanup
                      functions
                    </li>
                    <li>
                      Consider accessibility when handling keyboard events
                    </li>
                  </ul>
                </div>
              </div>
            </section>
          </article>

          <!-- Lists & Keys Section -->
          <article class="docs-article" id="section-9">
            <header class="docs-header">
              <h1 class="docs-heading">Lists & Keys</h1>
              <section class="docs-intro">
                <p>
                  Rendering lists of data is a common requirement in React
                  applications. Understanding how to properly render lists and
                  use keys is crucial for performance and avoiding bugs.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-9-1">
              <h2 class="section-heading">Rendering Lists</h2>
              <p>
                In React, you can render lists by using JavaScript's map()
                function to transform arrays of data into arrays of elements.
              </p>

              <h4>Basic List Rendering</h4>
              <pre><code class="language-tsx">import { useState } from 'react';

interface Todo {
  id: number;
  text: string;
  completed: boolean;
  priority: 'low' | 'medium' | 'high';
  createdAt: Date;
}

function TodoList() {
  const [todos] = useState&lt;Todo[]&gt;([
    { 
      id: 1, 
      text: 'Learn React', 
      completed: false, 
      priority: 'high',
      createdAt: new Date('2024-01-01')
    },
    { 
      id: 2, 
      text: 'Build a project', 
      completed: true, 
      priority: 'medium',
      createdAt: new Date('2024-01-02')
    },
    { 
      id: 3, 
      text: 'Deploy to production', 
      completed: false, 
      priority: 'low',
      createdAt: new Date('2024-01-03')
    }
  ]);

  return (
    &lt;div&gt;
      &lt;h2&gt;Todo List&lt;/h2&gt;
      &lt;ul&gt;
        {todos.map(todo =&gt; (
          &lt;li key={todo.id}&gt;
            &lt;span style={{ 
              textDecoration: todo.completed ? 'line-through' : 'none',
              color: todo.priority === 'high' ? 'red' : 
                     todo.priority === 'medium' ? 'orange' : 'green'
            }}&gt;
              {todo.text}
            &lt;/span&gt;
            &lt;small&gt; (Priority: {todo.priority})&lt;/small&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Dynamic List with Actions</h4>
              <pre><code class="language-tsx">function DynamicTodoList() {
  const [todos, setTodos] = useState&lt;Todo[]&gt;([
    { id: 1, text: 'Learn React', completed: false, priority: 'high', createdAt: new Date() }
  ]);
  const [newTodo, setNewTodo] = useState('');
  const [filter, setFilter] = useState&lt;'all' | 'active' | 'completed'&gt;('all');
  const [sortBy, setSortBy] = useState&lt;'date' | 'priority' | 'text'&gt;('date');

  const addTodo = () =&gt; {
    if (newTodo.trim()) {
      const todo: Todo = {
        id: Date.now(),
        text: newTodo.trim(),
        completed: false,
        priority: 'medium',
        createdAt: new Date()
      };
      setTodos(prev =&gt; [...prev, todo]);
      setNewTodo('');
    }
  };

  const toggleTodo = (id: number) =&gt; {
    setTodos(prev =&gt; prev.map(todo =&gt; 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const deleteTodo = (id: number) =&gt; {
    setTodos(prev =&gt; prev.filter(todo =&gt; todo.id !== id));
  };

  const updatePriority = (id: number, priority: Todo['priority']) =&gt; {
    setTodos(prev =&gt; prev.map(todo =&gt; 
      todo.id === id ? { ...todo, priority } : todo
    ));
  };

  // Filter todos
  const filteredTodos = todos.filter(todo =&gt; {
    switch (filter) {
      case 'active': return !todo.completed;
      case 'completed': return todo.completed;
      default: return true;
    }
  });

  // Sort todos
  const sortedTodos = [...filteredTodos].sort((a, b) =&gt; {
    switch (sortBy) {
      case 'text':
        return a.text.localeCompare(b.text);
      case 'priority':
        const priorityOrder = { high: 3, medium: 2, low: 1 };
        return priorityOrder[b.priority] - priorityOrder[a.priority];
      case 'date':
      default:
        return b.createdAt.getTime() - a.createdAt.getTime();
    }
  });

  return (
    &lt;div&gt;
      &lt;h2&gt;Dynamic Todo List&lt;/h2&gt;
      
      {/* Add new todo */}
      &lt;div&gt;
        &lt;input
          type="text"
          value={newTodo}
          onChange={(e) =&gt; setNewTodo(e.target.value)}
          onKeyPress={(e) =&gt; e.key === 'Enter' && addTodo()}
          placeholder="Add new todo..."
        /&gt;
        &lt;button onClick={addTodo}&gt;Add&lt;/button&gt;
      &lt;/div&gt;
      
      {/* Filters and sorting */}
      &lt;div style={{ margin: '20px 0' }}&gt;
        &lt;label&gt;
          Filter: 
          &lt;select value={filter} onChange={(e) =&gt; setFilter(e.target.value as any)}&gt;
            &lt;option value="all"&gt;All&lt;/option&gt;
            &lt;option value="active"&gt;Active&lt;/option&gt;
            &lt;option value="completed"&gt;Completed&lt;/option&gt;
          &lt;/select&gt;
        &lt;/label&gt;
        
        &lt;label style={{ marginLeft: '20px' }}&gt;
          Sort by: 
          &lt;select value={sortBy} onChange={(e) =&gt; setSortBy(e.target.value as any)}&gt;
            &lt;option value="date"&gt;Date&lt;/option&gt;
            &lt;option value="priority"&gt;Priority&lt;/option&gt;
            &lt;option value="text"&gt;Text&lt;/option&gt;
          &lt;/select&gt;
        &lt;/label&gt;
      &lt;/div&gt;

      {/* Todo list */}
      &lt;ul&gt;
        {sortedTodos.map(todo =&gt; (
          &lt;li key={todo.id} style={{ margin: '10px 0', padding: '10px', border: '1px solid #ccc' }}&gt;
            &lt;div&gt;
              &lt;input
                type="checkbox"
                checked={todo.completed}
                onChange={() =&gt; toggleTodo(todo.id)}
              /&gt;
              &lt;span style={{ 
                textDecoration: todo.completed ? 'line-through' : 'none',
                marginLeft: '10px'
              }}&gt;
                {todo.text}
              &lt;/span&gt;
            &lt;/div&gt;
            
            &lt;div style={{ marginTop: '5px', fontSize: '0.8em' }}&gt;
              &lt;select
                value={todo.priority}
                onChange={(e) =&gt; updatePriority(todo.id, e.target.value as Todo['priority'])}
              &gt;
                &lt;option value="low"&gt;Low&lt;/option&gt;
                &lt;option value="medium"&gt;Medium&lt;/option&gt;
                &lt;option value="high"&gt;High&lt;/option&gt;
              &lt;/select&gt;
              
              &lt;span style={{ marginLeft: '10px' }}&gt;
                Created: {todo.createdAt.toLocaleDateString()}
              &lt;/span&gt;
              
              &lt;button 
                onClick={() =&gt; deleteTodo(todo.id)}
                style={{ marginLeft: '10px', color: 'red' }}
              &gt;
                Delete
              &lt;/button&gt;
            &lt;/div&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;

      {/* Summary */}
      &lt;div style={{ marginTop: '20px', padding: '10px', backgroundColor: '#f5f5f5' }}&gt;
        &lt;p&gt;Total: {todos.length} | Active: {todos.filter(t =&gt; !t.completed).length} | Completed: {todos.filter(t =&gt; t.completed).length}&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Nested Lists</h4>
              <pre><code class="language-tsx">interface Category {
  id: number;
  name: string;
  items: { id: number; name: string; description: string }[];
}

function NestedList() {
  const [categories] = useState&lt;Category[]&gt;([
    {
      id: 1,
      name: 'Fruits',
      items: [
        { id: 1, name: 'Apple', description: 'Red and sweet' },
        { id: 2, name: 'Banana', description: 'Yellow and soft' },
        { id: 3, name: 'Orange', description: 'Orange and juicy' }
      ]
    },
    {
      id: 2,
      name: 'Vegetables',
      items: [
        { id: 4, name: 'Carrot', description: 'Orange and crunchy' },
        { id: 5, name: 'Broccoli', description: 'Green and healthy' }
      ]
    }
  ]);

  return (
    &lt;div&gt;
      &lt;h2&gt;Nested List Example&lt;/h2&gt;
      {categories.map(category =&gt; (
        &lt;div key={category.id} style={{ marginBottom: '20px' }}&gt;
          &lt;h3&gt;{category.name}&lt;/h3&gt;
          &lt;ul&gt;
            {category.items.map(item =&gt; (
              &lt;li key={item.id}&gt;
                &lt;strong&gt;{item.name}&lt;/strong&gt;: {item.description}
              &lt;/li&gt;
            ))}
          &lt;/ul&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>

              <h4>List with Pagination</h4>
              <pre><code class="language-tsx">function PaginatedList() {
  const [items] = useState(
    Array.from({ length: 100 }, (_, i) =&gt; ({
      id: i + 1,
      name: `Item ${i + 1}`,
      description: `Description for item ${i + 1}`
    }))
  );
  
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);

  // Calculate pagination
  const totalPages = Math.ceil(items.length / itemsPerPage);
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const currentItems = items.slice(startIndex, endIndex);

  const goToPage = (page: number) =&gt; {
    setCurrentPage(Math.max(1, Math.min(page, totalPages)));
  };

  return (
    &lt;div&gt;
      &lt;h2&gt;Paginated List&lt;/h2&gt;
      
      {/* Items */}
      &lt;ul&gt;
        {currentItems.map(item =&gt; (
          &lt;li key={item.id} style={{ padding: '5px 0' }}&gt;
            &lt;strong&gt;{item.name}&lt;/strong&gt;: {item.description}
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;

      {/* Pagination controls */}
      &lt;div style={{ marginTop: '20px' }}&gt;
        &lt;button 
          onClick={() =&gt; goToPage(currentPage - 1)}
          disabled={currentPage === 1}
        &gt;
          Previous
        &lt;/button&gt;
        
        &lt;span style={{ margin: '0 10px' }}&gt;
          Page {currentPage} of {totalPages}
        &lt;/span&gt;
        
        &lt;button 
          onClick={() =&gt; goToPage(currentPage + 1)}
          disabled={currentPage === totalPages}
        &gt;
          Next
        &lt;/button&gt;
      &lt;/div&gt;

      {/* Page numbers */}
      &lt;div style={{ marginTop: '10px' }}&gt;
        {Array.from({ length: Math.min(5, totalPages) }, (_, i) =&gt; {
          const pageNum = Math.max(1, currentPage - 2) + i;
          if (pageNum &gt; totalPages) return null;
          
          return (
            &lt;button
              key={pageNum}
              onClick={() =&gt; goToPage(pageNum)}
              style={{
                margin: '0 2px',
                backgroundColor: pageNum === currentPage ? '#007bff' : '#f8f9fa',
                color: pageNum === currentPage ? 'white' : 'black'
              }}
            &gt;
              {pageNum}
            &lt;/button&gt;
          );
        })}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-9-2">
              <h2 class="section-heading">Keys in React</h2>
              <p>
                Keys help React identify which items have changed, are added, or
                are removed. Keys should be given to the elements inside the
                array to give the elements a stable identity.
              </p>

              <h4>Why Keys Matter</h4>
              <pre><code class="language-tsx">// ❌ Bad: Using array index as key
function BadKeyExample() {
  const [items, setItems] = useState(['Apple', 'Banana', 'Cherry']);

  const addItem = () =&gt; {
    setItems(prev =&gt; ['New Item', ...prev]); // Adding to beginning
  };

  return (
    &lt;div&gt;
      &lt;button onClick={addItem}&gt;Add Item to Beginning&lt;/button&gt;
      &lt;ul&gt;
        {items.map((item, index) =&gt; (
          &lt;li key={index}&gt; {/* ❌ Bad: index as key */}
            &lt;input type="text" defaultValue={item} /&gt;
            &lt;span&gt;{item}&lt;/span&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

// ✅ Good: Using stable unique keys
interface Item {
  id: string;
  name: string;
}

function GoodKeyExample() {
  const [items, setItems] = useState&lt;Item[]&gt;([
    { id: '1', name: 'Apple' },
    { id: '2', name: 'Banana' },
    { id: '3', name: 'Cherry' }
  ]);

  const addItem = () =&gt; {
    const newItem: Item = {
      id: Date.now().toString(), // Better: use UUID in real apps
      name: 'New Item'
    };
    setItems(prev =&gt; [newItem, ...prev]);
  };

  return (
    &lt;div&gt;
      &lt;button onClick={addItem}&gt;Add Item to Beginning&lt;/button&gt;
      &lt;ul&gt;
        {items.map(item =&gt; (
          &lt;li key={item.id}&gt; {/* ✅ Good: stable unique key */}
            &lt;input type="text" defaultValue={item.name} /&gt;
            &lt;span&gt;{item.name}&lt;/span&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Key Best Practices</h4>
              <pre><code class="language-tsx">// ✅ Good key strategies

// 1. Database IDs (best for data from APIs)
function UserList({ users }: { users: Array&lt;{ id: number; name: string }&gt; }) {
  return (
    &lt;ul&gt;
      {users.map(user =&gt; (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt; // ✅ Database ID
      ))}
    &lt;/ul&gt;
  );
}

// 2. Composite keys for nested data
function OrderList({ orders }: { 
  orders: Array&lt;{ 
    id: string; 
    items: Array&lt;{ productId: string; quantity: number }&gt; 
  }&gt; 
}) {
  return (
    &lt;div&gt;
      {orders.map(order =&gt; (
        &lt;div key={order.id}&gt;
          &lt;h3&gt;Order {order.id}&lt;/h3&gt;
          &lt;ul&gt;
            {order.items.map(item =&gt; (
              &lt;li key={`${order.id}-${item.productId}`}&gt; {/* ✅ Composite key */}
                Product {item.productId}: {item.quantity}
              &lt;/li&gt;
            ))}
          &lt;/ul&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}

// 3. Content-based keys (when no ID available)
function TagList({ tags }: { tags: string[] }) {
  return (
    &lt;div&gt;
      {tags.map(tag =&gt; (
        &lt;span key={tag} className="tag"&gt; {/* ✅ Content as key (if unique) */}
          {tag}
        &lt;/span&gt;
      ))}
    &lt;/div&gt;
  );
}

// 4. Generated keys for static lists
function NavigationMenu() {
  const menuItems = [
    { label: 'Home', path: '/' },
    { label: 'About', path: '/about' },
    { label: 'Contact', path: '/contact' }
  ];

  return (
    &lt;nav&gt;
      {menuItems.map(item =&gt; (
        &lt;a key={item.path} href={item.path}&gt; {/* ✅ Path as key */}
          {item.label}
        &lt;/a&gt;
      ))}
    &lt;/nav&gt;
  );
}</code></pre>

              <h4>When Index Keys Are Acceptable</h4>
              <pre><code class="language-tsx">// ✅ Acceptable use of index as key
function StaticList() {
  // When the list is static and never reordered
  const steps = [
    'Preheat the oven to 350°F',
    'Mix the dry ingredients',
    'Add wet ingredients',
    'Bake for 25 minutes'
  ];

  return (
    &lt;ol&gt;
      {steps.map((step, index) =&gt; (
        &lt;li key={index}&gt;{step}&lt;/li&gt; {/* ✅ OK for static lists */}
      ))}
    &lt;/ol&gt;
  );
}

// ✅ Acceptable for read-only data that won't change
function ColorPalette() {
  const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00'];
  
  return (
    &lt;div&gt;
      {colors.map((color, index) =&gt; (
        &lt;div 
          key={index} {/* ✅ OK for static, read-only data */}
          style={{ 
            backgroundColor: color, 
            width: '50px', 
            height: '50px',
            display: 'inline-block' 
          }} 
        /&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-warning">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-exclamation-triangle"></i>
                    </span>
                    Key Anti-patterns
                  </h4>
                  <ul class="mb-0">
                    <li>
                      <strong>Don't use random values:</strong> Math.random()
                      will cause unnecessary re-renders
                    </li>
                    <li>
                      <strong>Don't use array index for dynamic lists:</strong>
                      Can cause state bugs and performance issues
                    </li>
                    <li>
                      <strong>Don't use object references:</strong> {} !== {}
                      even if they have the same content
                    </li>
                    <li>
                      <strong>Keys must be unique among siblings:</strong> They
                      don't need to be globally unique
                    </li>
                  </ul>
                </div>
              </div>
            </section>
          </article>

          <!-- Conditional Rendering Section -->
          <article class="docs-article" id="section-10">
            <header class="docs-header">
              <h1 class="docs-heading">Conditional Rendering</h1>
              <section class="docs-intro">
                <p>
                  In React, you can create distinct components that encapsulate
                  behavior you need. Then, you can render only some of them,
                  depending on the state of your application.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-10-1">
              <h2 class="section-heading">If Statements</h2>
              <p>
                You can use variables and if statements to conditionally render
                components. This is the most straightforward approach for
                complex conditional logic.
              </p>

              <h4>Basic Conditional Rendering</h4>
              <pre><code class="language-tsx">import { useState } from 'react';

interface User {
  id: number;
  name: string;
  email: string;
  role: 'admin' | 'user' | 'guest';
  isActive: boolean;
}

function UserGreeting({ user }: { user: User | null }) {
  // Early return pattern
  if (!user) {
    return &lt;div&gt;Please log in to continue.&lt;/div&gt;;
  }

  if (!user.isActive) {
    return (
      &lt;div className="warning"&gt;
        Your account is inactive. Please contact support.
      &lt;/div&gt;
    );
  }

  // Main render
  return (
    &lt;div&gt;
      &lt;h2&gt;Welcome back, {user.name}!&lt;/h2&gt;
      &lt;p&gt;Email: {user.email}&lt;/p&gt;
      &lt;p&gt;Role: {user.role}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Using conditional rendering with variables
function Dashboard() {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;string | null&gt;(null);

  // Simulate loading user data
  useEffect(() =&gt; {
    setTimeout(() =&gt; {
      try {
        // Simulate successful login
        setUser({
          id: 1,
          name: 'John Doe',
          email: 'john@example.com',
          role: 'admin',
          isActive: true
        });
      } catch (err) {
        setError('Failed to load user data');
      } finally {
        setLoading(false);
      }
    }, 2000);
  }, []);

  // Conditional rendering with if statements
  let content;
  
  if (loading) {
    content = &lt;div&gt;Loading...&lt;/div&gt;;
  } else if (error) {
    content = &lt;div className="error"&gt;Error: {error}&lt;/div&gt;;
  } else if (!user) {
    content = &lt;div&gt;No user data available&lt;/div&gt;;
  } else {
    content = (
      &lt;div&gt;
        &lt;UserGreeting user={user} /&gt;
        {user.role === 'admin' && (
          &lt;div&gt;
            &lt;h3&gt;Admin Panel&lt;/h3&gt;
            &lt;button&gt;Manage Users&lt;/button&gt;
            &lt;button&gt;View Reports&lt;/button&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className="dashboard"&gt;
      &lt;h1&gt;Dashboard&lt;/h1&gt;
      {content}
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Component-based Conditional Rendering</h4>
              <pre><code class="language-tsx">// Separate components for different states
function LoadingSpinner() {
  return (
    &lt;div style={{ textAlign: 'center', padding: '20px' }}&gt;
      &lt;div&gt;🔄 Loading...&lt;/div&gt;
    &lt;/div&gt;
  );
}

function ErrorMessage({ message, onRetry }: { message: string; onRetry?: () =&gt; void }) {
  return (
    &lt;div style={{ color: 'red', padding: '20px', textAlign: 'center' }}&gt;
      &lt;p&gt;❌ {message}&lt;/p&gt;
      {onRetry && &lt;button onClick={onRetry}&gt;Retry&lt;/button&gt;}
    &lt;/div&gt;
  );
}

function EmptyState({ message, action }: { 
  message: string; 
  action?: { label: string; onClick: () =&gt; void } 
}) {
  return (
    &lt;div style={{ textAlign: 'center', padding: '40px' }}&gt;
      &lt;p&gt;{message}&lt;/p&gt;
      {action && (
        &lt;button onClick={action.onClick}&gt;{action.label}&lt;/button&gt;
      )}
    &lt;/div&gt;
  );
}

// Main component using conditional rendering
function ProductList() {
  const [products, setProducts] = useState&lt;any[]&gt;([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;string | null&gt;(null);

  const loadProducts = async () =&gt; {
    setLoading(true);
    setError(null);
    
    try {
      // Simulate API call
      await new Promise(resolve =&gt; setTimeout(resolve, 1000));
      setProducts([]); // Simulate empty result
    } catch (err) {
      setError('Failed to load products');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() =&gt; {
    loadProducts();
  }, []);

  // Conditional rendering with components
  if (loading) {
    return &lt;LoadingSpinner /&gt;;
  }

  if (error) {
    return &lt;ErrorMessage message={error} onRetry={loadProducts} /&gt;;
  }

  if (products.length === 0) {
    return (
      &lt;EmptyState 
        message="No products found" 
        action={{ label: 'Add Product', onClick: () =&gt; console.log('Add product') }}
      /&gt;
    );
  }

  return (
    &lt;div&gt;
      {products.map(product =&gt; (
        &lt;div key={product.id}&gt;{product.name}&lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-10-2">
              <h2 class="section-heading">Ternary Operators</h2>
              <p>
                The ternary operator (condition ? trueValue : falseValue) is
                useful for simple conditional rendering inline within JSX.
              </p>

              <h4>Basic Ternary Operations</h4>
              <pre><code class="language-tsx">function UserStatus({ user }: { user: User | null }) {
  return (
    &lt;div&gt;
      {/* Simple condition */}
      {user ? (
        &lt;span&gt;Welcome, {user.name}!&lt;/span&gt;
      ) : (
        &lt;span&gt;Please log in&lt;/span&gt;
      )}
      
      {/* Nested ternary (use sparingly) */}
      &lt;div&gt;
        Status: {
          user ? (
            user.isActive ? (
              &lt;span style={{ color: 'green' }}&gt;Active&lt;/span&gt;
            ) : (
              &lt;span style={{ color: 'red' }}&gt;Inactive&lt;/span&gt;
            )
          ) : (
            &lt;span style={{ color: 'gray' }}&gt;Unknown&lt;/span&gt;
          )
        }
      &lt;/div&gt;
      
      {/* Conditional styling */}
      &lt;button 
        style={{
          backgroundColor: user?.isActive ? '#4CAF50' : '#f44336',
          color: 'white'
        }}
      &gt;
        {user?.isActive ? 'Deactivate' : 'Activate'}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Ternary with Complex JSX</h4>
              <pre><code class="language-tsx">function BlogPost({ post, user }: { 
  post: { id: number; title: string; content: string; authorId: number }; 
  user: User | null 
}) {
  const isAuthor = user && user.id === post.authorId;
  const canEdit = user && (user.role === 'admin' || isAuthor);

  return (
    &lt;article&gt;
      &lt;h1&gt;{post.title}&lt;/h1&gt;
      &lt;div&gt;{post.content}&lt;/div&gt;
      
      {/* Complex conditional rendering */}
      {canEdit ? (
        &lt;div className="post-actions"&gt;
          &lt;button&gt;Edit&lt;/button&gt;
          &lt;button&gt;Delete&lt;/button&gt;
          {user?.role === 'admin' && (
            &lt;button&gt;Admin Actions&lt;/button&gt;
          )}
        &lt;/div&gt;
      ) : (
        user ? (
          &lt;div&gt;
            &lt;button&gt;Like&lt;/button&gt;
            &lt;button&gt;Share&lt;/button&gt;
          &lt;/div&gt;
        ) : (
          &lt;div&gt;
            &lt;p&gt;Please log in to interact with this post&lt;/p&gt;
            &lt;button&gt;Login&lt;/button&gt;
          &lt;/div&gt;
        )
      )}
      
      {/* Inline conditional content */}
      &lt;p&gt;
        This post has {post.content.length} characters
        {post.content.length &gt; 1000 ? ' (long read)' : ' (quick read)'}
      &lt;/p&gt;
    &lt;/article&gt;
  );
}</code></pre>

              <h4>Ternary Best Practices</h4>
              <pre><code class="language-tsx">function BestPracticesExample({ user, posts }: { 
  user: User | null; 
  posts: any[] 
}) {
  // ✅ Good: Simple ternary
  const greeting = user ? `Hello, ${user.name}` : 'Hello, Guest';
  
  // ✅ Good: Extract complex conditions
  const showAdminPanel = user?.role === 'admin' && user.isActive;
  const hasContent = posts && posts.length &gt; 0;
  
  return (
    &lt;div&gt;
      &lt;h1&gt;{greeting}&lt;/h1&gt;
      
      {/* ✅ Good: Simple inline ternary */}
      &lt;p&gt;You have {posts.length} {posts.length === 1 ? 'post' : 'posts'}&lt;/p&gt;
      
      {/* ✅ Good: Use variables for complex conditions */}
      {showAdminPanel && (
        &lt;div&gt;Admin Panel Content&lt;/div&gt;
      )}
      
      {/* ✅ Good: Clear intent with extracted variable */}
      {hasContent ? (
        &lt;div&gt;Posts list here&lt;/div&gt;
      ) : (
        &lt;div&gt;No posts available&lt;/div&gt;
      )}
      
      {/* ❌ Avoid: Too complex nested ternary */}
      {/* 
      {user ? (
        user.isActive ? (
          user.role === 'admin' ? (
            &lt;AdminDashboard /&gt;
          ) : (
            &lt;UserDashboard /&gt;
          )
        ) : (
          &lt;InactiveMessage /&gt;
        )
      ) : (
        &lt;LoginForm /&gt;
      )}
      */}
      
      {/* ✅ Better: Use if statements or separate function */}
      {renderDashboard(user)}
    &lt;/div&gt;
  );
  
  function renderDashboard(user: User | null) {
    if (!user) return &lt;LoginForm /&gt;;
    if (!user.isActive) return &lt;InactiveMessage /&gt;;
    if (user.role === 'admin') return &lt;AdminDashboard /&gt;;
    return &lt;UserDashboard /&gt;;
  }
}</code></pre>
            </section>

            <section class="docs-section" id="item-10-3">
              <h2 class="section-heading">Logical Operators</h2>
              <p>
                You can use JavaScript logical operators && and || for
                conditional rendering. The && operator is particularly useful
                for conditionally including an element.
              </p>

              <h4>Logical AND (&&) Operator</h4>
              <pre><code class="language-tsx">function NotificationCenter({ notifications, user }: { 
  notifications: Array&lt;{ id: number; message: string; type: 'info' | 'warning' | 'error' }&gt;;
  user: User | null;
}) {
  const unreadCount = notifications.length;

  return (
    &lt;div&gt;
      &lt;h2&gt;Notifications&lt;/h2&gt;
      
      {/* Simple conditional rendering */}
      {user && &lt;p&gt;Welcome back, {user.name}!&lt;/p&gt;}
      
      {/* Conditional with count */}
      {unreadCount &gt; 0 && (
        &lt;div className="notification-badge"&gt;
          {unreadCount} unread notifications
        &lt;/div&gt;
      )}
      
      {/* Multiple conditions */}
      {user && user.role === 'admin' && (
        &lt;button&gt;Admin: Clear All Notifications&lt;/button&gt;
      )}
      
      {/* Conditional list rendering */}
      {notifications.length > 0 && (
        &lt;ul&gt;
          {notifications.map(notification =&gt; (
            &lt;li 
              key={notification.id}
              style={{
                color: notification.type === 'error' ? 'red' : 
                       notification.type === 'warning' ? 'orange' : 'blue'
              }}
            &gt;
              {notification.message}
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
      
      {/* Warning about empty state */}
      {notifications.length === 0 && (
        &lt;p&gt;No notifications to display&lt;/p&gt;
      )}
      
      {/* Complex conditional with function call */}
      {user && isBusinessHours() && (
        &lt;div className="live-chat"&gt;
          &lt;button&gt;Start Live Chat&lt;/button&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
  
  function isBusinessHours(): boolean {
    const now = new Date();
    const hour = now.getHours();
    return hour >= 9 && hour <= 17; // 9 AM to 5 PM
  }
}</code></pre>

              <h4>Logical OR (||) Operator</h4>
              <pre><code class="language-tsx">function UserProfile({ user }: { user: Partial&lt;User&gt; }) {
  return (
    &lt;div&gt;
      {/* Fallback values with || */}
      &lt;h1&gt;{user.name || 'Anonymous User'}&lt;/h1&gt;
      &lt;p&gt;Email: {user.email || 'No email provided'}&lt;/p&gt;
      &lt;p&gt;Role: {user.role || 'guest'}&lt;/p&gt;
      
      {/* Fallback components */}
      {user.avatar || &lt;div className="default-avatar"&gt;👤&lt;/div&gt;}
      
      {/* Complex fallback with ternary + || */}
      &lt;div&gt;
        Status: {
          user.isActive !== undefined 
            ? (user.isActive ? 'Active' : 'Inactive')
            : 'Unknown'
        }
      &lt;/div&gt;
      
      {/* Fallback for arrays */}
      &lt;div&gt;
        Interests: {
          (user.interests && user.interests.length > 0)
            ? user.interests.join(', ')
            : 'No interests specified'
        }
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Common Pitfalls and Solutions</h4>
              <pre><code class="language-tsx">function CommonPitfalls({ items, count }: { 
  items: string[]; 
  count: number;
}) {
  return (
    &lt;div&gt;
      {/* ❌ Pitfall: 0 renders as "0" instead of nothing */}
      {count && &lt;div&gt;You have {count} items&lt;/div&gt;}
      
      {/* ✅ Solution: Explicit comparison */}
      {count > 0 && &lt;div&gt;You have {count} items&lt;/div&gt;}
      
      {/* ❌ Pitfall: Empty string renders as empty space */}
      {items.length && &lt;div&gt;Items: {items.join(', ')}&lt;/div&gt;}
      
      {/* ✅ Solution: Explicit length check */}
      {items.length > 0 && &lt;div&gt;Items: {items.join(', ')}&lt;/div&gt;}
      
      {/* ❌ Pitfall: NaN renders as "NaN" */}
      {count && count / 2 && &lt;div&gt;Half: {count / 2}&lt;/div&gt;}
      
      {/* ✅ Solution: Proper validation */}
      {count > 0 && !isNaN(count / 2) && &lt;div&gt;Half: {count / 2}&lt;/div&gt;}
      
      {/* ✅ Safe null/undefined checks */}
      {items?.length > 0 && (
        &lt;ul&gt;
          {items.map((item, index) =&gt; (
            &lt;li key={index}&gt;{item}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Advanced Conditional Patterns</h4>
              <pre><code class="language-tsx">// Higher-order component for conditional rendering
function withConditionalRender&lt;P extends object&gt;(
  WrappedComponent: React.ComponentType&lt;P&gt;,
  condition: (props: P) =&gt; boolean,
  fallback?: React.ComponentType&lt;P&gt;
) {
  return function ConditionalComponent(props: P) {
    if (condition(props)) {
      return &lt;WrappedComponent {...props} /&gt;;
    }
    
    if (fallback) {
      const FallbackComponent = fallback;
      return &lt;FallbackComponent {...props} /&gt;;
    }
    
    return null;
  };
}

// Usage
const ConditionalUserProfile = withConditionalRender(
  UserProfile,
  (props: { user: User | null }) =&gt; props.user !== null,
  () =&gt; &lt;div&gt;Please log in to view profile&lt;/div&gt;
);

// Render prop pattern for conditional logic
function ConditionalRender&lt;T&gt;({ 
  condition, 
  children, 
  fallback 
}: {
  condition: T | boolean;
  children: (value: T) =&gt; React.ReactNode;
  fallback?: React.ReactNode;
}) {
  if (condition) {
    return &lt;&gt;{children(condition as T)}&lt;/&gt;;
  }
  
  return &lt;&gt;{fallback}&lt;/&gt;;
}

// Usage example
function App() {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  
  return (
    &lt;div&gt;
      &lt;ConditionalRender
        condition={user}
        fallback={&lt;div&gt;Loading user...&lt;/div&gt;}
      &gt;
        {(user) =&gt; (
          &lt;div&gt;
            &lt;h1&gt;Welcome, {user.name}!&lt;/h1&gt;
            &lt;p&gt;Role: {user.role}&lt;/p&gt;
          &lt;/div&gt;
        )}
      &lt;/ConditionalRender&gt;
      
      {/* Switch-like pattern with object */}
      {(() =&gt; {
        const renderByRole = {
          admin: () =&gt; &lt;AdminDashboard /&gt;,
          user: () =&gt; &lt;UserDashboard /&gt;,
          guest: () =&gt; &lt;GuestWelcome /&gt;
        };
        
        const role = user?.role || 'guest';
        const Component = renderByRole[role];
        return Component ? Component() : &lt;div&gt;Unknown role&lt;/div&gt;;
      })()}
    &lt;/div&gt;
  );
}

// Custom hook for conditional logic
function useConditionalRender(conditions: Record&lt;string, boolean&gt;) {
  const renderIf = (key: string, component: React.ReactNode) =&gt; {
    return conditions[key] ? component : null;
  };
  
  const renderUnless = (key: string, component: React.ReactNode) =&gt; {
    return !conditions[key] ? component : null;
  };
  
  return { renderIf, renderUnless, conditions };
}

// Usage of custom hook
function FeatureFlags() {
  const features = {
    newDesign: true,
    betaFeatures: false,
    adminPanel: true
  };
  
  const { renderIf, renderUnless } = useConditionalRender(features);
  
  return (
    &lt;div&gt;
      {renderIf('newDesign', &lt;div&gt;🎨 New design is enabled&lt;/div&gt;)}
      {renderUnless('betaFeatures', &lt;div&gt;Beta features are disabled&lt;/div&gt;)}
      {renderIf('adminPanel', &lt;button&gt;Admin Panel&lt;/button&gt;)}
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-success">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-lightbulb"></i>
                    </span>
                    Conditional Rendering Best Practices
                  </h4>
                  <ul class="mb-0">
                    <li>
                      <strong>Keep it simple:</strong> Prefer simple conditions
                      over complex nested ternaries
                    </li>
                    <li>
                      <strong>Extract logic:</strong> Move complex conditions to
                      variables or functions
                    </li>
                    <li>
                      <strong>Use early returns:</strong> Return early for
                      simpler component logic
                    </li>
                    <li>
                      <strong>Be explicit:</strong> Use explicit comparisons
                      (count > 0) instead of truthy checks
                    </li>
                    <li>
                      <strong>Consider performance:</strong> Conditional
                      rendering can help optimize by not rendering unnecessary
                      components
                    </li>
                    <li>
                      <strong>Handle edge cases:</strong> Always consider null,
                      undefined, 0, and empty string cases
                    </li>
                  </ul>
                </div>
              </div>
            </section>
          </article>

          <!-- Forms Section -->
          <article class="docs-article" id="section-11">
            <header class="docs-header">
              <h1 class="docs-heading">Forms</h1>
              <section class="docs-intro">
                <p>
                  Forms are essential for user interaction in web applications.
                  React provides controlled components for handling form state,
                  validation, and submission in a predictable way.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-11-1">
              <h2 class="section-heading">Controlled Components</h2>
              <p>
                In React, form elements are controlled components where the form
                data is handled by React state. This gives you full control over
                the form data and validation.
              </p>

              <h4>Basic Controlled Form</h4>
              <pre><code class="language-tsx">import { useState, FormEvent } from 'react';

interface ContactFormData {
  name: string;
  email: string;
  message: string;
  category: string;
  newsletter: boolean;
  rating: number;
}

function ContactForm() {
  const [formData, setFormData] = useState&lt;ContactFormData&gt;({
    name: '',
    email: '',
    message: '',
    category: 'general',
    newsletter: false,
    rating: 5
  });

  const [isSubmitting, setIsSubmitting] = useState(false);

  // Generic input handler
  const handleInputChange = (
    event: React.ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement&gt;
  ) =&gt; {
    const { name, value, type } = event.target;
    
    setFormData(prev =&gt; ({
      ...prev,
      [name]: type === 'checkbox' 
        ? (event.target as HTMLInputElement).checked
        : type === 'number'
        ? parseFloat(value) || 0
        : value
    }));
  };

  const handleSubmit = async (event: FormEvent&lt;HTMLFormElement&gt;) =&gt; {
    event.preventDefault();
    setIsSubmitting(true);

    try {
      // Simulate API call
      await new Promise(resolve =&gt; setTimeout(resolve, 2000));
      console.log('Form submitted:', formData);
      alert('Form submitted successfully!');
      
      // Reset form
      setFormData({
        name: '',
        email: '',
        message: '',
        category: 'general',
        newsletter: false,
        rating: 5
      });
    } catch (error) {
      console.error('Submission error:', error);
      alert('Failed to submit form');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label htmlFor="name"&gt;Name:&lt;/label&gt;
        &lt;input
          type="text"
          id="name"
          name="name"
          value={formData.name}
          onChange={handleInputChange}
          required
          disabled={isSubmitting}
        /&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email:&lt;/label&gt;
        &lt;input
          type="email"
          id="email"
          name="email"
          value={formData.email}
          onChange={handleInputChange}
          required
          disabled={isSubmitting}
        /&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="category"&gt;Category:&lt;/label&gt;
        &lt;select
          id="category"
          name="category"
          value={formData.category}
          onChange={handleInputChange}
          disabled={isSubmitting}
        &gt;
          &lt;option value="general"&gt;General Inquiry&lt;/option&gt;
          &lt;option value="support"&gt;Support&lt;/option&gt;
          &lt;option value="sales"&gt;Sales&lt;/option&gt;
          &lt;option value="feedback"&gt;Feedback&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="message"&gt;Message:&lt;/label&gt;
        &lt;textarea
          id="message"
          name="message"
          value={formData.message}
          onChange={handleInputChange}
          rows={4}
          required
          disabled={isSubmitting}
        /&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="rating"&gt;Rating (1-10):&lt;/label&gt;
        &lt;input
          type="range"
          id="rating"
          name="rating"
          min="1"
          max="10"
          value={formData.rating}
          onChange={handleInputChange}
          disabled={isSubmitting}
        /&gt;
        &lt;span&gt;{formData.rating}/10&lt;/span&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;
          &lt;input
            type="checkbox"
            name="newsletter"
            checked={formData.newsletter}
            onChange={handleInputChange}
            disabled={isSubmitting}
          /&gt;
          Subscribe to newsletter
        &lt;/label&gt;
      &lt;/div&gt;

      &lt;button type="submit" disabled={isSubmitting}&gt;
        {isSubmitting ? 'Submitting...' : 'Submit'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

              <h4>Custom Form Hook</h4>
              <pre><code class="language-tsx">// Reusable form hook
function useForm&lt;T extends Record&lt;string, any&gt;&gt;(
  initialValues: T,
  validationRules?: Partial&lt;Record&lt;keyof T, (value: any) =&gt; string | null&gt;&gt;
) {
  const [values, setValues] = useState&lt;T&gt;(initialValues);
  const [errors, setErrors] = useState&lt;Partial&lt;Record&lt;keyof T, string&gt;&gt;&gt;({});
  const [touched, setTouched] = useState&lt;Partial&lt;Record&lt;keyof T, boolean&gt;&gt;&gt;({});

  const setValue = (name: keyof T, value: any) =&gt; {
    setValues(prev =&gt; ({ ...prev, [name]: value }));
    
    // Clear error when user starts typing
    if (errors[name]) {
      setErrors(prev =&gt; ({ ...prev, [name]: undefined }));
    }
  };

  const setFieldTouched = (name: keyof T, isTouched = true) =&gt; {
    setTouched(prev =&gt; ({ ...prev, [name]: isTouched }));
  };

  const validateField = (name: keyof T, value: any) =&gt; {
    if (validationRules && validationRules[name]) {
      const error = validationRules[name]!(value);
      setErrors(prev =&gt; ({ ...prev, [name]: error }));
      return error;
    }
    return null;
  };

  const validateAll = () =&gt; {
    if (!validationRules) return true;
    
    const newErrors: Partial&lt;Record&lt;keyof T, string&gt;&gt; = {};
    let isValid = true;

    Object.keys(validationRules).forEach(key =&gt; {
      const error = validationRules[key as keyof T]!(values[key as keyof T]);
      if (error) {
        newErrors[key as keyof T] = error;
        isValid = false;
      }
    });

    setErrors(newErrors);
    return isValid;
  };

  const handleChange = (event: React.ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement&gt;) =&gt; {
    const { name, value, type } = event.target;
    const fieldValue = type === 'checkbox' 
      ? (event.target as HTMLInputElement).checked
      : type === 'number'
      ? parseFloat(value) || 0
      : value;

    setValue(name as keyof T, fieldValue);
  };

  const handleBlur = (event: React.FocusEvent&lt;HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement&gt;) =&gt; {
    const { name, value } = event.target;
    setFieldTouched(name as keyof T);
    validateField(name as keyof T, value);
  };

  const reset = () =&gt; {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  };

  return {
    values,
    errors,
    touched,
    setValue,
    setFieldTouched,
    validateField,
    validateAll,
    handleChange,
    handleBlur,
    reset
  };
}

// Usage example
function RegistrationForm() {
  const validationRules = {
    username: (value: string) =&gt; {
      if (!value) return 'Username is required';
      if (value.length &lt; 3) return 'Username must be at least 3 characters';
      if (!/^[a-zA-Z0-9_]+$/.test(value)) return 'Username can only contain letters, numbers, and underscores';
      return null;
    },
    email: (value: string) =&gt; {
      if (!value) return 'Email is required';
      if (!/\S+@\S+\.\S+/.test(value)) return 'Email is invalid';
      return null;
    },
    password: (value: string) =&gt; {
      if (!value) return 'Password is required';
      if (value.length &lt; 8) return 'Password must be at least 8 characters';
      if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(value)) {
        return 'Password must contain uppercase, lowercase, and number';
      }
      return null;
    },
    confirmPassword: (value: string) =&gt; {
      if (!value) return 'Please confirm your password';
      if (value !== form.values.password) return 'Passwords do not match';
      return null;
    }
  };

  const form = useForm({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
    agreeToTerms: false
  }, validationRules);

  const handleSubmit = async (event: FormEvent) =&gt; {
    event.preventDefault();
    
    if (!form.validateAll()) {
      return;
    }

    if (!form.values.agreeToTerms) {
      alert('Please agree to the terms and conditions');
      return;
    }

    console.log('Registration data:', form.values);
    form.reset();
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label htmlFor="username"&gt;Username:&lt;/label&gt;
        &lt;input
          type="text"
          id="username"
          name="username"
          value={form.values.username}
          onChange={form.handleChange}
          onBlur={form.handleBlur}
        /&gt;
        {form.touched.username && form.errors.username && (
          &lt;span className="error"&gt;{form.errors.username}&lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email:&lt;/label&gt;
        &lt;input
          type="email"
          id="email"
          name="email"
          value={form.values.email}
          onChange={form.handleChange}
          onBlur={form.handleBlur}
        /&gt;
        {form.touched.email && form.errors.email && (
          &lt;span className="error"&gt;{form.errors.email}&lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="password"&gt;Password:&lt;/label&gt;
        &lt;input
          type="password"
          id="password"
          name="password"
          value={form.values.password}
          onChange={form.handleChange}
          onBlur={form.handleBlur}
        /&gt;
        {form.touched.password && form.errors.password && (
          &lt;span className="error"&gt;{form.errors.password}&lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="confirmPassword"&gt;Confirm Password:&lt;/label&gt;
        &lt;input
          type="password"
          id="confirmPassword"
          name="confirmPassword"
          value={form.values.confirmPassword}
          onChange={form.handleChange}
          onBlur={form.handleBlur}
        /&gt;
        {form.touched.confirmPassword && form.errors.confirmPassword && (
          &lt;span className="error"&gt;{form.errors.confirmPassword}&lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;
          &lt;input
            type="checkbox"
            name="agreeToTerms"
            checked={form.values.agreeToTerms}
            onChange={form.handleChange}
          /&gt;
          I agree to the terms and conditions
        &lt;/label&gt;
      &lt;/div&gt;

      &lt;button type="submit"&gt;Register&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-11-2">
              <h2 class="section-heading">Form Validation</h2>
              <p>
                Form validation ensures that user input meets your requirements
                before submission. React provides multiple approaches for
                implementing validation.
              </p>

              <h4>Real-time Validation</h4>
              <pre><code class="language-tsx">function RealTimeValidationForm() {
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    confirmPassword: ''
  });

  const [validation, setValidation] = useState({
    email: { isValid: false, message: '' },
    password: { isValid: false, message: '', strength: 0 },
    confirmPassword: { isValid: false, message: '' }
  });

  // Email validation
  const validateEmail = (email: string) =&gt; {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!email) {
      return { isValid: false, message: 'Email is required' };
    }
    if (!emailRegex.test(email)) {
      return { isValid: false, message: 'Please enter a valid email address' };
    }
    return { isValid: true, message: 'Email looks good!' };
  };

  // Password strength validation
  const validatePassword = (password: string) =&gt; {
    let strength = 0;
    let message = '';

    if (!password) {
      return { isValid: false, message: 'Password is required', strength: 0 };
    }

    if (password.length &gt;= 8) strength += 1;
    if (/[a-z]/.test(password)) strength += 1;
    if (/[A-Z]/.test(password)) strength += 1;
    if (/\d/.test(password)) strength += 1;
    if (/[^a-zA-Z\d]/.test(password)) strength += 1;

    const strengthLabels = ['Very Weak', 'Weak', 'Fair', 'Good', 'Strong'];
    const strengthColors = ['#ff4444', '#ff8800', '#ffcc00', '#88cc00', '#44cc44'];

    if (strength &lt; 3) {
      message = `Password is ${strengthLabels[strength]}. `;
      if (password.length &lt; 8) message += 'Use at least 8 characters. ';
      if (!/[a-z]/.test(password)) message += 'Add lowercase letters. ';
      if (!/[A-Z]/.test(password)) message += 'Add uppercase letters. ';
      if (!/\d/.test(password)) message += 'Add numbers. ';
      if (!/[^a-zA-Z\d]/.test(password)) message += 'Add special characters. ';
    } else {
      message = `Password strength: ${strengthLabels[strength]}`;
    }

    return {
      isValid: strength &gt;= 3,
      message,
      strength,
      color: strengthColors[strength]
    };
  };

  // Confirm password validation
  const validateConfirmPassword = (confirmPassword: string, password: string) =&gt; {
    if (!confirmPassword) {
      return { isValid: false, message: 'Please confirm your password' };
    }
    if (confirmPassword !== password) {
      return { isValid: false, message: 'Passwords do not match' };
    }
    return { isValid: true, message: 'Passwords match!' };
  };

  const handleInputChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    const { name, value } = event.target;
    
    setFormData(prev =&gt; ({ ...prev, [name]: value }));

    // Real-time validation
    let validationResult;
    switch (name) {
      case 'email':
        validationResult = validateEmail(value);
        setValidation(prev =&gt; ({ ...prev, email: validationResult }));
        break;
      case 'password':
        validationResult = validatePassword(value);
        setValidation(prev =&gt; ({ ...prev, password: validationResult }));
        
        // Re-validate confirm password if it exists
        if (formData.confirmPassword) {
          const confirmResult = validateConfirmPassword(formData.confirmPassword, value);
          setValidation(prev =&gt; ({ ...prev, confirmPassword: confirmResult }));
        }
        break;
      case 'confirmPassword':
        validationResult = validateConfirmPassword(value, formData.password);
        setValidation(prev =&gt; ({ ...prev, confirmPassword: validationResult }));
        break;
    }
  };

  const isFormValid = validation.email.isValid && 
                     validation.password.isValid && 
                     validation.confirmPassword.isValid;

  return (
    &lt;form&gt;
      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email:&lt;/label&gt;
        &lt;input
          type="email"
          id="email"
          name="email"
          value={formData.email}
          onChange={handleInputChange}
          className={
            formData.email ? 
              (validation.email.isValid ? 'valid' : 'invalid') : 
              ''
          }
        /&gt;
        {formData.email && (
          &lt;div className={validation.email.isValid ? 'success' : 'error'}&gt;
            {validation.email.message}
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="password"&gt;Password:&lt;/label&gt;
        &lt;input
          type="password"
          id="password"
          name="password"
          value={formData.password}
          onChange={handleInputChange}
          className={
            formData.password ? 
              (validation.password.isValid ? 'valid' : 'invalid') : 
              ''
          }
        /&gt;
        {formData.password && (
          &lt;div&gt;
            &lt;div 
              className={validation.password.isValid ? 'success' : 'warning'}
              style={{ color: validation.password.color }}
            &gt;
              {validation.password.message}
            &lt;/div&gt;
            
            {/* Password strength indicator */}
            &lt;div className="password-strength"&gt;
              &lt;div 
                className="strength-bar"
                style={{
                  width: `${(validation.password.strength / 5) * 100}%`,
                  backgroundColor: validation.password.color,
                  height: '4px',
                  transition: 'all 0.3s ease'
                }}
              /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="confirmPassword"&gt;Confirm Password:&lt;/label&gt;
        &lt;input
          type="password"
          id="confirmPassword"
          name="confirmPassword"
          value={formData.confirmPassword}
          onChange={handleInputChange}
          className={
            formData.confirmPassword ? 
              (validation.confirmPassword.isValid ? 'valid' : 'invalid') : 
              ''
          }
        /&gt;
        {formData.confirmPassword && (
          &lt;div className={validation.confirmPassword.isValid ? 'success' : 'error'}&gt;
            {validation.confirmPassword.message}
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;button type="submit" disabled={!isFormValid}&gt;
        {isFormValid ? 'Submit' : 'Please fix errors above'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

              <h4>Async Validation</h4>
              <pre><code class="language-tsx">function AsyncValidationForm() {
  const [username, setUsername] = useState('');
  const [usernameStatus, setUsernameStatus] = useState&lt;{
    loading: boolean;
    available: boolean | null;
    message: string;
  }&gt;({
    loading: false,
    available: null,
    message: ''
  });

  // Debounced username check
  useEffect(() =&gt; {
    if (!username || username.length &lt; 3) {
      setUsernameStatus({
        loading: false,
        available: null,
        message: username.length > 0 && username.length &lt; 3 ? 'Username must be at least 3 characters' : ''
      });
      return;
    }

    const timeoutId = setTimeout(async () =&gt; {
      setUsernameStatus(prev =&gt; ({ ...prev, loading: true }));
      
      try {
        // Simulate API call to check username availability
        await new Promise(resolve =&gt; setTimeout(resolve, 1000));
        
        // Simulate some usernames being taken
        const takenUsernames = ['admin', 'test', 'user123', 'john'];
        const isAvailable = !takenUsernames.includes(username.toLowerCase());
        
        setUsernameStatus({
          loading: false,
          available: isAvailable,
          message: isAvailable ? 
            '✓ Username is available!' : 
            '✗ Username is already taken'
        });
      } catch (error) {
        setUsernameStatus({
          loading: false,
          available: null,
          message: 'Error checking username availability'
        });
      }
    }, 500); // 500ms debounce

    return () =&gt; clearTimeout(timeoutId);
  }, [username]);

  return (
    &lt;form&gt;
      &lt;div&gt;
        &lt;label htmlFor="username"&gt;Username:&lt;/label&gt;
        &lt;div style={{ position: 'relative' }}&gt;
          &lt;input
            type="text"
            id="username"
            value={username}
            onChange={(e) =&gt; setUsername(e.target.value)}
            placeholder="Enter username..."
          /&gt;
          
          {usernameStatus.loading && (
            &lt;span style={{ position: 'absolute', right: '10px', top: '50%', transform: 'translateY(-50%)' }}&gt;
              🔄
            &lt;/span&gt;
          )}
        &lt;/div&gt;
        
        {usernameStatus.message && (
          &lt;div 
            className={
              usernameStatus.available === true ? 'success' :
              usernameStatus.available === false ? 'error' : 'warning'
            }
          &gt;
            {usernameStatus.message}
          &lt;/div&gt;
        )}
      &lt;/div&gt;
      
      &lt;button 
        type="submit" 
        disabled={!usernameStatus.available || usernameStatus.loading}
      &gt;
        Create Account
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-11-3">
              <h2 class="section-heading">Form Libraries</h2>
              <p>
                While you can build forms with vanilla React, form libraries
                like React Hook Form and Formik provide additional features and
                reduce boilerplate code.
              </p>

              <h4>React Hook Form Pattern</h4>
              <pre><code class="language-tsx">// Example implementation mimicking React Hook Form patterns
interface FormData {
  firstName: string;
  lastName: string;
  email: string;
  age: number;
  terms: boolean;
}

// Custom hook mimicking useForm from React Hook Form
function useCustomForm&lt;T extends Record&lt;string, any&gt;&gt;() {
  const [data, setData] = useState&lt;Partial&lt;T&gt;&gt;({});
  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});

  const register = (name: keyof T, validation?: {
    required?: string;
    pattern?: { value: RegExp; message: string };
    minLength?: { value: number; message: string };
    validate?: (value: any) =&gt; string | true;
  }) =&gt; {
    return {
      name: name as string,
      onChange: (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
        const value = e.target.type === 'checkbox' ? e.target.checked : e.target.value;
        setData(prev =&gt; ({ ...prev, [name]: value }));
        
        // Clear error on change
        if (errors[name as string]) {
          setErrors(prev =&gt; ({ ...prev, [name]: undefined }));
        }
      },
      onBlur: (e: React.FocusEvent&lt;HTMLInputElement&gt;) =&gt; {
        if (validation) {
          const value = e.target.type === 'checkbox' ? e.target.checked : e.target.value;
          const error = validateField(value, validation);
          if (error) {
            setErrors(prev =&gt; ({ ...prev, [name]: error }));
          }
        }
      }
    };
  };

  const validateField = (value: any, validation: any) =&gt; {
    if (validation.required && !value) {
      return validation.required;
    }
    if (validation.pattern && !validation.pattern.value.test(value)) {
      return validation.pattern.message;
    }
    if (validation.minLength && value.length &lt; validation.minLength.value) {
      return validation.minLength.message;
    }
    if (validation.validate) {
      const result = validation.validate(value);
      return result === true ? null : result;
    }
    return null;
  };

  const handleSubmit = (onSubmit: (data: Partial&lt;T&gt;) =&gt; void) =&gt; {
    return (e: React.FormEvent) =&gt; {
      e.preventDefault();
      // In a real implementation, you'd validate all fields here
      onSubmit(data);
    };
  };

  return {
    register,
    handleSubmit,
    formState: {
      errors
    },
    watch: (field?: keyof T) =&gt; field ? data[field] : data,
    setValue: (field: keyof T, value: any) =&gt; {
      setData(prev =&gt; ({ ...prev, [field]: value }));
    }
  };
}

// Usage example
function ReactHookFormStyleForm() {
  const { register, handleSubmit, formState: { errors }, watch, setValue } = useCustomForm&lt;FormData&gt;();

  const onSubmit = (data: Partial&lt;FormData&gt;) =&gt; {
    console.log('Form data:', data);
  };

  // Watch specific field
  const firstName = watch('firstName');

  return (
    &lt;div&gt;
      &lt;h3&gt;React Hook Form Style&lt;/h3&gt;
      &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
        &lt;div&gt;
          &lt;label&gt;First Name:&lt;/label&gt;
          &lt;input
            {...register('firstName', {
              required: 'First name is required',
              minLength: { value: 2, message: 'Minimum 2 characters' }
            })}
          /&gt;
          {errors.firstName && &lt;span className="error"&gt;{errors.firstName}&lt;/span&gt;}
        &lt;/div&gt;

        &lt;div&gt;
          &lt;label&gt;Last Name:&lt;/label&gt;
          &lt;input
            {...register('lastName', {
              required: 'Last name is required'
            })}
          /&gt;
          {errors.lastName && &lt;span className="error"&gt;{errors.lastName}&lt;/span&gt;}
        &lt;/div&gt;

        &lt;div&gt;
          &lt;label&gt;Email:&lt;/label&gt;
          &lt;input
            type="email"
            {...register('email', {
              required: 'Email is required',
              pattern: {
                value: /\S+@\S+\.\S+/,
                message: 'Invalid email format'
              }
            })}
          /&gt;
          {errors.email && &lt;span className="error"&gt;{errors.email}&lt;/span&gt;}
        &lt;/div&gt;

        &lt;div&gt;
          &lt;label&gt;Age:&lt;/label&gt;
          &lt;input
            type="number"
            {...register('age', {
              required: 'Age is required',
              validate: (value) =&gt; {
                const age = parseInt(value);
                if (age &lt; 18) return 'Must be 18 or older';
                if (age &gt; 120) return 'Please enter a valid age';
                return true;
              }
            })}
          /&gt;
          {errors.age && &lt;span className="error"&gt;{errors.age}&lt;/span&gt;}
        &lt;/div&gt;

        &lt;div&gt;
          &lt;label&gt;
            &lt;input
              type="checkbox"
              {...register('terms', {
                required: 'You must accept the terms'
              })}
            /&gt;
            I accept the terms and conditions
          &lt;/label&gt;
          {errors.terms && &lt;span className="error"&gt;{errors.terms}&lt;/span&gt;}
        &lt;/div&gt;

        {firstName && &lt;p&gt;Hello, {firstName}!&lt;/p&gt;}

        &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;button type="button" onClick={() =&gt; setValue('firstName', 'John')}&gt;
          Set First Name to John
        &lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Form Array Handling</h4>
              <pre><code class="language-tsx">function DynamicFieldsForm() {
  const [skills, setSkills] = useState([{ name: '', level: 'beginner' }]);

  const addSkill = () =&gt; {
    setSkills(prev =&gt; [...prev, { name: '', level: 'beginner' }]);
  };

  const removeSkill = (index: number) =&gt; {
    setSkills(prev =&gt; prev.filter((_, i) =&gt; i !== index));
  };

  const updateSkill = (index: number, field: 'name' | 'level', value: string) =&gt; {
    setSkills(prev =&gt; prev.map((skill, i) =&gt; 
      i === index ? { ...skill, [field]: value } : skill
    ));
  };

  const handleSubmit = (e: React.FormEvent) =&gt; {
    e.preventDefault();
    console.log('Skills:', skills);
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;h3&gt;Skills&lt;/h3&gt;
      
      {skills.map((skill, index) =&gt; (
        &lt;div key={index} style={{ border: '1px solid #ccc', padding: '10px', margin: '10px 0' }}&gt;
          &lt;div&gt;
            &lt;label&gt;Skill Name:&lt;/label&gt;
            &lt;input
              type="text"
              value={skill.name}
              onChange={(e) =&gt; updateSkill(index, 'name', e.target.value)}
              placeholder="e.g., JavaScript"
            /&gt;
          &lt;/div&gt;
          
          &lt;div&gt;
            &lt;label&gt;Level:&lt;/label&gt;
            &lt;select
              value={skill.level}
              onChange={(e) =&gt; updateSkill(index, 'level', e.target.value)}
            &gt;
              &lt;option value="beginner"&gt;Beginner&lt;/option&gt;
              &lt;option value="intermediate"&gt;Intermediate&lt;/option&gt;
              &lt;option value="advanced"&gt;Advanced&lt;/option&gt;
              &lt;option value="expert"&gt;Expert&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
          
          {skills.length &gt; 1 && (
            &lt;button type="button" onClick={() =&gt; removeSkill(index)}&gt;
              Remove Skill
            &lt;/button&gt;
          )}
        &lt;/div&gt;
      ))}
      
      &lt;button type="button" onClick={addSkill}&gt;
        Add Skill
      &lt;/button&gt;
      
      &lt;div style={{ marginTop: '20px' }}&gt;
        &lt;button type="submit"&gt;Submit Skills&lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-info">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-info-circle"></i>
                    </span>
                    Popular Form Libraries
                  </h4>
                  <ul class="mb-0">
                    <li>
                      <strong>React Hook Form:</strong> Minimal re-renders,
                      better performance, less code
                    </li>
                    <li>
                      <strong>Formik:</strong> Build forms without tears,
                      popular and well-established
                    </li>
                    <li>
                      <strong>React Final Form:</strong> High performance
                      subscription-based form state management
                    </li>
                    <li>
                      <strong>React JSON Schema Form:</strong> Build forms from
                      JSON Schema
                    </li>
                  </ul>
                </div>
              </div>
            </section>
          </article>

          <!-- Styling Section -->
          <article class="docs-article" id="section-12">
            <header class="docs-header">
              <h1 class="docs-heading">Styling</h1>
              <section class="docs-intro">
                <p>
                  React offers multiple approaches to styling components. From
                  traditional CSS to modern CSS-in-JS solutions, each approach
                  has its own benefits and use cases.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-12-1">
              <h2 class="section-heading">CSS Modules</h2>
              <p>
                CSS Modules provide locally scoped CSS by automatically
                generating unique class names. This prevents style conflicts and
                makes your styles more maintainable.
              </p>

              <h4>Basic CSS Modules Usage</h4>
              <pre><code class="language-css">/* Button.module.css */
.button {
  background-color: #007bff;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  transition: all 0.2s ease;
}

.button:hover {
  background-color: #0056b3;
  transform: translateY(-1px);
}

.button:disabled {
  background-color: #6c757d;
  cursor: not-allowed;
  transform: none;
}

.primary {
  background-color: #007bff;
}

.secondary {
  background-color: #6c757d;
}

.danger {
  background-color: #dc3545;
}

.small {
  padding: 8px 16px;
  font-size: 14px;
}

.large {
  padding: 16px 32px;
  font-size: 18px;
}

.fullWidth {
  width: 100%;
}</code></pre>

              <pre><code class="language-tsx">// Button.tsx
import styles from './Button.module.css';
import { ReactNode } from 'react';

interface ButtonProps {
  children: ReactNode;
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  fullWidth?: boolean;
  disabled?: boolean;
  onClick?: () =&gt; void;
}

function Button({ 
  children, 
  variant = 'primary', 
  size = 'medium', 
  fullWidth = false,
  disabled = false,
  onClick 
}: ButtonProps) {
  // Combine multiple CSS module classes
  const className = [
    styles.button,
    styles[variant],
    size !== 'medium' && styles[size],
    fullWidth && styles.fullWidth
  ].filter(Boolean).join(' ');

  return (
    &lt;button 
      className={className}
      disabled={disabled}
      onClick={onClick}
    &gt;
      {children}
    &lt;/button&gt;
  );
}

// Usage
function App() {
  return (
    &lt;div&gt;
      &lt;Button variant="primary" size="large"&gt;
        Primary Large Button
      &lt;/Button&gt;
      
      &lt;Button variant="danger" size="small"&gt;
        Danger Small Button
      &lt;/Button&gt;
      
      &lt;Button variant="secondary" fullWidth&gt;
        Full Width Button
      &lt;/Button&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Advanced CSS Modules Patterns</h4>
              <pre><code class="language-css">/* Card.module.css */
.card {
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  overflow: hidden;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
}

.header {
  padding: 16px 20px;
  border-bottom: 1px solid #eee;
  background: #f8f9fa;
}

.title {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #333;
}

.content {
  padding: 20px;
}

.actions {
  padding: 16px 20px;
  border-top: 1px solid #eee;
  background: #f8f9fa;
  display: flex;
  gap: 12px;
  justify-content: flex-end;
}

/* Composition with other modules */
.actionButton {
  composes: button from './Button.module.css';
  composes: small from './Button.module.css';
}

/* Theme variations */
.darkTheme {
  background: #2d2d2d;
  color: white;
}

.darkTheme .header {
  background: #1a1a1a;
  border-bottom-color: #444;
}

.darkTheme .title {
  color: white;
}

.darkTheme .actions {
  background: #1a1a1a;
  border-top-color: #444;
}</code></pre>

              <pre><code class="language-tsx">// Card.tsx
import styles from './Card.module.css';
import { ReactNode } from 'react';

interface CardProps {
  title?: string;
  children: ReactNode;
  actions?: ReactNode;
  theme?: 'light' | 'dark';
  className?: string;
}

function Card({ title, children, actions, theme = 'light', className }: CardProps) {
  const cardClassName = [
    styles.card,
    theme === 'dark' && styles.darkTheme,
    className
  ].filter(Boolean).join(' ');

  return (
    &lt;div className={cardClassName}&gt;
      {title && (
        &lt;div className={styles.header}&gt;
          &lt;h3 className={styles.title}&gt;{title}&lt;/h3&gt;
        &lt;/div&gt;
      )}
      
      &lt;div className={styles.content}&gt;
        {children}
      &lt;/div&gt;
      
      {actions && (
        &lt;div className={styles.actions}&gt;
          {actions}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}

// Usage with composition
function UserCard({ user }: { user: { name: string; email: string; avatar: string } }) {
  const actions = (
    &lt;&gt;
      &lt;button className={styles.actionButton}&gt;Edit&lt;/button&gt;
      &lt;button className={styles.actionButton}&gt;Delete&lt;/button&gt;
    &lt;/&gt;
  );

  return (
    &lt;Card title={user.name} actions={actions}&gt;
      &lt;div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}&gt;
        &lt;img 
          src={user.avatar} 
          alt={user.name}
          style={{ width: '50px', height: '50px', borderRadius: '50%' }}
        /&gt;
        &lt;div&gt;
          &lt;p&gt;{user.email}&lt;/p&gt;
          &lt;p&gt;Member since 2024&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/Card&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-12-2">
              <h2 class="section-heading">Styled Components</h2>
              <p>
                Styled Components is a CSS-in-JS library that allows you to
                write actual CSS in your JavaScript. It provides dynamic styling
                based on props and automatic vendor prefixing.
              </p>

              <h4>Basic Styled Components</h4>
              <pre><code class="language-tsx">// Note: This is a simulation of styled-components syntax
// In a real project, you would install and import styled-components

// Simulating styled-components with regular CSS-in-JS
const styled = {
  div: (styles: any) =&gt; ({ children, ...props }: any) =&gt; (
    &lt;div style={typeof styles === 'function' ? styles(props) : styles} {...props}&gt;
      {children}
    &lt;/div&gt;
  ),
  button: (styles: any) =&gt; ({ children, ...props }: any) =&gt; (
    &lt;button style={typeof styles === 'function' ? styles(props) : styles} {...props}&gt;
      {children}
    &lt;/button&gt;
  ),
  input: (styles: any) =&gt; (props: any) =&gt; (
    &lt;input style={typeof styles === 'function' ? styles(props) : styles} {...props} /&gt;
  )
};

// Styled button with dynamic props
const StyledButton = styled.button((props: { 
  variant: 'primary' | 'secondary' | 'danger';
  size: 'small' | 'medium' | 'large';
  fullWidth?: boolean;
}) =&gt; {
  const variants = {
    primary: { backgroundColor: '#007bff', color: 'white' },
    secondary: { backgroundColor: '#6c757d', color: 'white' },
    danger: { backgroundColor: '#dc3545', color: 'white' }
  };

  const sizes = {
    small: { padding: '8px 16px', fontSize: '14px' },
    medium: { padding: '12px 24px', fontSize: '16px' },
    large: { padding: '16px 32px', fontSize: '18px' }
  };

  return {
    ...variants[props.variant],
    ...sizes[props.size],
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    width: props.fullWidth ? '100%' : 'auto',
    
    ':hover': {
      opacity: 0.9,
      transform: 'translateY(-1px)'
    },
    
    ':disabled': {
      backgroundColor: '#6c757d',
      cursor: 'not-allowed',
      transform: 'none'
    }
  };
});

// Styled card component
const Card = styled.div({
  background: 'white',
  borderRadius: '8px',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',
  overflow: 'hidden',
  transition: 'transform 0.2s ease, box-shadow 0.2s ease',
  
  ':hover': {
    transform: 'translateY(-2px)',
    boxShadow: '0 4px 16px rgba(0, 0, 0, 0.15)'
  }
});

const CardHeader = styled.div({
  padding: '16px 20px',
  borderBottom: '1px solid #eee',
  background: '#f8f9fa'
});

const CardTitle = styled.h3({
  margin: 0,
  fontSize: '18px',
  fontWeight: 600,
  color: '#333'
});

const CardContent = styled.div({
  padding: '20px'
});

// Theme provider simulation
const ThemeProvider = ({ theme, children }: { theme: any; children: any }) =&gt; {
  return &lt;div data-theme={theme.name}&gt;{children}&lt;/div&gt;;
};

const theme = {
  name: 'default',
  colors: {
    primary: '#007bff',
    secondary: '#6c757d',
    danger: '#dc3545',
    background: '#ffffff',
    text: '#333333'
  },
  spacing: {
    small: '8px',
    medium: '16px',
    large: '24px'
  },
  breakpoints: {
    mobile: '768px',
    tablet: '1024px',
    desktop: '1200px'
  }
};

// Usage example
function StyledComponentsExample() {
  return (
    &lt;ThemeProvider theme={theme}&gt;
      &lt;div&gt;
        &lt;Card&gt;
          &lt;CardHeader&gt;
            &lt;CardTitle&gt;Styled Components Example&lt;/CardTitle&gt;
          &lt;/CardHeader&gt;
          &lt;CardContent&gt;
            &lt;p&gt;This card is built with styled components!&lt;/p&gt;
            
            &lt;div style={{ display: 'flex', gap: '12px', marginTop: '16px' }}&gt;
              &lt;StyledButton variant="primary" size="medium"&gt;
                Primary
              &lt;/StyledButton&gt;
              
              &lt;StyledButton variant="secondary" size="small"&gt;
                Secondary
              &lt;/StyledButton&gt;
              
              &lt;StyledButton variant="danger" size="large"&gt;
                Danger
              &lt;/StyledButton&gt;
            &lt;/div&gt;
          &lt;/CardContent&gt;
        &lt;/Card&gt;
      &lt;/div&gt;
    &lt;/ThemeProvider&gt;
  );
}</code></pre>

              <h4>Advanced Styling Patterns</h4>
              <pre><code class="language-tsx">// Responsive styled components
const ResponsiveGrid = styled.div((props: { columns?: number }) =&gt; ({
  display: 'grid',
  gridTemplateColumns: `repeat(${props.columns || 1}, 1fr)`,
  gap: '20px',
  
  '@media (max-width: 768px)': {
    gridTemplateColumns: '1fr',
    gap: '16px'
  }
}));

// Animation with styled components
const FadeInBox = styled.div((props: { delay?: number }) =&gt; ({
  opacity: 0,
  transform: 'translateY(20px)',
  animation: `fadeIn 0.5s ease forwards ${props.delay || 0}s`,
  
  '@keyframes fadeIn': {
    'to': {
      opacity: 1,
      transform: 'translateY(0)'
    }
  }
}));

// Complex component with multiple variants
const Alert = styled.div((props: {
  variant: 'info' | 'success' | 'warning' | 'error';
  dismissible?: boolean;
}) =&gt; {
  const variants = {
    info: { backgroundColor: '#d1ecf1', color: '#0c5460', borderColor: '#bee5eb' },
    success: { backgroundColor: '#d4edda', color: '#155724', borderColor: '#c3e6cb' },
    warning: { backgroundColor: '#fff3cd', color: '#856404', borderColor: '#ffeaa7' },
    error: { backgroundColor: '#f8d7da', color: '#721c24', borderColor: '#f5c6cb' }
  };

  return {
    ...variants[props.variant],
    padding: '12px 16px',
    border: `1px solid`,
    borderRadius: '4px',
    position: 'relative',
    marginBottom: '16px',
    
    ...(props.dismissible && {
      paddingRight: '48px'
    })
  };
});

const AlertCloseButton = styled.button({
  position: 'absolute',
  top: '50%',
  right: '16px',
  transform: 'translateY(-50%)',
  background: 'none',
  border: 'none',
  fontSize: '18px',
  cursor: 'pointer',
  opacity: 0.7,
  
  ':hover': {
    opacity: 1
  }
});

// Usage of complex styled components
function AlertExample() {
  const [alerts, setAlerts] = useState([
    { id: 1, variant: 'info' as const, message: 'This is an info alert' },
    { id: 2, variant: 'success' as const, message: 'Operation completed successfully!' },
    { id: 3, variant: 'warning' as const, message: 'Please review your settings' },
    { id: 4, variant: 'error' as const, message: 'An error occurred' }
  ]);

  const dismissAlert = (id: number) =&gt; {
    setAlerts(prev =&gt; prev.filter(alert =&gt; alert.id !== id));
  };

  return (
    &lt;div&gt;
      &lt;ResponsiveGrid columns={2}&gt;
        {alerts.map((alert, index) =&gt; (
          &lt;FadeInBox key={alert.id} delay={index * 0.1}&gt;
            &lt;Alert variant={alert.variant} dismissible&gt;
              {alert.message}
              &lt;AlertCloseButton onClick={() =&gt; dismissAlert(alert.id)}&gt;
                ×
              &lt;/AlertCloseButton&gt;
            &lt;/Alert&gt;
          &lt;/FadeInBox&gt;
        ))}
      &lt;/ResponsiveGrid&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-12-3">
              <h2 class="section-heading">Tailwind CSS</h2>
              <p>
                Tailwind CSS is a utility-first CSS framework that provides
                low-level utility classes to build custom designs directly in
                your markup.
              </p>

              <h4>Basic Tailwind Usage</h4>
              <pre><code class="language-tsx">// Basic Tailwind classes in React components
function TailwindButton({ 
  children, 
  variant = 'primary', 
  size = 'medium',
  fullWidth = false,
  disabled = false,
  onClick 
}: {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'danger' | 'outline';
  size?: 'small' | 'medium' | 'large';
  fullWidth?: boolean;
  disabled?: boolean;
  onClick?: () =&gt; void;
}) {
  // Base classes
  const baseClasses = [
    'inline-flex',
    'items-center',
    'justify-center',
    'border',
    'font-medium',
    'rounded-md',
    'transition-all',
    'duration-200',
    'focus:outline-none',
    'focus:ring-2',
    'focus:ring-offset-2',
    'disabled:opacity-50',
    'disabled:cursor-not-allowed',
    'hover:transform',
    'hover:-translate-y-0.5',
    'active:translate-y-0'
  ];

  // Variant classes
  const variantClasses = {
    primary: [
      'bg-blue-600',
      'border-blue-600',
      'text-white',
      'hover:bg-blue-700',
      'focus:ring-blue-500'
    ],
    secondary: [
      'bg-gray-600',
      'border-gray-600',
      'text-white',
      'hover:bg-gray-700',
      'focus:ring-gray-500'
    ],
    danger: [
      'bg-red-600',
      'border-red-600',
      'text-white',
      'hover:bg-red-700',
      'focus:ring-red-500'
    ],
    outline: [
      'bg-transparent',
      'border-gray-300',
      'text-gray-700',
      'hover:bg-gray-50',
      'focus:ring-gray-500'
    ]
  };

  // Size classes
  const sizeClasses = {
    small: ['px-3', 'py-1.5', 'text-sm'],
    medium: ['px-4', 'py-2', 'text-base'],
    large: ['px-6', 'py-3', 'text-lg']
  };

  // Combine all classes
  const className = [
    ...baseClasses,
    ...variantClasses[variant],
    ...sizeClasses[size],
    fullWidth && 'w-full',
    disabled && 'pointer-events-none'
  ].filter(Boolean).join(' ');

  return (
    &lt;button
      className={className}
      disabled={disabled}
      onClick={onClick}
    &gt;
      {children}
    &lt;/button&gt;
  );
}

// Card component with Tailwind
function TailwindCard({ 
  title, 
  children, 
  actions,
  hover = true,
  shadow = 'medium' 
}: {
  title?: string;
  children: React.ReactNode;
  actions?: React.ReactNode;
  hover?: boolean;
  shadow?: 'small' | 'medium' | 'large';
}) {
  const shadowClasses = {
    small: 'shadow-sm',
    medium: 'shadow-md',
    large: 'shadow-lg'
  };

  const cardClasses = [
    'bg-white',
    'rounded-lg',
    'overflow-hidden',
    'border',
    'border-gray-200',
    shadowClasses[shadow],
    hover && 'hover:shadow-lg',
    hover && 'transition-shadow',
    hover && 'duration-200'
  ].filter(Boolean).join(' ');

  return (
    &lt;div className={cardClasses}&gt;
      {title && (
        &lt;div className="px-6 py-4 border-b border-gray-200 bg-gray-50"&gt;
          &lt;h3 className="text-lg font-semibold text-gray-900"&gt;{title}&lt;/h3&gt;
        &lt;/div&gt;
      )}
      
      &lt;div className="px-6 py-4"&gt;
        {children}
      &lt;/div&gt;
      
      {actions && (
        &lt;div className="px-6 py-4 border-t border-gray-200 bg-gray-50 flex justify-end space-x-3"&gt;
          {actions}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Responsive Design with Tailwind</h4>
              <pre><code class="language-tsx">function ResponsiveLayout() {
  return (
    &lt;div className="min-h-screen bg-gray-100"&gt;
      {/* Header */}
      &lt;header className="bg-white shadow-sm border-b border-gray-200"&gt;
        &lt;div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"&gt;
          &lt;div className="flex justify-between items-center h-16"&gt;
            &lt;div className="flex items-center"&gt;
              &lt;h1 className="text-xl font-bold text-gray-900 sm:text-2xl"&gt;
                My App
              &lt;/h1&gt;
            &lt;/div&gt;
            
            {/* Mobile menu button */}
            &lt;button className="md:hidden p-2 rounded-md text-gray-400 hover:text-gray-500 hover:bg-gray-100"&gt;
              &lt;svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"&gt;
                &lt;path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" /&gt;
              &lt;/svg&gt;
            &lt;/button&gt;
            
            {/* Desktop navigation */}
            &lt;nav className="hidden md:flex space-x-8"&gt;
              &lt;a href="#" className="text-gray-500 hover:text-gray-900 px-3 py-2 text-sm font-medium"&gt;
                Home
              &lt;/a&gt;
              &lt;a href="#" className="text-gray-500 hover:text-gray-900 px-3 py-2 text-sm font-medium"&gt;
                About
              &lt;/a&gt;
              &lt;a href="#" className="text-gray-500 hover:text-gray-900 px-3 py-2 text-sm font-medium"&gt;
                Contact
              &lt;/a&gt;
            &lt;/nav&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/header&gt;

      {/* Main content */}
      &lt;main className="max-w-7xl mx-auto py-6 px-4 sm:px-6 lg:px-8"&gt;
        {/* Hero section */}
        &lt;div className="bg-gradient-to-r from-blue-500 to-purple-600 rounded-lg p-8 mb-8 text-white"&gt;
          &lt;h2 className="text-2xl sm:text-3xl lg:text-4xl font-bold mb-4"&gt;
            Welcome to Our Platform
          &lt;/h2&gt;
          &lt;p className="text-lg sm:text-xl mb-6 opacity-90"&gt;
            Build amazing things with our tools and services
          &lt;/p&gt;
          &lt;TailwindButton variant="outline" size="large"&gt;
            Get Started
          &lt;/TailwindButton&gt;
        &lt;/div&gt;

        {/* Grid layout */}
        &lt;div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8"&gt;
          {[1, 2, 3, 4, 5, 6].map(item =&gt; (
            &lt;TailwindCard key={item} title={`Feature ${item}`}&gt;
              &lt;p className="text-gray-600 mb-4"&gt;
                Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
                Sed do eiusmod tempor incididunt ut labore.
              &lt;/p&gt;
              &lt;div className="flex items-center text-sm text-blue-600"&gt;
                &lt;span&gt;Learn more&lt;/span&gt;
                &lt;svg className="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"&gt;
                  &lt;path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" /&gt;
                &lt;/svg&gt;
              &lt;/div&gt;
            &lt;/TailwindCard&gt;
          ))}
        &lt;/div&gt;

        {/* Stats section */}
        &lt;div className="bg-white rounded-lg shadow-md p-6"&gt;
          &lt;div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6"&gt;
            {[
              { label: 'Users', value: '10,000+' },
              { label: 'Projects', value: '5,000+' },
              { label: 'Success Rate', value: '99.9%' },
              { label: 'Support', value: '24/7' }
            ].map(stat =&gt; (
              &lt;div key={stat.label} className="text-center"&gt;
                &lt;div className="text-2xl sm:text-3xl font-bold text-gray-900 mb-1"&gt;
                  {stat.value}
                &lt;/div&gt;
                &lt;div className="text-sm text-gray-500"&gt;
                  {stat.label}
                &lt;/div&gt;
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/main&gt;

      {/* Footer */}
      &lt;footer className="bg-gray-800 text-white mt-12"&gt;
        &lt;div className="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8"&gt;
          &lt;div className="grid grid-cols-1 md:grid-cols-3 gap-8"&gt;
            &lt;div&gt;
              &lt;h3 className="text-lg font-semibold mb-4"&gt;Company&lt;/h3&gt;
              &lt;ul className="space-y-2 text-gray-300"&gt;
                &lt;li&gt;&lt;a href="#" className="hover:text-white transition-colors"&gt;About&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href="#" className="hover:text-white transition-colors"&gt;Careers&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href="#" className="hover:text-white transition-colors"&gt;Contact&lt;/a&gt;&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/div&gt;
            
            &lt;div&gt;
              &lt;h3 className="text-lg font-semibold mb-4"&gt;Resources&lt;/h3&gt;
              &lt;ul className="space-y-2 text-gray-300"&gt;
                &lt;li&gt;&lt;a href="#" className="hover:text-white transition-colors"&gt;Documentation&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href="#" className="hover:text-white transition-colors"&gt;Support&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href="#" className="hover:text-white transition-colors"&gt;Blog&lt;/a&gt;&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/div&gt;
            
            &lt;div&gt;
              &lt;h3 className="text-lg font-semibold mb-4"&gt;Legal&lt;/h3&gt;
              &lt;ul className="space-y-2 text-gray-300"&gt;
                &lt;li&gt;&lt;a href="#" className="hover:text-white transition-colors"&gt;Privacy&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href="#" className="hover:text-white transition-colors"&gt;Terms&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href="#" className="hover:text-white transition-colors"&gt;Security&lt;/a&gt;&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          
          &lt;div className="border-t border-gray-700 mt-8 pt-8 text-center text-gray-400"&gt;
            &lt;p&gt;&copy; 2024 My App. All rights reserved.&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/footer&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Dark Mode with Tailwind</h4>
              <pre><code class="language-tsx">function DarkModeToggle() {
  const [darkMode, setDarkMode] = useState(false);

  useEffect(() =&gt; {
    // Check system preference
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    setDarkMode(prefersDark);
  }, []);

  useEffect(() =&gt; {
    // Apply dark mode class to document
    if (darkMode) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }, [darkMode]);

  return (
    &lt;div className="min-h-screen bg-white dark:bg-gray-900 transition-colors duration-200"&gt;
      {/* Dark mode toggle */}
      &lt;div className="flex justify-end p-4"&gt;
        &lt;button
          onClick={() =&gt; setDarkMode(!darkMode)}
          className="p-2 rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors"
        &gt;
          {darkMode ? '☀️' : '🌙'}
        &lt;/button&gt;
      &lt;/div&gt;

      {/* Content with dark mode support */}
      &lt;div className="max-w-4xl mx-auto p-6"&gt;
        &lt;h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-8"&gt;
          Dark Mode Demo
        &lt;/h1&gt;

        &lt;div className="grid grid-cols-1 md:grid-cols-2 gap-6"&gt;
          &lt;div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md border border-gray-200 dark:border-gray-700"&gt;
            &lt;h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-4"&gt;
              Card Title
            &lt;/h2&gt;
            &lt;p className="text-gray-600 dark:text-gray-300 mb-4"&gt;
              This card adapts to dark mode automatically using Tailwind's dark: prefix.
            &lt;/p&gt;
            &lt;button className="bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white px-4 py-2 rounded-md transition-colors"&gt;
              Action Button
            &lt;/button&gt;
          &lt;/div&gt;

          &lt;div className="bg-gradient-to-br from-purple-500 to-pink-500 dark:from-purple-600 dark:to-pink-600 p-6 rounded-lg text-white"&gt;
            &lt;h2 className="text-xl font-semibold mb-4"&gt;
              Gradient Card
            &lt;/h2&gt;
            &lt;p className="opacity-90 mb-4"&gt;
              Even gradients can be adjusted for dark mode.
            &lt;/p&gt;
            &lt;button className="bg-white bg-opacity-20 hover:bg-opacity-30 text-white px-4 py-2 rounded-md transition-all"&gt;
              Learn More
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        {/* Form example */}
        &lt;div className="mt-8 bg-white dark:bg-gray-800 p-6 rounded-lg shadow-md border border-gray-200 dark:border-gray-700"&gt;
          &lt;h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-6"&gt;
            Contact Form
          &lt;/h2&gt;
          
          &lt;form className="space-y-4"&gt;
            &lt;div&gt;
              &lt;label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"&gt;
                Name
              &lt;/label&gt;
              &lt;input 
                type="text"
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                placeholder="Your name"
              /&gt;
            &lt;/div&gt;
            
            &lt;div&gt;
              &lt;label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"&gt;
                Email
              &lt;/label&gt;
              &lt;input 
                type="email"
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                placeholder="your@email.com"
              /&gt;
            &lt;/div&gt;
            
            &lt;div&gt;
              &lt;label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2"&gt;
                Message
              &lt;/label&gt;
              &lt;textarea 
                rows={4}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                placeholder="Your message..."
              /&gt;
            &lt;/div&gt;
            
            &lt;button 
              type="submit"
              className="w-full bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white py-2 px-4 rounded-md transition-colors"
            &gt;
              Send Message
            &lt;/button&gt;
          &lt;/form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-success">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-lightbulb"></i>
                    </span>
                    Styling Best Practices
                  </h4>
                  <ul class="mb-0">
                    <li>
                      <strong>Choose the right approach:</strong> CSS Modules
                      for scoped styles, Styled Components for dynamic styling,
                      Tailwind for rapid development
                    </li>
                    <li>
                      <strong>Consistency:</strong> Stick to one primary styling
                      approach per project
                    </li>
                    <li>
                      <strong>Performance:</strong> Consider bundle size and
                      runtime performance implications
                    </li>
                    <li>
                      <strong>Maintainability:</strong> Use design systems and
                      consistent naming conventions
                    </li>
                    <li>
                      <strong>Responsive design:</strong> Always consider
                      mobile-first responsive design
                    </li>
                    <li>
                      <strong>Accessibility:</strong> Ensure sufficient color
                      contrast and proper focus states
                    </li>
                  </ul>
                </div>
              </div>
            </section>
          </article>

          <!-- Performance Section -->
          <article class="docs-article" id="section-13">
            <header class="docs-header">
              <h1 class="docs-heading">Performance</h1>
              <section class="docs-intro">
                <p>
                  React provides several tools and techniques to optimize your
                  application's performance. Understanding when and how to use
                  these optimizations is crucial for building fast, responsive
                  applications.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-13-1">
              <h2 class="section-heading">React.memo</h2>
              <p>
                React.memo is a higher-order component that memoizes the result
                of a component. It only re-renders if its props have changed,
                which can prevent unnecessary re-renders.
              </p>

              <h4>Basic React.memo Usage</h4>
              <pre><code class="language-tsx">import { memo, useState } from 'react';

// Component that might re-render unnecessarily
interface ExpensiveComponentProps {
  name: string;
  age: number;
  hobbies: string[];
}

// Without memo - re-renders on every parent render
function ExpensiveComponent({ name, age, hobbies }: ExpensiveComponentProps) {
  console.log('ExpensiveComponent rendered');
  
  // Simulate expensive computation
  const expensiveValue = useMemo(() => {
    console.log('Expensive calculation running...');
    return Array.from({ length: 1000000 }, (_, i) => i).reduce((a, b) => a + b, 0);
  }, []);

  return (
    &lt;div&gt;
      &lt;h3&gt;{name} (Age: {age})&lt;/h3&gt;
      &lt;p&gt;Expensive calculation result: {expensiveValue}&lt;/p&gt;
      &lt;ul&gt;
        {hobbies.map(hobby =&gt; (
          &lt;li key={hobby}&gt;{hobby}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

// With memo - only re-renders when props change
const MemoizedExpensiveComponent = memo(ExpensiveComponent);

// Custom comparison function for memo
const MemoizedWithCustomComparison = memo(ExpensiveComponent, (prevProps, nextProps) =&gt; {
  // Return true if props are equal (don't re-render)
  // Return false if props are different (re-render)
  
  // Custom comparison: ignore age changes less than 5 years
  const ageChanged = Math.abs(prevProps.age - nextProps.age) >= 5;
  const nameChanged = prevProps.name !== nextProps.name;
  const hobbiesChanged = prevProps.hobbies.length !== nextProps.hobbies.length ||
    prevProps.hobbies.some((hobby, index) =&gt; hobby !== nextProps.hobbies[index]);

  return !ageChanged && !nameChanged && !hobbiesChanged;
});

// Parent component to test memo
function ParentComponent() {
  const [counter, setCounter] = useState(0);
  const [userData, setUserData] = useState({
    name: 'John Doe',
    age: 25,
    hobbies: ['reading', 'swimming']
  });

  return (
    &lt;div&gt;
      &lt;h2&gt;Performance Demo&lt;/h2&gt;
      
      &lt;div&gt;
        &lt;button onClick={() =&gt; setCounter(c =&gt; c + 1)}&gt;
          Counter: {counter} (causes parent re-render)
        &lt;/button&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;button onClick={() =&gt; setUserData(prev =&gt; ({ ...prev, age: prev.age + 1 }))}&gt;
          Increase Age
        &lt;/button&gt;
        &lt;button onClick={() =&gt; setUserData(prev =&gt; ({ 
          ...prev, 
          hobbies: [...prev.hobbies, `hobby${Date.now()}`] 
        }))}&gt;
          Add Hobby
        &lt;/button&gt;
      &lt;/div&gt;

      &lt;div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px', marginTop: '20px' }}&gt;
        &lt;div&gt;
          &lt;h4&gt;Without Memo (always re-renders)&lt;/h4&gt;
          &lt;ExpensiveComponent {...userData} /&gt;
        &lt;/div&gt;
        
        &lt;div&gt;
          &lt;h4&gt;With Memo (smart re-rendering)&lt;/h4&gt;
          &lt;MemoizedExpensiveComponent {...userData} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>When to Use React.memo</h4>
              <pre><code class="language-tsx">// ✅ // ✅ Good use case: Pure component with expensive rendering
const UserCard = memo(({ user }: { user: User }) =&gt; {
  return (
    &lt;div className="user-card"&gt;
      &lt;img src={user.avatar} alt={user.name} /&gt;
      &lt;h3&gt;{user.name}&lt;/h3&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
});

// ❌ Don't memo: Component that always receives new props
const Timestamp = memo(() =&gt; {
  return &lt;span&gt;{new Date().toLocaleTimeString()}&lt;/span&gt;;
});

// ❌ Don't memo: Component with children (children are often new objects)
const Container = memo(({ children }: { children: React.ReactNode }) =&gt; {
  return &lt;div className="container"&gt;{children}&lt;/div&gt;;
});

// ✅ Good: List item that rarely changes
const TodoItem = memo(({ 
  todo, 
  onToggle, 
  onDelete 
}: { 
  todo: Todo; 
  onToggle: (id: number) =&gt; void; 
  onDelete: (id: number) =&gt; void; 
}) =&gt; {
  return (
    &lt;div className="todo-item"&gt;
      &lt;input 
        type="checkbox" 
        checked={todo.completed}
        onChange={() =&gt; onToggle(todo.id)}
      /&gt;
      &lt;span&gt;{todo.text}&lt;/span&gt;
      &lt;button onClick={() =&gt; onDelete(todo.id)}&gt;Delete&lt;/button&gt;
    &lt;/div&gt;
  );
});</code></pre>
            </section>

            <section class="docs-section" id="item-13-2">
              <h2 class="section-heading">useMemo & useCallback</h2>
              <p>
                useMemo and useCallback are hooks that help optimize performance
                by memoizing expensive calculations and function references.
              </p>

              <h4>useMemo for Expensive Calculations</h4>
              <pre><code class="language-tsx">import { useState, useMemo, useCallback } from 'react';

function DataProcessor({ data }: { data: number[] }) {
  const [filter, setFilter] = useState('');
  const [sortOrder, setSortOrder] = useState&lt;'asc' | 'desc'&gt;('asc');

  // ✅ useMemo: Expensive calculation that depends on data and sortOrder
  const sortedData = useMemo(() =&gt; {
    console.log('Sorting data...', data.length, 'items');
    return [...data].sort((a, b) =&gt; {
      return sortOrder === 'asc' ? a - b : b - a;
    });
  }, [data, sortOrder]);

  // ✅ useMemo: Expensive filtering based on sorted data and filter
  const filteredData = useMemo(() =&gt; {
    console.log('Filtering data...');
    if (!filter) return sortedData;
    
    const filterNum = parseFloat(filter);
    if (isNaN(filterNum)) return sortedData;
    
    return sortedData.filter(item =&gt; item &gt;= filterNum);
  }, [sortedData, filter]);

  // ✅ useMemo: Expensive statistics calculation
  const statistics = useMemo(() =&gt; {
    console.log('Calculating statistics...');
    const sum = filteredData.reduce((acc, val) =&gt; acc + val, 0);
    const avg = sum / filteredData.length || 0;
    const min = Math.min(...filteredData);
    const max = Math.max(...filteredData);
    
    return { sum, avg, min, max, count: filteredData.length };
  }, [filteredData]);

  // ❌ Don't memo: Simple calculation
  const doubleCount = filteredData.length * 2; // No useMemo needed

  return (
    &lt;div&gt;
      &lt;div&gt;
        &lt;input
          type="text"
          placeholder="Filter by minimum value"
          value={filter}
          onChange={(e) =&gt; setFilter(e.target.value)}
        /&gt;
        
        &lt;select 
          value={sortOrder} 
          onChange={(e) =&gt; setSortOrder(e.target.value as 'asc' | 'desc')}
        &gt;
          &lt;option value="asc"&gt;Ascending&lt;/option&gt;
          &lt;option value="desc"&gt;Descending&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;h3&gt;Statistics&lt;/h3&gt;
        &lt;p&gt;Count: {statistics.count}&lt;/p&gt;
        &lt;p&gt;Sum: {statistics.sum}&lt;/p&gt;
        &lt;p&gt;Average: {statistics.avg.toFixed(2)}&lt;/p&gt;
        &lt;p&gt;Min: {statistics.min}&lt;/p&gt;
        &lt;p&gt;Max: {statistics.max}&lt;/p&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;h3&gt;Filtered Data ({filteredData.length} items)&lt;/h3&gt;
        &lt;div style={{ maxHeight: '200px', overflow: 'auto' }}&gt;
          {filteredData.slice(0, 20).map((item, index) =&gt; (
            &lt;div key={index}&gt;{item}&lt;/div&gt;
          ))}
          {filteredData.length &gt; 20 && &lt;div&gt;... and {filteredData.length - 20} more&lt;/div&gt;}
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>useCallback for Function Memoization</h4>
              <pre><code class="language-tsx">function TodoApp() {
  const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
  const [filter, setFilter] = useState&lt;'all' | 'active' | 'completed'&gt;('all');

  // ✅ useCallback: Function passed to child components
  const handleToggle = useCallback((id: number) =&gt; {
    setTodos(prev =&gt; prev.map(todo =&gt; 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  }, []); // No dependencies - function never changes

  // ✅ useCallback: Function that depends on external values
  const handleDelete = useCallback((id: number) =&gt; {
    setTodos(prev =&gt; prev.filter(todo =&gt; todo.id !== id));
  }, []); // No dependencies

  // ✅ useCallback: Function with dependencies
  const handleAdd = useCallback((text: string) =&gt; {
    const newTodo: Todo = {
      id: Date.now(),
      text,
      completed: false
    };
    setTodos(prev =&gt; [...prev, newTodo]);
  }, []); // No dependencies

  // ✅ useMemo: Expensive filtering operation
  const filteredTodos = useMemo(() =&gt; {
    switch (filter) {
      case 'active':
        return todos.filter(todo =&gt; !todo.completed);
      case 'completed':
        return todos.filter(todo =&gt; todo.completed);
      default:
        return todos;
    }
  }, [todos, filter]);

  // ❌ Don't useCallback: Simple event handlers that don't need optimization
  const handleFilterChange = (newFilter: typeof filter) =&gt; {
    setFilter(newFilter);
  };

  return (
    &lt;div&gt;
      &lt;TodoForm onAdd={handleAdd} /&gt;
      
      &lt;div&gt;
        &lt;button 
          onClick={() =&gt; handleFilterChange('all')}
          disabled={filter === 'all'}
        &gt;
          All
        &lt;/button&gt;
        &lt;button 
          onClick={() =&gt; handleFilterChange('active')}
          disabled={filter === 'active'}
        &gt;
          Active
        &lt;/button&gt;
        &lt;button 
          onClick={() =&gt; handleFilterChange('completed')}
          disabled={filter === 'completed'}
        &gt;
          Completed
        &lt;/button&gt;
      &lt;/div&gt;

      &lt;TodoList 
        todos={filteredTodos}
        onToggle={handleToggle}
        onDelete={handleDelete}
      /&gt;
    &lt;/div&gt;
  );
}

// Memoized child component that benefits from useCallback
const TodoList = memo(({ 
  todos, 
  onToggle, 
  onDelete 
}: {
  todos: Todo[];
  onToggle: (id: number) =&gt; void;
  onDelete: (id: number) =&gt; void;
}) =&gt; {
  console.log('TodoList rendered');
  
  return (
    &lt;ul&gt;
      {todos.map(todo =&gt; (
        &lt;TodoItem
          key={todo.id}
          todo={todo}
          onToggle={onToggle}
          onDelete={onDelete}
        /&gt;
      ))}
    &lt;/ul&gt;
  );
});</code></pre>

              <h4>Performance Anti-patterns</h4>
              <pre><code class="language-tsx">function PerformanceAntiPatterns() {
  const [count, setCount] = useState(0);
  const [items, setItems] = useState([1, 2, 3, 4, 5]);

  // ❌ Anti-pattern: Unnecessary useMemo for simple values
  const simpleValue = useMemo(() =&gt; count * 2, [count]); // Just use: count * 2

  // ❌ Anti-pattern: useMemo with no dependencies
  const alwaysNew = useMemo(() =&gt; ({ value: count }), []); // This creates new object every render

  // ❌ Anti-pattern: useCallback without memoized children
  const handleClick = useCallback(() =&gt; {
    setCount(c =&gt; c + 1);
  }, []); // Useless if not passing to memoized component

  // ❌ Anti-pattern: Complex dependency array
  const complexMemo = useMemo(() =&gt; {
    return items.map(item =&gt; ({ id: item, value: item * count }));
  }, [items, count, /* avoid many dependencies */]);

  // ✅ Better: Break down complex calculations
  const processedItems = useMemo(() =&gt; {
    return items.map(item =&gt; ({ id: item, multiplier: count }));
  }, [items, count]);

  const finalItems = useMemo(() =&gt; {
    return processedItems.map(item =&gt; ({
      ...item,
      value: item.id * item.multiplier
    }));
  }, [processedItems]);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(c =&gt; c + 1)}&gt;Increment&lt;/button&gt;
      
      &lt;ul&gt;
        {finalItems.map(item =&gt; (
          &lt;li key={item.id}&gt;{item.id}: {item.value}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-13-3">
              <h2 class="section-heading">Code Splitting</h2>
              <p>
                Code splitting allows you to split your bundle into smaller
                chunks that can be loaded on demand, reducing the initial bundle
                size and improving load times.
              </p>

              <h4>React.lazy and Suspense</h4>
              <pre><code class="language-tsx">import { lazy, Suspense, useState } from 'react';

// ✅ Lazy load heavy components
const HeavyDashboard = lazy(() =&gt; import('./HeavyDashboard'));
const UserSettings = lazy(() =&gt; import('./UserSettings'));
const Reports = lazy(() =&gt; import('./Reports'));

// Loading fallback component
function LoadingSpinner() {
  return (
    &lt;div style={{ 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center', 
      height: '200px' 
    }}&gt;
      &lt;div&gt;Loading...&lt;/div&gt;
    &lt;/div&gt;
  );
}

// Error boundary for lazy loading
class LazyLoadErrorBoundary extends React.Component&lt;
  { children: React.ReactNode },
  { hasError: boolean }
&gt; {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.log('Lazy loading error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        &lt;div style={{ padding: '20px', textAlign: 'center' }}&gt;
          &lt;h3&gt;Something went wrong loading this section.&lt;/h3&gt;
          &lt;button onClick={() =&gt; this.setState({ hasError: false })}&gt;
            Try Again
          &lt;/button&gt;
        &lt;/div&gt;
      );
    }

    return this.props.children;
  }
}

// Main app with code splitting
function AppWithCodeSplitting() {
  const [currentView, setCurrentView] = useState&lt;'dashboard' | 'settings' | 'reports'&gt;('dashboard');

  const renderCurrentView = () =&gt; {
    switch (currentView) {
      case 'dashboard':
        return &lt;HeavyDashboard /&gt;;
      case 'settings':
        return &lt;UserSettings /&gt;;
      case 'reports':
        return &lt;Reports /&gt;;
      default:
        return &lt;div&gt;Select a view&lt;/div&gt;;
    }
  };

  return (
    &lt;div&gt;
      &lt;nav style={{ padding: '20px', borderBottom: '1px solid #ccc' }}&gt;
        &lt;button 
          onClick={() =&gt; setCurrentView('dashboard')}
          disabled={currentView === 'dashboard'}
        &gt;
          Dashboard
        &lt;/button&gt;
        &lt;button 
          onClick={() =&gt; setCurrentView('settings')}
          disabled={currentView === 'settings'}
        &gt;
          Settings
        &lt;/button&gt;
        &lt;button 
          onClick={() =&gt; setCurrentView('reports')}
          disabled={currentView === 'reports'}
        &gt;
          Reports
        &lt;/button&gt;
      &lt;/nav&gt;

      &lt;main style={{ padding: '20px' }}&gt;
        &lt;LazyLoadErrorBoundary&gt;
          &lt;Suspense fallback={&lt;LoadingSpinner /&gt;}&gt;
            {renderCurrentView()}
          &lt;/Suspense&gt;
        &lt;/LazyLoadErrorBoundary&gt;
      &lt;/main&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Route-based Code Splitting</h4>
              <pre><code class="language-tsx">// Simulate react-router-dom for demo purposes
const Router = ({ children }: { children: React.ReactNode }) =&gt; children;
const Routes = ({ children }: { children: React.ReactNode }) =&gt; children;
const Route = ({ path, element }: { path: string; element: React.ReactNode }) =&gt; element;

// Lazy load route components
const Home = lazy(() =&gt; import('./pages/Home'));
const About = lazy(() =&gt; import('./pages/About'));
const Contact = lazy(() =&gt; import('./pages/Contact'));
const Profile = lazy(() =&gt; import('./pages/Profile'));

// Higher-order component for lazy loading with error handling
function withLazyLoading(Component: React.LazyExoticComponent&lt;any&gt;) {
  return function LazyWrapper(props: any) {
    return (
      &lt;LazyLoadErrorBoundary&gt;
        &lt;Suspense 
          fallback={
            &lt;div className="lazy-loading"&gt;
              &lt;LoadingSpinner /&gt;
              &lt;p&gt;Loading page...&lt;/p&gt;
            &lt;/div&gt;
          }
        &gt;
          &lt;Component {...props} /&gt;
        &lt;/Suspense&gt;
      &lt;/LazyLoadErrorBoundary&gt;
    );
  };
}

// App with route-based code splitting
function AppWithRoutes() {
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;nav&gt;
          &lt;a href="/"&gt;Home&lt;/a&gt;
          &lt;a href="/about"&gt;About&lt;/a&gt;
          &lt;a href="/contact"&gt;Contact&lt;/a&gt;
          &lt;a href="/profile"&gt;Profile&lt;/a&gt;
        &lt;/nav&gt;
        
        &lt;Routes&gt;
          &lt;Route path="/" element={withLazyLoading(Home)({})} /&gt;
          &lt;Route path="/about" element={withLazyLoading(About)({})} /&gt;
          &lt;Route path="/contact" element={withLazyLoading(Contact)({})} /&gt;
          &lt;Route path="/profile" element={withLazyLoading(Profile)({})} /&gt;
        &lt;/Routes&gt;
      &lt;/div&gt;
    &lt;/Router&gt;
  );
}</code></pre>

              <h4>Dynamic Imports with Conditions</h4>
              <pre><code class="language-tsx">function ConditionalLoading() {
  const [showAdvanced, setShowAdvanced] = useState(false);
  const [AdvancedComponent, setAdvancedComponent] = useState&lt;React.ComponentType | null&gt;(null);
  const [loading, setLoading] = useState(false);

  const loadAdvancedComponent = async () =&gt; {
    if (AdvancedComponent) return; // Already loaded
    
    setLoading(true);
    try {
      // Dynamic import with condition
      const module = await import('./AdvancedFeatures');
      setAdvancedComponent(() =&gt; module.default);
    } catch (error) {
      console.error('Failed to load advanced component:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleToggleAdvanced = () =&gt; {
    if (!showAdvanced && !AdvancedComponent) {
      loadAdvancedComponent();
    }
    setShowAdvanced(!showAdvanced);
  };

  return (
    &lt;div&gt;
      &lt;h2&gt;Basic Features&lt;/h2&gt;
      &lt;p&gt;This content is always loaded.&lt;/p&gt;
      
      &lt;button 
        onClick={handleToggleAdvanced}
        disabled={loading}
      &gt;
        {loading ? 'Loading...' : showAdvanced ? 'Hide Advanced' : 'Show Advanced'}
      &lt;/button&gt;
      
      {showAdvanced && (
        &lt;div&gt;
          {AdvancedComponent ? (
            &lt;AdvancedComponent /&gt;
          ) : (
            &lt;div&gt;Loading advanced features...&lt;/div&gt;
          )}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-warning">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-exclamation-triangle"></i>
                    </span>
                    Performance Optimization Guidelines
                  </h4>
                  <ul class="mb-0">
                    <li>
                      <strong>Measure first:</strong> Use React DevTools
                      Profiler to identify actual performance bottlenecks
                    </li>
                    <li>
                      <strong>Don't optimize prematurely:</strong> Only optimize
                      when you have a proven performance problem
                    </li>
                    <li>
                      <strong>Consider bundle size:</strong> Code splitting can
                      reduce initial load time but may increase complexity
                    </li>
                    <li>
                      <strong>Test thoroughly:</strong> Performance
                      optimizations can introduce bugs if not properly tested
                    </li>
                    <li>
                      <strong>Monitor in production:</strong> Real-world
                      performance may differ from development
                    </li>
                  </ul>
                </div>
              </div>
            </section>
          </article>

          <!-- Testing Section -->
          <article class="docs-article" id="section-14">
            <header class="docs-header">
              <h1 class="docs-heading">Testing</h1>
              <section class="docs-intro">
                <p>
                  Testing React components ensures your application works
                  correctly and prevents regressions. React Testing Library
                  provides utilities for testing components in a way that
                  resembles how users interact with your app.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-14-1">
              <h2 class="section-heading">React Testing Library</h2>
              <p>
                React Testing Library is the recommended way to test React
                components. It encourages testing user interactions rather than
                implementation details.
              </p>

              <h4>Basic Component Testing</h4>
              <pre><code class="language-tsx">// Button.tsx - Component to test
interface ButtonProps {
  children: React.ReactNode;
  onClick?: () =&gt; void;
  disabled?: boolean;
  variant?: 'primary' | 'secondary';
}

export function Button({ children, onClick, disabled = false, variant = 'primary' }: ButtonProps) {
  return (
    &lt;button
      onClick={onClick}
      disabled={disabled}
      className={`btn btn-${variant}`}
    &gt;
      {children}
    &lt;/button&gt;
  );
}

// Button.test.tsx - Test file
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Button } from './Button';

describe('Button Component', () =&gt; {
  it('renders button with correct text', () =&gt; {
    render(&lt;Button&gt;Click me&lt;/Button&gt;);
    
    expect(screen.getByRole('button')).toBeInTheDocument();
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('calls onClick handler when clicked', async () =&gt; {
    const handleClick = jest.fn();
    const user = userEvent.setup();
    
    render(&lt;Button onClick={handleClick}&gt;Click me&lt;/Button&gt;);
    
    await user.click(screen.getByRole('button'));
    
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('is disabled when disabled prop is true', () =&gt; {
    render(&lt;Button disabled&gt;Disabled button&lt;/Button&gt;);
    
    expect(screen.getByRole('button')).toBeDisabled();
  });

  it('does not call onClick when disabled', async () =&gt; {
    const handleClick = jest.fn();
    const user = userEvent.setup();
    
    render(&lt;Button onClick={handleClick} disabled&gt;Disabled button&lt;/Button&gt;);
    
    await user.click(screen.getByRole('button'));
    
    expect(handleClick).not.toHaveBeenCalled();
  });

  it('applies correct CSS class for variant', () =&gt; {
    const { rerender } = render(&lt;Button variant="primary"&gt;Primary&lt;/Button&gt;);
    
    expect(screen.getByRole('button')).toHaveClass('btn-primary');
    
    rerender(&lt;Button variant="secondary"&gt;Secondary&lt;/Button&gt;);
    
    expect(screen.getByRole('button')).toHaveClass('btn-secondary');
  });
});</code></pre>

              <h4>Testing Forms and User Interactions</h4>
              <pre><code class="language-tsx">// LoginForm.tsx - Form component to test
interface LoginFormProps {
  onSubmit: (credentials: { username: string; password: string }) =&gt; void;
  loading?: boolean;
  error?: string;
}

export function LoginForm({ onSubmit, loading = false, error }: LoginFormProps) {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = (e: React.FormEvent) =&gt; {
    e.preventDefault();
    onSubmit({ username, password });
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      {error && (
        &lt;div role="alert" className="error"&gt;
          {error}
        &lt;/div&gt;
      )}
      
      &lt;div&gt;
        &lt;label htmlFor="username"&gt;Username:&lt;/label&gt;
        &lt;input
          id="username"
          type="text"
          value={username}
          onChange={(e) =&gt; setUsername(e.target.value)}
          disabled={loading}
        /&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="password"&gt;Password:&lt;/label&gt;
        &lt;input
          id="password"
          type="password"
          value={password}
          onChange={(e) =&gt; setPassword(e.target.value)}
          disabled={loading}
        /&gt;
      &lt;/div&gt;
      
      &lt;button type="submit" disabled={loading || !username || !password}&gt;
        {loading ? 'Logging in...' : 'Login'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}

// LoginForm.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { LoginForm } from './LoginForm';

describe('LoginForm', () =&gt; {
  const defaultProps = {
    onSubmit: jest.fn(),
    loading: false,
    error: undefined
  };

  beforeEach(() =&gt; {
    jest.clearAllMocks();
  });

  it('renders form elements correctly', () =&gt; {
    render(&lt;LoginForm {...defaultProps} /&gt;);
    
    expect(screen.getByLabelText(/username/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /login/i })).toBeInTheDocument();
  });

  it('updates input values when user types', async () =&gt; {
    const user = userEvent.setup();
    render(&lt;LoginForm {...defaultProps} /&gt;);
    
    const usernameInput = screen.getByLabelText(/username/i);
    const passwordInput = screen.getByLabelText(/password/i);
    
    await user.type(usernameInput, 'john');
    await user.type(passwordInput, 'password123');
    
    expect(usernameInput).toHaveValue('john');
    expect(passwordInput).toHaveValue('password123');
  });

  it('calls onSubmit with correct data when form is submitted', async () =&gt; {
    const mockOnSubmit = jest.fn();
    const user = userEvent.setup();
    
    render(&lt;LoginForm {...defaultProps} onSubmit={mockOnSubmit} /&gt;);
    
    await user.type(screen.getByLabelText(/username/i), 'john');
    await user.type(screen.getByLabelText(/password/i), 'password123');
    await user.click(screen.getByRole('button', { name: /login/i }));
    
    expect(mockOnSubmit).toHaveBeenCalledWith({
      username: 'john',
      password: 'password123'
    });
  });

  it('disables submit button when form is invalid', () =&gt; {
    render(&lt;LoginForm {...defaultProps} /&gt;);
    
    const submitButton = screen.getByRole('button', { name: /login/i });
    
    expect(submitButton).toBeDisabled();
  });

  it('shows loading state correctly', () =&gt; {
    render(&lt;LoginForm {...defaultProps} loading={true} /&gt;);
    
    expect(screen.getByRole('button', { name: /logging in/i })).toBeInTheDocument();
    expect(screen.getByLabelText(/username/i)).toBeDisabled();
    expect(screen.getByLabelText(/password/i)).toBeDisabled();
  });

  it('displays error message when provided', () =&gt; {
    const errorMessage = 'Invalid credentials';
    render(&lt;LoginForm {...defaultProps} error={errorMessage} /&gt;);
    
    expect(screen.getByRole('alert')).toHaveTextContent(errorMessage);
  });
});</code></pre>
            </section>

            <section class="docs-section" id="item-14-2">
              <h2 class="section-heading">Component Testing</h2>
              <p>
                Testing components involves verifying their rendering,
                interactions, and integration with other components. Focus on
                testing behavior rather than implementation details.
              </p>

              <h4>Testing Component Integration</h4>
              <pre><code class="language-tsx">// TodoApp.tsx - Integrated component to test
interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

export function TodoApp() {
  const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
  const [newTodo, setNewTodo] = useState('');
  
  const addTodo = () =&gt; {
    if (newTodo.trim()) {
      const todo: Todo = {
        id: Date.now(),
        text: newTodo.trim(),
        completed: false
      };
      setTodos(prev =&gt; [...prev, todo]);
      setNewTodo('');
    }
  };

  const toggleTodo = (id: number) =&gt; {
    setTodos(prev =&gt; prev.map(todo =&gt; 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const deleteTodo = (id: number) =&gt; {
    setTodos(prev =&gt; prev.filter(todo =&gt; todo.id !== id));
  };

  const completedCount = todos.filter(todo =&gt; todo.completed).length;

  return (
    &lt;div&gt;
      &lt;h1&gt;Todo App&lt;/h1&gt;
      
      &lt;div&gt;
        &lt;input
          type="text"
          value={newTodo}
          onChange={(e) =&gt; setNewTodo(e.target.value)}
          placeholder="Add new todo..."
          onKeyPress={(e) =&gt; e.key === 'Enter' && addTodo()}
        /&gt;
        &lt;button onClick={addTodo}&gt;Add&lt;/button&gt;
      &lt;/div&gt;

      &lt;div data-testid="todo-stats"&gt;
        {completedCount} of {todos.length} completed
      &lt;/div&gt;

      &lt;ul&gt;
        {todos.map(todo =&gt; (
          &lt;li key={todo.id} data-testid={`todo-${todo.id}`}&gt;
            &lt;input
              type="checkbox"
              checked={todo.completed}
              onChange={() =&gt; toggleTodo(todo.id)}
              aria-label={`Toggle ${todo.text}`}
            /&gt;
            &lt;span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}&gt;
              {todo.text}
            &lt;/span&gt;
            &lt;button onClick={() =&gt; deleteTodo(todo.id)}&gt;
              Delete
            &lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

// TodoApp.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { TodoApp } from './TodoApp';

describe('TodoApp Integration', () =&gt; {
  it('allows users to add, complete, and delete todos', async () =&gt; {
    const user = userEvent.setup();
    render(&lt;TodoApp /&gt;);
    
    // Initially no todos
    expect(screen.getByTestId('todo-stats')).toHaveTextContent('0 of 0 completed');
    
    // Add a todo
    const input = screen.getByPlaceholderText(/add new todo/i);
    const addButton = screen.getByRole('button', { name: /add/i });
    
    await user.type(input, 'Learn React Testing');
    await user.click(addButton);
    
    // Verify todo was added
    expect(screen.getByText('Learn React Testing')).toBeInTheDocument();
    expect(screen.getByTestId('todo-stats')).toHaveTextContent('0 of 1 completed');
    
    // Complete the todo
    const checkbox = screen.getByLabelText(/toggle learn react testing/i);
    await user.click(checkbox);
    
    // Verify todo is completed
    expect(checkbox).toBeChecked();
    expect(screen.getByTestId('todo-stats')).toHaveTextContent('1 of 1 completed');
    
    // Add another todo
    await user.type(input, 'Write tests');
    await user.click(addButton);
    
    expect(screen.getByTestId('todo-stats')).toHaveTextContent('1 of 2 completed');
    
    // Delete a todo
    const deleteButtons = screen.getAllByRole('button', { name: /delete/i });
    await user.click(deleteButtons[0]);
    
    expect(screen.queryByText('Learn React Testing')).not.toBeInTheDocument();
    expect(screen.getByTestId('todo-stats')).toHaveTextContent('0 of 1 completed');
  });

  it('allows adding todo by pressing Enter', async () =&gt; {
    const user = userEvent.setup();
    render(&lt;TodoApp /&gt;);
    
    const input = screen.getByPlaceholderText(/add new todo/i);
    
    await user.type(input, 'Quick todo{enter}');
    
    expect(screen.getByText('Quick todo')).toBeInTheDocument();
    expect(input).toHaveValue(''); // Input should be cleared
  });

  it('does not add empty todos', async () =&gt; {
    const user = userEvent.setup();
    render(&lt;TodoApp /&gt;);
    
    const addButton = screen.getByRole('button', { name: /add/i });
    
    // Try to add empty todo
    await user.click(addButton);
    
    expect(screen.getByTestId('todo-stats')).toHaveTextContent('0 of 0 completed');
    
    // Try to add whitespace-only todo
    const input = screen.getByPlaceholderText(/add new todo/i);
    await user.type(input, '   ');
    await user.click(addButton);
    
    expect(screen.getByTestId('todo-stats')).toHaveTextContent('0 of 0 completed');
  });
});</code></pre>

              <h4>Testing Hooks</h4>
              <pre><code class="language-tsx">// useCounter.ts - Custom hook to test
import { useState, useCallback } from 'react';

export function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = useCallback(() =&gt; {
    setCount(prev =&gt; prev + 1);
  }, []);

  const decrement = useCallback(() =&gt; {
    setCount(prev =&gt; prev - 1);
  }, []);

  const reset = useCallback(() =&gt; {
    setCount(initialValue);
  }, [initialValue]);

  const setValue = useCallback((value: number) =&gt; {
    setCount(value);
  }, []);

  return {
    count,
    increment,
    decrement,
    reset,
    setValue
  };
}

// useCounter.test.ts
import { renderHook, act } from '@testing-library/react';
import { useCounter } from './useCounter';

describe('useCounter Hook', () =&gt; {
  it('initializes with default value', () =&gt; {
    const { result } = renderHook(() =&gt; useCounter());
    
    expect(result.current.count).toBe(0);
  });

  it('initializes with provided value', () =&gt; {
    const { result } = renderHook(() =&gt; useCounter(10));
    
    expect(result.current.count).toBe(10);
  });

  it('increments count', () =&gt; {
    const { result } = renderHook(() =&gt; useCounter());
    
    act(() =&gt; {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
  });

  it('decrements count', () =&gt; {
    const { result } = renderHook(() =&gt; useCounter(5));
    
    act(() =&gt; {
      result.current.decrement();
    });
    
    expect(result.current.count).toBe(4);
  });

  it('resets to initial value', () =&gt; {
    const { result } = renderHook(() =&gt; useCounter(10));
    
    act(() =&gt; {
      result.current.increment();
      result.current.increment();
    });
    
    expect(result.current.count).toBe(12);
    
    act(() =&gt; {
      result.current.reset();
    });
    
    expect(result.current.count).toBe(10);
  });

  it('sets specific value', () =&gt; {
    const { result } = renderHook(() =&gt; useCounter());
    
    act(() =&gt; {
      result.current.setValue(25);
    });
    
    expect(result.current.count).toBe(25);
  });

  it('maintains function reference stability', () =&gt; {
    const { result, rerender } = renderHook(() =&gt; useCounter());
    
    const firstIncrement = result.current.increment;
    const firstDecrement = result.current.decrement;
    const firstReset = result.current.reset;
    
    rerender();
    
    expect(result.current.increment).toBe(firstIncrement);
    expect(result.current.decrement).toBe(firstDecrement);
    expect(result.current.reset).toBe(firstReset);
  });
});</code></pre>
            </section>

            <section class="docs-section" id="item-14-3">
              <h2 class="section-heading">Mocking</h2>
              <p>
                Mocking allows you to isolate components for testing by
                replacing dependencies with controlled implementations. This
                helps create predictable test conditions.
              </p>

              <h4>Mocking API Calls</h4>
              <pre><code class="language-tsx">// UserProfile.tsx - Component that fetches data
interface User {
  id: number;
  name: string;
  email: string;
}

interface UserProfileProps {
  userId: number;
}

export function UserProfile({ userId }: UserProfileProps) {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;string | null&gt;(null);

  useEffect(() =&gt; {
    let cancelled = false;

    const fetchUser = async () =&gt; {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(`/api/users/${userId}`);
        
        if (!response.ok) {
          throw new Error('Failed to fetch user');
        }
        
        const userData = await response.json();
        
        if (!cancelled) {
          setUser(userData);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err instanceof Error ? err.message : 'Unknown error');
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };

    fetchUser();

    return () =&gt; {
      cancelled = true;
    };
  }, [userId]);

  if (loading) {
    return &lt;div role="status"&gt;Loading user...&lt;/div&gt;;
  }

  if (error) {
    return &lt;div role="alert"&gt;Error: {error}&lt;/div&gt;;
  }

  if (!user) {
    return &lt;div&gt;User not found&lt;/div&gt;;
  }

  return (
    &lt;div data-testid="user-profile"&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;Email: {user.email}&lt;/p&gt;
      &lt;p&gt;ID: {user.id}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// UserProfile.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import { UserProfile } from './UserProfile';

// Mock fetch globally
const mockFetch = jest.fn();
global.fetch = mockFetch;

describe('UserProfile', () =&gt; {
  beforeEach(() =&gt; {
    mockFetch.mockClear();
  });

  it('displays loading state initially', () =&gt; {
    mockFetch.mockImplementation(() =&gt; new Promise(() =&gt; {})); // Never resolves
    
    render(&lt;UserProfile userId={1} /&gt;);
    
    expect(screen.getByRole('status')).toHaveTextContent('Loading user...');
  });

  it('displays user data when fetch succeeds', async () =&gt; {
    const mockUser = {
      id: 1,
      name: 'John Doe',
      email: 'john@example.com'
    };

    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: () =&gt; Promise.resolve(mockUser)
    });

    render(&lt;UserProfile userId={1} /&gt;);

    await waitFor(() =&gt; {
      expect(screen.getByTestId('user-profile')).toBeInTheDocument();
    });

    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('Email: john@example.com')).toBeInTheDocument();
    expect(screen.getByText('ID: 1')).toBeInTheDocument();
    
    expect(mockFetch).toHaveBeenCalledWith('/api/users/1');
  });

  it('displays error message when fetch fails', async () =&gt; {
    mockFetch.mockRejectedValueOnce(new Error('Network error'));

    render(&lt;UserProfile userId={1} /&gt;);

    await waitFor(() =&gt; {
      expect(screen.getByRole('alert')).toBeInTheDocument();
    });

    expect(screen.getByText('Error: Network error')).toBeInTheDocument();
  });

  it('displays error when response is not ok', async () =&gt; {
    mockFetch.mockResolvedValueOnce({
      ok: false,
      status: 404
    });

    render(&lt;UserProfile userId={999} /&gt;);

    await waitFor(() =&gt; {
      expect(screen.getByRole('alert')).toBeInTheDocument();
    });

    expect(screen.getByText('Error: Failed to fetch user')).toBeInTheDocument();
  });

  it('refetches when userId changes', async () =&gt; {
    const user1 = { id: 1, name: 'User 1', email: 'user1@example.com' };
    const user2 = { id: 2, name: 'User 2', email: 'user2@example.com' };

    mockFetch
      .mockResolvedValueOnce({
        ok: true,
        json: () =&gt; Promise.resolve(user1)
      })
      .mockResolvedValueOnce({
        ok: true,
        json: () =&gt; Promise.resolve(user2)
      });

    const { rerender } = render(&lt;UserProfile userId={1} /&gt;);

    await waitFor(() =&gt; {
      expect(screen.getByText('User 1')).toBeInTheDocument();
    });

    rerender(&lt;UserProfile userId={2} /&gt;);

    await waitFor(() =&gt; {
      expect(screen.getByText('User 2')).toBeInTheDocument();
    });

    expect(mockFetch).toHaveBeenCalledTimes(2);
    expect(mockFetch).toHaveBeenNthCalledWith(1, '/api/users/1');
    expect(mockFetch).toHaveBeenNthCalledWith(2, '/api/users/2');
  });
});</code></pre>

              <h4>Mocking Modules and Components</h4>
              <pre><code class="language-tsx">// Modal.tsx - Component that uses a portal
import { createPortal } from 'react-dom';

interface ModalProps {
  isOpen: boolean;
  onClose: () =&gt; void;
  children: React.ReactNode;
}

export function Modal({ isOpen, onClose, children }: ModalProps) {
  if (!isOpen) return null;

  return createPortal(
    &lt;div className="modal-overlay" onClick={onClose}&gt;
      &lt;div className="modal-content" onClick={(e) =&gt; e.stopPropagation()}&gt;
        &lt;button className="modal-close" onClick={onClose}&gt;
          ×
        &lt;/button&gt;
        {children}
      &lt;/div&gt;
    &lt;/div&gt;,
    document.body
  );
}

// App.tsx - Component using Modal
export function App() {
  const [modalOpen, setModalOpen] = useState(false);

  return (
    &lt;div&gt;
      &lt;h1&gt;My App&lt;/h1&gt;
      &lt;button onClick={() =&gt; setModalOpen(true)}&gt;
        Open Modal
      &lt;/button&gt;
      
      &lt;Modal isOpen={modalOpen} onClose={() =&gt; setModalOpen(false)}&gt;
        &lt;h2&gt;Modal Content&lt;/h2&gt;
        &lt;p&gt;This is the modal content.&lt;/p&gt;
      &lt;/Modal&gt;
    &lt;/div&gt;
  );
}

// App.test.tsx - Test with mocked Modal
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { App } from './App';

// Mock the Modal component
jest.mock('./Modal', () =&gt; ({
  Modal: ({ isOpen, onClose, children }: any) =&gt; 
    isOpen ? (
      &lt;div data-testid="modal"&gt;
        &lt;button onClick={onClose}&gt;Close&lt;/button&gt;
        {children}
      &lt;/div&gt;
    ) : null
}));

describe('App with Mocked Modal', () =&gt; {
  it('opens and closes modal correctly', async () =&gt; {
    const user = userEvent.setup();
    render(&lt;App /&gt;);

    // Modal should not be visible initially
    expect(screen.queryByTestId('modal')).not.toBeInTheDocument();

    // Open modal
    await user.click(screen.getByText('Open Modal'));
    expect(screen.getByTestId('modal')).toBeInTheDocument();
    expect(screen.getByText('Modal Content')).toBeInTheDocument();

    // Close modal
    await user.click(screen.getByText('Close'));
    expect(screen.queryByTestId('modal')).not.toBeInTheDocument();
  });
});

// Alternative: Mock with jest.fn() for more control
jest.mock('./Modal', () =&gt; ({
  Modal: jest.fn(({ isOpen, children }) =&gt; 
    isOpen ? &lt;div data-testid="modal"&gt;{children}&lt;/div&gt; : null
  )
}));

import { Modal } from './Modal';
const MockedModal = Modal as jest.MockedFunction&lt;typeof Modal&gt;;

describe('App with Function Mock', () =&gt; {
  beforeEach(() =&gt; {
    MockedModal.mockClear();
  });

  it('passes correct props to Modal', async () =&gt; {
    const user = userEvent.setup();
    render(&lt;App /&gt;);

    expect(MockedModal).toHaveBeenCalledWith(
      expect.objectContaining({
        isOpen: false,
        onClose: expect.any(Function)
      }),
      {}
    );

    await user.click(screen.getByText('Open Modal'));

    expect(MockedModal).toHaveBeenLastCalledWith(
      expect.objectContaining({
        isOpen: true,
        onClose: expect.any(Function)
      }),
      {}
    );
  });
});</code></pre>

              <div class="callout-block callout-block-success">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-lightbulb"></i>
                    </span>
                    Testing Best Practices
                  </h4>
                  <ul class="mb-0">
                    <li>
                      <strong>Test behavior, not implementation:</strong> Focus
                      on what users can see and do
                    </li>
                    <li>
                      <strong>Use accessible queries:</strong> Prefer getByRole,
                      getByLabelText over getByTestId
                    </li>
                    <li>
                      <strong>Test user interactions:</strong> Use userEvent
                      instead of fireEvent for more realistic tests
                    </li>
                    <li>
                      <strong>Mock external dependencies:</strong> Isolate
                      components by mocking APIs and third-party libraries
                    </li>
                    <li>
                      <strong>Test error states:</strong> Don't forget to test
                      loading, error, and edge cases
                    </li>
                    <li>
                      <strong>Keep tests simple:</strong> Each test should focus
                      on one specific behavior
                    </li>
                  </ul>
                </div>
              </div>
            </section>
          </article>

          <!-- Best Practices Section -->
          <article class="docs-article" id="section-15">
            <header class="docs-header">
              <h1 class="docs-heading">Best Practices</h1>
              <section class="docs-intro">
                <p>
                  Following React best practices ensures your applications are
                  maintainable, performant, and scalable. These guidelines help
                  you write clean, reliable React code.
                </p>
              </section>
            </header>

            <section class="docs-section" id="item-15-1">
              <h2 class="section-heading">Component Design</h2>
              <p>
                Well-designed components are the foundation of maintainable
                React applications. They should be focused, reusable, and easy
                to understand.
              </p>

              <h4>Single Responsibility Principle</h4>
              <pre><code class="language-tsx">// ❌ Bad: Component doing too many things
function UserDashboard({ userId }: { userId: number }) {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const [posts, setPosts] = useState&lt;Post[]&gt;([]);
  const [notifications, setNotifications] = useState&lt;Notification[]&gt;([]);
  const [settings, setSettings] = useState&lt;Settings | null&gt;(null);
  
  // Multiple useEffect hooks for different concerns
  useEffect(() =&gt; { /* fetch user */ }, [userId]);
  useEffect(() =&gt; { /* fetch posts */ }, [userId]);
  useEffect(() =&gt; { /* fetch notifications */ }, [userId]);
  useEffect(() =&gt; { /* fetch settings */ }, [userId]);
  
  // Complex rendering logic mixing different concerns
  return (
    &lt;div&gt;
      {/* User profile rendering */}
      {/* Posts rendering */}
      {/* Notifications rendering */}
      {/* Settings rendering */}
    &lt;/div&gt;
  );
}

// ✅ Good: Separate components for different responsibilities
function UserProfile({ user }: { user: User }) {
  return (
    &lt;div className="user-profile"&gt;
      &lt;img src={user.avatar} alt={user.name} /&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}

function UserPosts({ userId }: { userId: number }) {
  const [posts, setPosts] = useState&lt;Post[]&gt;([]);
  const [loading, setLoading] = useState(true);

  useEffect(() =&gt; {
    fetchUserPosts(userId).then(setPosts).finally(() =&gt; setLoading(false));
  }, [userId]);

  if (loading) return &lt;div&gt;Loading posts...&lt;/div&gt;;

  return (
    &lt;div className="user-posts"&gt;
      {posts.map(post =&gt; (
        &lt;PostCard key={post.id} post={post} /&gt;
      ))}
    &lt;/div&gt;
  );
}

function NotificationsList({ userId }: { userId: number }) {
  const [notifications, setNotifications] = useState&lt;Notification[]&gt;([]);

  useEffect(() =&gt; {
    fetchNotifications(userId).then(setNotifications);
  }, [userId]);

  return (
    &lt;div className="notifications"&gt;
      {notifications.map(notification =&gt; (
        &lt;NotificationItem key={notification.id} notification={notification} /&gt;
      ))}
    &lt;/div&gt;
  );
}

// Composed dashboard
function UserDashboard({ userId }: { userId: number }) {
  const { user, loading, error } = useUser(userId);

  if (loading) return &lt;LoadingSpinner /&gt;;
  if (error) return &lt;ErrorMessage error={error} /&gt;;
  if (!user) return &lt;div&gt;User not found&lt;/div&gt;;

  return (
    &lt;div className="dashboard"&gt;
      &lt;UserProfile user={user} /&gt;
      &lt;UserPosts userId={userId} /&gt;
      &lt;NotificationsList userId={userId} /&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Props Interface Design</h4>
              <pre><code class="language-tsx">// ✅ Good: Clear, typed props interfaces
interface ButtonProps {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  loading?: boolean;
  onClick?: (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void;
  'aria-label'?: string;
  className?: string;
}

// ✅ Good: Extending HTML attributes when appropriate
interface InputProps extends Omit&lt;React.InputHTMLAttributes&lt;HTMLInputElement&gt;, 'onChange'&gt; {
  label: string;
  error?: string;
  onChange: (value: string) =&gt; void;
  required?: boolean;
}

// ✅ Good: Using generic types for reusable components
interface SelectProps&lt;T&gt; {
  options: Array&lt;{ value: T; label: string }&gt;;
  value: T;
  onChange: (value: T) =&gt; void;
  placeholder?: string;
  disabled?: boolean;
}

function Select&lt;T&gt;({ options, value, onChange, placeholder, disabled }: SelectProps&lt;T&gt;) {
  return (
    &lt;select 
      value={String(value)} 
      onChange={(e) =&gt; {
        const selectedOption = options.find(opt =&gt; String(opt.value) === e.target.value);
        if (selectedOption) onChange(selectedOption.value);
      }}
      disabled={disabled}
    &gt;
      {placeholder && &lt;option value=""&gt;{placeholder}&lt;/option&gt;}
      {options.map((option, index) =&gt; (
        &lt;option key={index} value={String(option.value)}&gt;
          {option.label}
        &lt;/option&gt;
      ))}
    &lt;/select&gt;
  );
}

// Usage
&lt;Select&lt;string&gt;
  options={[
    { value: 'js', label: 'JavaScript' },
    { value: 'ts', label: 'TypeScript' },
    { value: 'py', label: 'Python' }
  ]}
  value={selectedLanguage}
  onChange={setSelectedLanguage}
  placeholder="Select a language"
/&gt;</code></pre>

              <h4>Component Composition Patterns</h4>
              <pre><code class="language-tsx">// ✅ Good: Compound components pattern
interface CardContextType {
  variant: 'default' | 'elevated' | 'outlined';
}

const CardContext = createContext&lt;CardContextType | null&gt;(null);

function Card({ 
  children, 
  variant = 'default' 
}: { 
  children: React.ReactNode; 
  variant?: CardContextType['variant'];
}) {
  return (
    &lt;CardContext.Provider value={{ variant }}&gt;
      &lt;div className={`card card-${variant}`}&gt;
        {children}
      &lt;/div&gt;
    &lt;/CardContext.Provider&gt;
  );
}

function CardHeader({ children }: { children: React.ReactNode }) {
  const context = useContext(CardContext);
  return (
    &lt;div className={`card-header ${context?.variant === 'elevated' ? 'elevated' : ''}`}&gt;
      {children}
    &lt;/div&gt;
  );
}

function CardContent({ children }: { children: React.ReactNode }) {
  return &lt;div className="card-content"&gt;{children}&lt;/div&gt;;
}

function CardActions({ children }: { children: React.ReactNode }) {
  return &lt;div className="card-actions"&gt;{children}&lt;/div&gt;;
}

// Attach sub-components to main component
Card.Header = CardHeader;
Card.Content = CardContent;
Card.Actions = CardActions;

// Usage
function UserCard() {
  return (
    &lt;Card variant="elevated"&gt;
      &lt;Card.Header&gt;
        &lt;h3&gt;John Doe&lt;/h3&gt;
      &lt;/Card.Header&gt;
      &lt;Card.Content&gt;
        &lt;p&gt;Software Engineer&lt;/p&gt;
        &lt;p&gt;john@example.com&lt;/p&gt;
      &lt;/Card.Content&gt;
      &lt;Card.Actions&gt;
        &lt;button&gt;Edit&lt;/button&gt;
        &lt;button&gt;Delete&lt;/button&gt;
      &lt;/Card.Actions&gt;
    &lt;/Card&gt;
  );
}</code></pre>
            </section>

            <section class="docs-section" id="item-15-2">
              <h2 class="section-heading">Code Organization</h2>
              <p>
                Proper code organization makes your React applications easier to
                navigate, maintain, and scale. Follow consistent patterns for
                file structure and naming.
              </p>

              <h4>File and Folder Structure</h4>
              <pre><code class="language-text">src/
├── components/           # Reusable UI components
│   ├── ui/              # Basic UI components
│   │   ├── Button/
│   │   │   ├── Button.tsx
│   │   │   ├── Button.test.tsx
│   │   │   ├── Button.stories.tsx
│   │   │   └── index.ts
│   │   ├── Input/
│   // ✅ Good use case: Pure component with expensive rendering
const UserCard = memo(({ user }: { user: User }) =&gt; {
  return (
    &lt;div className="user-card"&gt;
      &lt;img src={user.avatar} alt={user.name} /&gt;
      &lt;h3&gt;{user.name}&lt;/h3&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
});

// ❌ Don't memo: Component that always receives new props
const Timestamp = memo(() =&gt; {
  return &lt;span&gt;{new Date().toLocaleTimeString()}&lt;/span&gt;;
});

// ❌ Don't memo: Component with children (children are often new objects)
const Container = memo(({ children }: { children: React.ReactNode }) =&gt; {
  return &lt;div className="container"&gt;{children}&lt;/div&gt;;
});

// ✅ Good: List item that rarely changes
const TodoItem = memo(({ 
  todo, 
  onToggle, 
  onDelete 
}: { 
  todo: Todo; 
  onToggle: (id: number) =&gt; void; 
  onDelete: (id: number) =&gt; void; 
}) =&gt; {
  return (
    &lt;div className="todo-item"&gt;
      &lt;input 
        type="checkbox" 
        checked={todo.completed}
        onChange={() =&gt; onToggle(todo.id)}
      /&gt;
      &lt;span&gt;{todo.text}&lt;/span&gt;
      &lt;button onClick={() =&gt; onDelete(todo.id)}&gt;Delete&lt;/button&gt;
    &lt;/div&gt;
  );
});</code></pre>
            </section>

            <section class="docs-section" id="item-15-3">
              <h2 class="section-heading">Error Boundaries</h2>
              <p>
                Error boundaries are React components that catch JavaScript
                errors anywhere in their child component tree. While error
                boundaries must be class components, you can create reusable
                error boundary components and use modern patterns with
                functional components for error handling.
              </p>

              <h4>Simple Reusable Error Boundary</h4>
              <pre><code class="language-tsx">import React, { Component, ErrorInfo, ReactNode } from 'react';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
}

interface ErrorBoundaryState {
  hasError: boolean;
}

// Minimal error boundary class component (reusable)
class ErrorBoundary extends Component&lt;ErrorBoundaryProps, ErrorBoundaryState&gt; {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(): ErrorBoundaryState {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.props.onError?.(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        &lt;div className="error-fallback"&gt;
          &lt;h2&gt;Something went wrong&lt;/h2&gt;
          &lt;button onClick={() =&gt; this.setState({ hasError: false })}&gt;
            Try again
          &lt;/button&gt;
        &lt;/div&gt;
      );
    }
    return this.props.children;
  }
}</code></pre>

              <h4>Functional Component Error Handling Patterns</h4>
              <pre><code class="language-tsx">import { useState, useEffect, ReactNode } from 'react';

// Custom hook for error handling in functional components
function useErrorHandler() {
  const [error, setError] = useState&lt;Error | null&gt;(null);

  const throwError = (error: Error) =&gt; {
    setError(error);
    throw error; // This will be caught by the nearest error boundary
  };

  const clearError = () =&gt; setError(null);

  return { error, throwError, clearError };
}

// Higher-order component for error handling
function withErrorBoundary&lt;P extends object&gt;(
  WrappedComponent: React.ComponentType&lt;P&gt;,
  fallbackComponent?: React.ComponentType&lt;{ error?: Error; retry?: () =&gt; void }&gt;
) {
  return function WithErrorBoundaryComponent(props: P) {
    return (
      &lt;ErrorBoundary
        fallback={
          fallbackComponent ? (
            React.createElement(fallbackComponent, {
              error: undefined,
              retry: () =&gt; window.location.reload()
            })
          ) : undefined
        }
      &gt;
        &lt;WrappedComponent {...props} /&gt;
      &lt;/ErrorBoundary&gt;
    );
  };
}

// Example functional component with error handling
function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const { throwError } = useErrorHandler();

  useEffect(() =&gt; {
    fetchUser(userId)
      .then(setUser)
      .catch(throwError) // This will trigger the error boundary
      .finally(() =&gt; setLoading(false));
  }, [userId, throwError]);

  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (!user) return &lt;div&gt;No user found&lt;/div&gt;;

  return (
    &lt;div&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Usage with HOC
const UserProfileWithErrorBoundary = withErrorBoundary(UserProfile);</code></pre>

              <h4>React-Error-Boundary Library (Recommended)</h4>
              <pre><code class="language-tsx">// npm install react-error-boundary
import { ErrorBoundary, withErrorBoundary } from 'react-error-boundary';

// Error fallback component
function ErrorFallback({ 
  error, 
  resetErrorBoundary 
}: { 
  error: Error; 
  resetErrorBoundary: () =&gt; void; 
}) {
  return (
    &lt;div role="alert" className="error-boundary"&gt;
      &lt;h2&gt;Something went wrong:&lt;/h2&gt;
      &lt;pre&gt;{error.message}&lt;/pre&gt;
      &lt;button onClick={resetErrorBoundary}&gt;Try again&lt;/button&gt;
    &lt;/div&gt;
  );
}

// Using ErrorBoundary component
function App() {
  return (
    &lt;ErrorBoundary
      FallbackComponent={ErrorFallback}
      onError={(error, errorInfo) =&gt; {
        console.log('Error caught:', error, errorInfo);
        // Send to error reporting service
      }}
      onReset={() =&gt; {
        // Clear any state if needed
        window.location.reload();
      }}
    &gt;
      &lt;Header /&gt;
      &lt;MainContent /&gt;
      &lt;Footer /&gt;
    &lt;/ErrorBoundary&gt;
  );
}

// Using withErrorBoundary HOC
const SafeComponent = withErrorBoundary(MyComponent, {
  fallback: ErrorFallback,
  onError: (error, errorInfo) =&gt; {
    console.log('Error in SafeComponent:', error, errorInfo);
  }
});

// Using useErrorHandler hook from react-error-boundary
import { useErrorHandler } from 'react-error-boundary';

function DataFetcher() {
  const [data, setData] = useState(null);
  const handleError = useErrorHandler();

  useEffect(() =&gt; {
    fetchData()
      .then(setData)
      .catch(handleError); // Automatically triggers error boundary
  }, [handleError]);

  return &lt;div&gt;{data ? JSON.stringify(data) : 'Loading...'}&lt;/div&gt;;
}</code></pre>

              <h4>Async Error Handling in Functional Components</h4>
              <pre><code class="language-tsx">// Custom hook for async operations with error boundaries
function useAsyncError() {
  const [, setError] = useState();
  return (error: Error) =&gt; {
    setError(() =&gt; {
      throw error;
    });
  };
}

// Hook for safe async operations
function useSafeAsync&lt;T&gt;() {
  const [state, setState] = useState&lt;{
    data: T | null;
    loading: boolean;
    error: Error | null;
  }&gt;({
    data: null,
    loading: false,
    error: null
  });

  const throwError = useAsyncError();

  const execute = async (asyncFunction: () =&gt; Promise&lt;T&gt;) =&gt; {
    try {
      setState(prev =&gt; ({ ...prev, loading: true, error: null }));
      const data = await asyncFunction();
      setState({ data, loading: false, error: null });
      return data;
    } catch (error) {
      const errorObj = error instanceof Error ? error : new Error(String(error));
      setState({ data: null, loading: false, error: errorObj });
      throwError(errorObj); // This will trigger error boundary
    }
  };

  return { ...state, execute };
}

// Usage example
function ProductList() {
  const { data: products, loading, error, execute } = useSafeAsync&lt;Product[]&gt;();

  useEffect(() =&gt; {
    execute(() =&gt; fetchProducts());
  }, [execute]);

  if (loading) return &lt;div&gt;Loading products...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;

  return (
    &lt;ul&gt;
      {products?.map(product =&gt; (
        &lt;li key={product.id}&gt;{product.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

              <h4>Error Boundary Best Practices</h4>
              <pre><code class="language-tsx">// Granular error boundaries for better UX
function AppWithGranularErrorBoundaries() {
  return (
    &lt;div className="app"&gt;
      {/* Header with its own error boundary */}
      &lt;ErrorBoundary fallback={&lt;div&gt;Header unavailable&lt;/div&gt;}&gt;
        &lt;Header /&gt;
      &lt;/ErrorBoundary&gt;

      &lt;main&gt;
        {/* Sidebar with its own error boundary */}
        &lt;ErrorBoundary fallback={&lt;div&gt;Sidebar unavailable&lt;/div&gt;}&gt;
          &lt;Sidebar /&gt;
        &lt;/ErrorBoundary&gt;

        {/* Main content with its own error boundary */}
        &lt;ErrorBoundary 
          fallback={
            &lt;div&gt;
              &lt;h2&gt;Main content failed to load&lt;/h2&gt;
              &lt;button onClick={() =&gt; window.location.reload()}&gt;
                Refresh page
              &lt;/button&gt;
            &lt;/div&gt;
          }
        &gt;
          &lt;MainContent /&gt;
        &lt;/ErrorBoundary&gt;
      &lt;/main&gt;

      {/* Footer with its own error boundary */}
      &lt;ErrorBoundary fallback={&lt;div&gt;Footer unavailable&lt;/div&gt;}&gt;
        &lt;Footer /&gt;
      &lt;/ErrorBoundary&gt;
    &lt;/div&gt;
  );
}

// Error reporting utility
function reportError(error: Error, errorInfo?: any) {
  // Send to error tracking service (Sentry, LogRocket, etc.)
  console.error('Error reported:', { error, errorInfo });
  
  // Example with a hypothetical error service
  // errorTrackingService.captureException(error, {
  //   extra: errorInfo,
  //   tags: {
  //     component: 'ErrorBoundary'
  //   }
  // });
}

// Production-ready error boundary setup
function ProductionApp() {
  return (
    &lt;ErrorBoundary
      FallbackComponent={({ error, resetErrorBoundary }) =&gt; (
        &lt;div className="error-page"&gt;
          &lt;h1&gt;Oops! Something went wrong&lt;/h1&gt;
          &lt;p&gt;We apologize for the inconvenience. Please try again.&lt;/p&gt;
          &lt;details style={{ whiteSpace: 'pre-wrap', marginTop: '1rem' }}&gt;
            &lt;summary&gt;Error details (for developers)&lt;/summary&gt;
            {error.stack}
          &lt;/details&gt;
          &lt;div style={{ marginTop: '1rem' }}&gt;
            &lt;button onClick={resetErrorBoundary}&gt;
              Try again
            &lt;/button&gt;
            &lt;button onClick={() =&gt; window.location.href = '/'}&gt;
              Go to homepage
            &lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      )}
      onError={reportError}
    &gt;
      &lt;Router&gt;
        &lt;Routes&gt;
          &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
          &lt;Route path="/products" element={&lt;Products /&gt;} /&gt;
          &lt;Route path="/profile" element={&lt;Profile /&gt;} /&gt;
        &lt;/Routes&gt;
      &lt;/Router&gt;
    &lt;/ErrorBoundary&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-info">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-info-circle"></i>
                    </span>
                    Error Boundary Limitations
                  </h4>
                  <p>
                    <strong>Error boundaries do NOT catch errors for:</strong>
                  </p>
                  <ul class="mb-0">
                    <li>Event handlers (use try-catch instead)</li>
                    <li>
                      Asynchronous code (e.g., setTimeout or
                      requestAnimationFrame callbacks)
                    </li>
                    <li>Errors thrown during server-side rendering</li>
                    <li>Errors thrown in the error boundary itself</li>
                  </ul>
                </div>
              </div>

              <div class="callout-block callout-block-success">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-lightbulb"></i>
                    </span>
                    Best Practices
                  </h4>
                  <ul class="mb-0">
                    <li>
                      <strong>Use multiple error boundaries:</strong> Don't wrap
                      your entire app in one boundary
                    </li>
                    <li>
                      <strong>Provide meaningful fallbacks:</strong> Show
                      helpful error messages, not just "Something went wrong"
                    </li>
                    <li>
                      <strong>Log errors:</strong> Always log errors to
                      monitoring services
                    </li>
                    <li>
                      <strong>Test error scenarios:</strong> Deliberately throw
                      errors in development to test boundaries
                    </li>
                    <li>
                      <strong>Consider react-error-boundary:</strong> Use the
                      library for more features and better DX
                    </li>
                    <li>
                      <strong>Handle async errors:</strong> Use custom hooks to
                      bridge async errors to error boundaries
                    </li>
                  </ul>
                </div>
              </div>
            </section>
          </article>

          <!-- Footer Section -->
          <footer class="footer">
            <div class="container text-center py-5">
              <ul class="social-list list-unstyled pb-4 mb-0">
                <li class="list-inline-item">
                  <a
                    href="https://www.facebook.com/AmpersandAcademy"
                    target="_blank"
                  >
                    <i class="fab fa-facebook-f fa-fw"></i>
                  </a>
                </li>
                <li class="list-inline-item">
                  <a
                    href="https://www.google.com/maps/place//data=!4m2!3m1!1s0x3a5267c7e2f583e1:0x2571d69e5709aacd?source=g.page.default"
                    target="_blank"
                  >
                    <i class="fab fa-google fa-fw"></i>
                  </a>
                </li>
                <li class="list-inline-item">
                  <a
                    href="https://www.linkedin.com/company/ampersandacademy/"
                    target="_blank"
                  >
                    <i class="fab fa-linkedin fa-fw"></i>
                  </a>
                </li>
                <li class="list-inline-item">
                  <a
                    href="https://www.instagram.com/ampersandacad/"
                    target="_blank"
                  >
                    <i class="fab fa-instagram fa-fw"></i>
                  </a>
                </li>
                <li class="list-inline-item">
                  <a
                    href="https://whatsapp.com/channel/0029Va9uvHh4Ui2ZTI70bH2w"
                    target="_blank"
                  >
                    <i class="fab fa-whatsapp fa-fw"></i>
                  </a>
                </li>
                <li class="list-inline-item">
                  <a href="https://t.me/ampersandacad" target="_blank">
                    <i class="fab fa-telegram fa-fw"></i>
                  </a>
                </li>
              </ul>
              <!--//social-list-->
              <small class="copyright">
                <a href="https://ampersandacademy.com" target="_blank"
                  >Ampersand Academy</a
                >
                | All rights reserved
              </small>
            </div>
          </footer>
        </div>
        <!--//container-->
      </div>
      <!--//docs-content-->
    </div>
    <!--//docs-wrapper-->

    <!-- JavaScript -->
    <script src="assets/plugins/popper.min.js"></script>
    <script src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>

    <!-- Page Specific JS -->
    <script src="assets/plugins/smoothscroll.min.js"></script>

    <!-- Prism.js for Syntax Highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>

    <!-- Other plugins -->
    <script src="assets/plugins/simplelightbox/simple-lightbox.min.js"></script>
    <script src="assets/plugins/gumshoe/gumshoe.polyfills.min.js"></script>
    <script src="assets/js/docs.js"></script>

    <!-- Custom Prism initialization -->
    <script>
      // Prism.js auto-highlights code blocks
      // Additional custom initialization if needed
      document.addEventListener("DOMContentLoaded", function () {
        if (typeof Prism !== "undefined") {
          // Force re-highlight if needed
          Prism.highlightAll();
        }
      });
    </script>
  </body>
</html>
