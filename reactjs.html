<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Ampersand Academy - React.js Notes</title>

    <!-- Meta -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta name="description" content="React.js Guide and Notes" />
    <meta name="author" content="Ampersand Academy" />
    <link rel="shortcut icon" href="favicon.ico" />

    <!-- Google Font -->
    <link
      href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap"
      rel="stylesheet"
    />

    <!-- FontAwesome JS-->
    <script defer src="assets/fontawesome/js/all.min.js"></script>

    <!-- Plugins CSS -->
    <link
      rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.2/styles/atom-one-dark.min.css"
    />
    <link
      rel="stylesheet"
      href="assets/plugins/simplelightbox/simple-lightbox.min.css"
    />

    <!-- Dark Github Gist CSS -->
    <link
      id="theme-style"
      rel="stylesheet"
      href="assets/css/darkGist.min.css"
    />

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/theme.css" />
  </head>

  <body class="docs-page">
    <header class="header fixed-top">
      <div class="branding docs-branding">
        <div class="container-fluid position-relative py-2">
          <div class="docs-logo-wrapper">
            <button
              id="docs-sidebar-toggler"
              class="docs-sidebar-toggler docs-sidebar-visible me-2 d-xl-none"
              type="button"
            >
              <span></span>
              <span></span>
              <span></span>
            </button>
            <div class="site-logo">
              <a class="navbar-brand" href="index.html"
                ><img
                  class="logo me-2"
                  src="assets/images/Ampersand_Academy_Logo.svg"
                  alt="logo"
                  height="50"
              /></a>
            </div>
          </div>
          <!--//docs-logo-wrapper-->
          <div
            class="docs-top-utilities d-flex justify-content-end align-items-center"
          >
            <ul
              class="social-list list-inline mx-md-3 mx-lg-5 mb-0 d-none d-lg-flex"
            >
              <li class="list-inline-item">
                <a
                  href="https://www.facebook.com/AmpersandAcademy"
                  target="_blank"
                  ><i class="fab fa-facebook-f fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a
                  href="https://www.google.com/maps/place//data=!4m2!3m1!1s0x3a5267c7e2f583e1:0x2571d69e5709aacd?source=g.page.default"
                  target="_blank"
                  ><i class="fab fa-google fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a
                  href="https://www.linkedin.com/company/ampersandacademy/"
                  target="_blank"
                  ><i class="fab fa-linkedin fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a
                  href="https://www.instagram.com/ampersandacad/"
                  target="_blank"
                  ><i class="fab fa-instagram fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a
                  href="https://whatsapp.com/channel/0029Va9uvHh4Ui2ZTI70bH2w"
                  target="_blank"
                  ><i class="fab fa-whatsapp fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a href="https://t.me/ampersandacad" target="_blank"
                  ><i class="fab fa-telegram fa-fw"></i
                ></a>
              </li>
            </ul>
            <!--//social-list-->
          </div>
          <!--//docs-top-utilities-->
        </div>
        <!--//container-->
      </div>
      <!--//branding-->
    </header>
    <!--//header-->
    <div class="docs-wrapper">
      <div id="docs-sidebar" class="docs-sidebar">
        <div class="top-search-box d-lg-none p-3">
          <form class="search-form">
            <input
              type="text"
              placeholder="Search the docs..."
              name="search"
              class="form-control search-input"
            />
            <button type="submit" class="btn search-btn" value="Search">
              <i class="fas fa-search"></i>
            </button>
          </form>
        </div>
        <nav id="docs-nav" class="docs-nav navbar">
          <ul class="section-items list-unstyled nav flex-column pb-3">
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-1"
                ><span class="theme-icon-holder me-2"
                  ><i class="fas fa-info-circle"></i></span
                >Introduction</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-1-1"
                >What is React?</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-1-2"
                >React vs Other Frameworks</a
              >
            </li>
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-2"
                ><span class="theme-icon-holder me-2"
                  ><i class="fas fa-rocket"></i></span
                >Get Started</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-2-1">Development Environment</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-2-2">Creating a Vite Project</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-2-3">Project Structure</a>
            </li>
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-3"
                ><span class="theme-icon-holder me-2"
                  ><i class="fas fa-code"></i></span
                >Render HTML</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-3-1">Rendering Elements</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-3-2">React DOM</a>
            </li>
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-4"
                ><span class="theme-icon-holder me-2"
                  ><i class="fas fa-file-code"></i></span
                >JSX & TSX</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-4-1">Introduction to JSX/TSX</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-4-2">JSX vs TSX Syntax</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-4-3">Expressions in TSX</a>
            </li>
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-5"
                ><span class="theme-icon-holder me-2"
                  ><i class="fas fa-puzzle-piece"></i></span
                >Components</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-5-1">Functional Components</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-5-2">Component File Structure</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-5-3">Passing Data Between Components</a>
            </li>
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-6"
                ><span class="theme-icon-holder me-2"
                  ><i class="fas fa-cubes"></i></span
                >Class Components</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-6-1">Creating Class Components</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-6-2">Lifecycle Methods</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-6-3">Class vs Function Components</a>
            </li>
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-7"
                ><span class="theme-icon-holder me-2"
                  ><i class="fas fa-exchange-alt"></i></span
                >Props</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-7-1">Understanding Props</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-7-2">PropTypes and TypeScript</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-7-3">Default Props</a>
            </li>
            <li class="nav-item section-title mt-3">
              <a class="nav-link scrollto" href="#section-8"
                ><span class="theme-icon-holder me-2"
                  ><i class="fas fa-bolt"></i></span
                >Events</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-8-1">Handling Events</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-8-2">Event Types in TypeScript</a>
            </li>
            <li class="nav-item">
              <a class="nav-link scrollto" href="#item-8-3">Passing Arguments</a>
            </li>
          </ul>
        </nav>
        <!--//docs-nav-->
      </div>
      <!--//docs-sidebar-->
      <div class="docs-content">
        <div class="container">
          <article class="docs-article" id="section-1">
            <header class="docs-header">
              <h1 class="docs-heading">Introduction to React</h1>
              <section class="docs-intro">
                <p>
                  React is a popular JavaScript library for building user interfaces, particularly single-page applications. It's used for handling the view layer in web and mobile applications. React allows developers to create reusable UI components and efficiently update and render components when data changes.
                </p>
              </section>
              <!--//docs-intro-->
            </header>
            <section class="docs-section" id="item-1-1">
              <h2 class="section-heading">What is React?</h2>
              <p>
                React is a JavaScript library created by Facebook (now Meta) in 2013. It is designed for building fast and interactive user interfaces for web and mobile applications. React follows a component-based architecture which encourages the creation of reusable UI components that present data that changes over time.
              </p>

              <h4>Key Features</h4>
              <ul>
                <li>
                  <strong>Component-Based Architecture</strong>: Build encapsulated components that manage their own state, then compose them to make complex UIs
                </li>
                <li>
                  <strong>Declarative Paradigm</strong>: Design simple views for each state in your application, and React will efficiently update and render the right components when your data changes
                </li>
                <li>
                  <strong>Virtual DOM</strong>: React creates a lightweight representation of the real DOM in memory (Virtual DOM) which improves performance by reducing direct manipulation of the DOM
                </li>
                <li>
                  <strong>JSX/TSX</strong>: A syntax extension that allows you to write HTML-like code in your JavaScript/TypeScript files
                </li>
                <li>
                  <strong>Unidirectional Data Flow</strong>: Data flows down from parent components to child components, making the code more predictable and easier to debug
                </li>
              </ul>

              <div class="callout-block callout-block-info">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-info-circle"></i> </span
                    ><!--//icon-holder-->
                    React Core Philosophy
                  </h4>
                  <p>
                    React follows the philosophy of "Learn Once, Write Anywhere." You can develop new features in React without rewriting existing code, and React can also render on the server using Node.js and power mobile apps using React Native.
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>

            <section class="docs-section" id="item-1-2">
              <h2 class="section-heading">React vs Other Frameworks</h2>
              <p>
                While React focuses on the UI layer, other frameworks like Angular and Vue.js provide more comprehensive solutions. Let's compare React with other popular frameworks:
              </p>

              <div class="table-responsive">
                <table class="table table-striped">
                  <thead>
                    <tr>
                      <th>Feature</th>
                      <th>React</th>
                      <th>Angular</th>
                      <th>Vue.js</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Type</td>
                      <td>Library</td>
                      <td>Full-fledged Framework</td>
                      <td>Progressive Framework</td>
                    </tr>
                    <tr>
                      <td>Learning Curve</td>
                      <td>Moderate</td>
                      <td>Steep</td>
                      <td>Gentle</td>
                    </tr>
                    <tr>
                      <td>Size</td>
                      <td>Small (~42KB)</td>
                      <td>Large (~500KB)</td>
                      <td>Small (~33KB)</td>
                    </tr>
                    <tr>
                      <td>Data Binding</td>
                      <td>One-way</td>
                      <td>Two-way</td>
                      <td>Two-way</td>
                    </tr>
                    <tr>
                      <td>TypeScript Support</td>
                      <td>Good (optional)</td>
                      <td>Excellent (built-in)</td>
                      <td>Good (optional)</td>
                    </tr>
                    <tr>
                      <td>DOM</td>
                      <td>Virtual DOM</td>
                      <td>Real DOM</td>
                      <td>Virtual DOM</td>
                    </tr>
                    <tr>
                      <td>Rendering</td>
                      <td>Client & Server-side</td>
                      <td>Client-side</td>
                      <td>Client & Server-side</td>
                    </tr>
                  </tbody>
                </table>
              </div>

              <h4>Why Choose React?</h4>
              <ul>
                <li><strong>Flexibility</strong>: React can be used with various other libraries and frameworks</li>
                <li><strong>Strong Community</strong>: Large community and ecosystem with plenty of third-party libraries</li>
                <li><strong>Developer Experience</strong>: Good developer tools and debugging capabilities</li>
                <li><strong>Performance</strong>: Virtual DOM provides efficient DOM manipulation</li>
                <li><strong>Corporate Backing</strong>: Maintained by Facebook/Meta with regular updates</li>
                <li><strong>TypeScript Integration</strong>: Excellent TypeScript support for type safety</li>
              </ul>

              <div class="callout-block callout-block-warning">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-exclamation-triangle"></i> </span
                    ><!--//icon-holder-->
                    React is Just the UI
                  </h4>
                  <p>
                    Remember that React is primarily a UI library, not a complete framework. For routing, state management, and API calls, you'll need additional libraries like React Router, Redux or Context API, and Axios/Fetch. However, this modular approach allows you to pick the best tools for your specific needs.
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>
          </article>

          <article class="docs-article" id="section-2">
            <header class="docs-header">
              <h1 class="docs-heading">Get Started</h1>
              <section class="docs-intro">
                <p>
                  Setting up a React project with TypeScript is straightforward with modern build tools. We'll use Vite, a next-generation build tool that provides a faster and leaner development experience.
                </p>
              </section>
              <!--//docs-intro-->
            </header>
            <section class="docs-section" id="item-2-1">
              <h2 class="section-heading">Development Environment</h2>
              <p>
                Before starting with React development, make sure you have the following prerequisites installed:
              </p>

              <ul>
                <li><strong>Node.js and npm</strong>: React development requires Node.js version 14.0 or higher</li>
                <li><strong>Code Editor</strong>: Visual Studio Code is recommended for its excellent TypeScript and React support</li>
                <li><strong>Browser</strong>: Chrome, Firefox, or Edge with React DevTools extension installed</li>
              </ul>

              <h4>Recommended VS Code Extensions</h4>
              <ul>
                <li><strong>ES7+ React/Redux/React-Native snippets</strong>: Provides React code snippets</li>
                <li><strong>ESLint</strong>: Integrates ESLint into VS Code for linting</li>
                <li><strong>Prettier</strong>: Code formatter to maintain consistent coding style</li>
                <li><strong>TypeScript React code snippets</strong>: TypeScript snippets for React development</li>
                <li><strong>vscode-styled-components</strong>: Syntax highlighting for styled-components</li>
              </ul>

              <div class="callout-block callout-block-info">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-info-circle"></i> </span
                    ><!--//icon-holder-->
                    Node Version Manager
                  </h4>
                  <p>
                    Consider using NVM (Node Version Manager) to easily switch between Node.js versions, which is helpful when working on different projects with different Node.js requirements.
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>

            <section class="docs-section" id="item-2-2">
              <h2 class="section-heading">Creating a Vite Project</h2>
              <p>
                Vite (French for "quick") is a modern build tool that offers a faster and simpler development experience. It leverages native ES modules to provide instantaneous server start and fast HMR (Hot Module Replacement).
              </p>

              <h4>Why Vite?</h4>
              <ul>
                <li><strong>Faster Development</strong>: Instant server start and lightning-fast HMR</li>
                <li><strong>Optimized Build</strong>: Built-in optimizations for production</li>
                <li><strong>TypeScript Support</strong>: Native support for TypeScript</li>
                <li><strong>CSS Support</strong>: Support for CSS preprocessors like Sass</li>
                <li><strong>Plugin-based</strong>: Extensible with a growing plugin ecosystem</li>
              </ul>

              <h4>Creating a React TypeScript Project with Vite</h4>
              <p>Run the following command in your terminal:</p>
              <pre><code class="language-bash">npm create vite@latest my-react-app -- --template react-ts</code></pre>

              <p>This command creates a new React project with TypeScript template. Follow these steps to get started:</p>

              <pre><code class="language-bash"># Navigate to your project directory
cd my-react-app

# Install dependencies
npm install

# Start the development server
npm run dev</code></pre>

              <p>After running these commands, your React app will be available at <code>http://localhost:5173/</code> by default.</p>

              <div class="callout-block callout-block-success">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-thumbs-up"></i> </span
                    ><!--//icon-holder-->
                    Vite vs Create React App
                  </h4>
                  <p>
                    While Create React App (CRA) has been the standard tool for React development, Vite offers significant improvements in development experience and build times. Vite uses native ES modules during development, which allows it to start the dev server instantly regardless of app size.
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>

            <section class="docs-section" id="item-2-3">
              <h2 class="section-heading">Project Structure</h2>
              <p>
                After creating a project with Vite and React-TypeScript template, you'll see a folder structure similar to this:
              </p>

              <pre><code class="language-text">my-react-app/
├── node_modules/
├── public/
│   └── vite.svg
├── src/
│   ├── assets/
│   │   └── react.svg
│   ├── App.css
│   ├── App.tsx
│   ├── index.css
│   ├── main.tsx
│   └── vite-env.d.ts
├── .gitignore
├── index.html
├── package.json
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts</code></pre>

              <h4>Key Files and Directories</h4>
              <ul>
                <li>
                  <strong>index.html</strong>: The main HTML file that serves as the entry point for your app
                </li>
                <li>
                  <strong>src/</strong>: Contains your React application source code
                  <ul>
                    <li><strong>main.tsx</strong>: The entry point of your React application</li>
                    <li><strong>App.tsx</strong>: The main App component</li>
                    <li><strong>assets/</strong>: Contains static assets like images and fonts</li>
                  </ul>
                </li>
                <li>
                  <strong>public/</strong>: Contains static files that will be served directly without being processed
                </li>
                <li>
                  <strong>package.json</strong>: Lists dependencies and contains scripts for your project
                </li>
                <li>
                  <strong>tsconfig.json</strong>: TypeScript configuration
                </li>
                <li>
                  <strong>vite.config.ts</strong>: Vite-specific configuration
                </li>
              </ul>

              <h4>Let's Look at the Key Files</h4>

              <p><strong>index.html:</strong></p>
              <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;link rel="icon" type="image/svg+xml" href="/vite.svg" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;React + TypeScript + Vite&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
    &lt;script type="module" src="/src/main.tsx"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

              <p><strong>src/main.tsx:</strong></p>
              <pre><code class="language-typescript">import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
)</code></pre>

              <p><strong>src/App.tsx:</strong></p>
              <pre><code class="language-typescript">import { useState } from 'react'
import reactLogo from './assets/react.svg'
import viteLogo from '/vite.svg'
import './App.css'

function App() {
  const [count, setCount] = useState(0)

  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;a href="https://vitejs.dev" target="_blank"&gt;
          &lt;img src={viteLogo} className="logo" alt="Vite logo" /&gt;
        &lt;/a&gt;
        &lt;a href="https://react.dev" target="_blank"&gt;
          &lt;img src={reactLogo} className="logo react" alt="React logo" /&gt;
        &lt;/a&gt;
      &lt;/div&gt;
      &lt;h1&gt;Vite + React&lt;/h1&gt;
      &lt;div className="card"&gt;
        &lt;button onClick={() =&gt; setCount((count) =&gt; count + 1)}&gt;
          count is {count}
        &lt;/button&gt;
        &lt;p&gt;
          Edit &lt;code&gt;src/App.tsx&lt;/code&gt; and save to test HMR
        &lt;/p&gt;
      &lt;/div&gt;
      &lt;p className="read-the-docs"&gt;
        Click on the Vite and React logos to learn more
      &lt;/p&gt;
    &lt;/&gt;
  )
}

export default App</code></pre>

              <div class="callout-block callout-block-warning">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-exclamation-triangle"></i> </span
                    ><!--//icon-holder-->
                    Understanding the Entry Points
                  </h4>
                  <p>
                    In a Vite React project, the flow starts from <code>index.html</code>, which includes a script tag pointing to <code>src/main.tsx</code>. The <code>main.tsx</code> file renders the root React component (<code>App.tsx</code>) to the DOM element with id "root". Understanding this flow is crucial for troubleshooting and configuration.
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>
          </article>

          <article class="docs-article" id="section-3">
            <header class="docs-header">
              <h1 class="docs-heading">Render HTML</h1>
              <section class="docs-intro">
                <p>
                  React works by rendering components to the DOM. Understanding how React elements are created and rendered is fundamental to working with React.
                </p>
              </section>
              <!--//docs-intro-->
            </header>
            <section class="docs-section" id="item-3-1">
              <h2 class="section-heading">Rendering Elements</h2>
              <p>
                React elements are the smallest building blocks of React applications. An element describes what you want to see on the screen.
              </p>

              <p>Unlike browser DOM elements, React elements are plain objects and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p>

              <h4>Creating React Elements</h4>
              <p>React elements can be created using JSX/TSX or with <code>React.createElement()</code>:</p>

              <p><strong>Using JSX/TSX (Preferred Method):</strong></p>
              <pre><code class="language-typescript">// Using JSX/TSX
const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</code></pre>

              <p><strong>Using React.createElement() (Less Common):</strong></p>
              <pre><code class="language-typescript">// Using React.createElement()
                const element = React.createElement(
                  'h1',
                  null,
                  'Hello, world!'
                );</code></pre>
                
                              <h4>Rendering Elements to the DOM</h4>
                              <p>To render a React element to the DOM, you need a "root" DOM node. Everything inside it will be managed by React DOM:</p>
                
                              <pre><code class="language-html">&lt;!-- HTML file --&gt;
                &lt;div id="root"&gt;&lt;/div&gt;</code></pre>
                
                              <pre><code class="language-typescript">// TypeScript file
                import React from 'react';
                import ReactDOM from 'react-dom/client';
                
                const root = ReactDOM.createRoot(
                  document.getElementById('root') as HTMLElement
                );
                
                const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
                root.render(element);</code></pre>
                
                              <p>In this example, we're telling React to render the <code>&lt;h1&gt;</code> element into the DOM element with ID "root".</p>
                
                              <h4>Updating Rendered Elements</h4>
                              <p>React elements are immutable. Once you create an element, you can't change its children or attributes. To update the UI, you create a new element and pass it to <code>ReactDOM.render()</code>:</p>
                
                              <pre><code class="language-typescript">function tick() {
                  const element = (
                    &lt;div&gt;
                      &lt;h1&gt;Hello, world!&lt;/h1&gt;
                      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
                    &lt;/div&gt;
                  );
                  root.render(element);
                }
                
                // Update the UI every second
                setInterval(tick, 1000);</code></pre>
                
                              <div class="callout-block callout-block-info">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-info-circle"></i> </span
                                    ><!--//icon-holder-->
                                    React Only Updates What's Necessary
                                  </h4>
                                  <p>
                                    React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state. Even though we create a new element describing the whole UI tree on every tick, only the text node whose contents have changed gets updated by React DOM.
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
                            </section>
                
                            <section class="docs-section" id="item-3-2">
                              <h2 class="section-heading">React DOM</h2>
                              <p>
                                React DOM is the package that serves as the entry point to the DOM and server renderers for React. It's responsible for rendering React components to the DOM.
                              </p>
                
                              <h4>Key React DOM APIs</h4>
                              <ul>
                                <li>
                                  <strong>createRoot()</strong>: Creates a React root for the supplied container and returns a root object for rendering or unmounting
                                </li>
                                <li>
                                  <strong>hydrateRoot()</strong>: Same as createRoot(), but is used for containers whose HTML contents were rendered by ReactDOMServer
                                </li>
                              </ul>
                
                              <h4>Creating a Root</h4>
                              <p>In React 18 and later, we use <code>createRoot</code> to create a root for React to render into:</p>
                
                              <pre><code class="language-typescript">import { createRoot } from 'react-dom/client';
                
                // Create a root
                const root = createRoot(document.getElementById('root') as HTMLElement);
                
                // Initial render
                root.render(&lt;App /&gt;);
                
                // To unmount the application
                // root.unmount();</code></pre>
                
                              <h4>Strict Mode</h4>
                              <p>React provides a <code>StrictMode</code> component that helps you identify potential problems in your application:</p>
                
                              <pre><code class="language-typescript">import React from 'react';
                import { createRoot } from 'react-dom/client';
                import App from './App';
                
                const root = createRoot(document.getElementById('root') as HTMLElement);
                root.render(
                  &lt;React.StrictMode&gt;
                    &lt;App /&gt;
                  &lt;/React.StrictMode&gt;
                );</code></pre>
                
                              <p>StrictMode enables additional checks and warnings for its descendants, including:</p>
                              <ul>
                                <li>Identifying components with unsafe lifecycles</li>
                                <li>Warning about legacy string ref API usage</li>
                                <li>Detecting unexpected side effects</li>
                                <li>Detecting legacy context API</li>
                                <li>Ensuring reusable state</li>
                              </ul>
                
                              <div class="callout-block callout-block-warning">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-exclamation-triangle"></i> </span
                                    ><!--//icon-holder-->
                                    StrictMode in Development
                                  </h4>
                                  <p>
                                    StrictMode renders components twice in development mode to help detect side effects. This is intentional and helps find bugs, but it doesn't happen in production. You might notice components being mounted, unmounted, and remounted when using StrictMode.
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
                            </section>
                          </article>
                
                          <article class="docs-article" id="section-4">
                            <header class="docs-header">
                              <h1 class="docs-heading">JSX & TSX</h1>
                              <section class="docs-intro">
                                <p>
                                  JSX (JavaScript XML) and TSX (TypeScript XML) are syntax extensions that allow you to write HTML-like code in your JavaScript/TypeScript files. They make React code more readable and expressive.
                                </p>
                              </section>
                              <!--//docs-intro-->
                            </header>
                            <section class="docs-section" id="item-4-1">
                              <h2 class="section-heading">Introduction to JSX/TSX</h2>
                              <p>
                                JSX and TSX are syntax extensions for JavaScript and TypeScript respectively. They allow you to describe what the UI should look like using syntax that resembles HTML. TSX combines JSX syntax with TypeScript's type-checking capabilities.
                              </p>
                
                              <h4>Benefits of JSX/TSX</h4>
                              <ul>
                                <li><strong>Familiarity</strong>: Familiar syntax for defining UI elements</li>
                                <li><strong>Visual Clarity</strong>: Makes the structure of the UI more visible and easier to understand</li>
                                <li><strong>Type Safety (TSX)</strong>: TypeScript provides compile-time type checking to catch errors early</li>
                                <li><strong>IntelliSense</strong>: Better autocomplete and documentation in code editors</li>
                                <li><strong>Component Composition</strong>: Makes component composition more intuitive</li>
                              </ul>
                
                              <h4>How It Works</h4>
                              <p>Under the hood, JSX/TSX is transformed into regular JavaScript function calls. For example:</p>
                
                              <pre><code class="language-typescript">// TSX code
                const element = &lt;h1 className="greeting"&gt;Hello, world!&lt;/h1&gt;;
                
                // Compiled JavaScript (after transformation)
                const element = React.createElement(
                  'h1',
                  { className: 'greeting' },
                  'Hello, world!'
                );</code></pre>
                
                              <p>This transformation is handled by tools like Babel or TypeScript compiler.</p>
                
                              <div class="callout-block callout-block-info">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-info-circle"></i> </span
                                    ><!--//icon-holder-->
                                    React Must Be in Scope
                                  </h4>
                                  <p>
                                    Since JSX/TSX compiles to <code>React.createElement</code> calls, <code>React</code> must be in scope whenever you use JSX. You need to import React even if you don't directly use it in your code.
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
                            </section>
                
                            <section class="docs-section" id="item-4-2">
                              <h2 class="section-heading">JSX vs TSX Syntax</h2>
                              <p>
                                TSX extends JSX with TypeScript's type system, allowing you to define props types, state types, and more. Let's compare JSX and TSX syntax:
                              </p>
                
                              <h4>JSX Example (JavaScript)</h4>
                              <pre><code class="language-jsx">import React from 'react';
                
                function Greeting(props) {
                  return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
                }
                
                export default Greeting;</code></pre>
                
                              <h4>TSX Example (TypeScript)</h4>
                              <pre><code class="language-typescript">import React from 'react';
                
                interface GreetingProps {
                  name: string;
                  age?: number; // Optional prop
                }
                
                function Greeting(props: GreetingProps) {
                  return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
                }
                
                export default Greeting;</code></pre>
                
                              <p>The key difference is TypeScript's ability to define types for props, state, and other variables. This provides better type checking and developer experience.</p>
                
                              <h4>TSX Syntax Rules</h4>
                              <ul>
                                <li><strong>Self-closing Tags</strong>: Elements with no children must be self-closed with <code>/&gt;</code></li>
                                <li><strong>Case Sensitivity</strong>: HTML tags use lowercase, while React components start with an uppercase letter</li>
                                <li><strong>HTML Attributes</strong>: Most HTML attributes use camelCase in React (e.g., <code>className</code> instead of <code>class</code>)</li>
                                <li><strong>JavaScript Expressions</strong>: Use curly braces <code>{}</code> to embed JavaScript expressions</li>
                                <li><strong>Comments</strong>: Use <code>{/* comment */}</code> for comments within JSX</li>
                              </ul>
                
                              <pre><code class="language-tsx">// Example demonstrating TSX syntax rules
                function Profile() {
                  const username = "john_doe";
                  
                  return (
                    &lt;div className="profile-card"&gt;
                      {/* User profile information */}
                      &lt;img src="/images/avatar.png" alt="Profile" /&gt;
                      &lt;h2&gt;{username.toUpperCase()}&lt;/h2&gt;
                      &lt;UserStats userId={42} /&gt;
                    &lt;/div&gt;
                  );
                }</code></pre>
                
                              <div class="callout-block callout-block-warning">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-exclamation-triangle"></i> </span
                                    ><!--//icon-holder-->
                                    JSX Gotchas
                                  </h4>
                                  <p>
                                    Some HTML attributes are renamed in JSX to avoid conflicts with JavaScript reserved words:
                                    <ul>
                                      <li><code>class</code> → <code>className</code></li>
                                      <li><code>for</code> → <code>htmlFor</code></li>
                                      <li><code>tabindex</code> → <code>tabIndex</code></li>
                                    </ul>
                                    Also, inline styles use objects with camelCase properties instead of CSS strings: <code>style={{ backgroundColor: 'red' }}</code>
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
                            </section>
                
                            <section class="docs-section" id="item-4-3">
                              <h2 class="section-heading">Expressions in TSX</h2>
                              <p>
                                You can embed any JavaScript expression in TSX by wrapping it with curly braces <code>{}</code>. This allows you to incorporate dynamic content into your UI.
                              </p>
                
                              <h4>Basic Expressions</h4>
                              <pre><code class="language-tsx">function Greeting() {
                  const name = "John";
                  const age = 25;
                  
                  return (
                    &lt;div&gt;
                      &lt;h1&gt;Hello, {name}!&lt;/h1&gt;
                      &lt;p&gt;You are {age} years old.&lt;/p&gt;
                      &lt;p&gt;Next year, you will be {age + 1}.&lt;/p&gt;
                      &lt;p&gt;Your birth year is {new Date().getFullYear() - age}.&lt;/p&gt;
                    &lt;/div&gt;
                  );
                }</code></pre>
                
                              <h4>Conditional Rendering with Expressions</h4>
                              <p>You can use expressions for conditional rendering:</p>
                
                              <pre><code class="language-tsx">function UserGreeting(props: { isLoggedIn: boolean; username?: string }) {
                  return (
                    &lt;div&gt;
                      {/* Ternary operator */}
                      &lt;h1&gt;{props.isLoggedIn ? `Welcome back, ${props.username}!` : 'Welcome, Guest!'}&lt;/h1&gt;
                      
                      {/* Logical && operator */}
                      {props.isLoggedIn && &lt;p&gt;Your account details&lt;/p&gt;}
                      
                      {/* Immediately-invoked function expression (IIFE) */}
                      {(() => {
                        if (props.isLoggedIn) {
                          return &lt;button&gt;Logout&lt;/button&gt;;
                        } else {
                          return &lt;button&gt;Login&lt;/button&gt;;
                        }
                      })()}
                    &lt;/div&gt;
                  );
                }</code></pre>
                
                              <h4>Rendering Lists with Expressions</h4>
                              <p>Use expressions to render lists of elements:</p>
                
                              <pre><code class="language-tsx">function TodoList() {
                  const todos: string[] = ['Learn React', 'Learn TypeScript', 'Build something awesome'];
                  
                  return (
                    &lt;ul&gt;
                      {todos.map((todo, index) => (
                        &lt;li key={index}&gt;{todo}&lt;/li&gt;
                      ))}
                    &lt;/ul&gt;
                  );
                }</code></pre>
                
                              <h4>JSX as Expressions</h4>
                              <p>JSX elements themselves are expressions and can be used wherever expressions are valid:</p>
                
                              <pre><code class="language-tsx">function Message(props: { isError: boolean; children: React.ReactNode }) {
                  // Assigning JSX to variables
                  const errorStyle = { color: 'red', fontWeight: 'bold' };
                  const regularStyle = { color: 'black' };
                  
                  // Returning different JSX based on a condition
                  return (
                    &lt;div style={props.isError ? errorStyle : regularStyle}&gt;
                      {props.children}
                    &lt;/div&gt;
                  );
                }
                
                function App() {
                  // Using JSX in variable assignments
                  const successMessage = &lt;Message isError={false}&gt;Operation successful!&lt;/Message&gt;;
                  const errorMessage = &lt;Message isError={true}&gt;Something went wrong!&lt;/Message&gt;;
                  
                  const isError = false;
                  
                  return (
                    &lt;div&gt;
                      {isError ? errorMessage : successMessage}
                    &lt;/div&gt;
                  );
                }</code></pre>
                
                              <div class="callout-block callout-block-danger">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-exclamation-circle"></i> </span
                                    ><!--//icon-holder-->
                                    Expression Limitations
                                  </h4>
                                  <p>
                                    Not everything can be used inside JSX expressions:
                                    <ul>
                                      <li>Statements like <code>if</code>, <code>for</code>, or <code>switch</code> aren't expressions and can't be used directly</li>
                                      <li>Variable declarations (<code>let</code>, <code>const</code>) aren't allowed</li>
                                      <li>You can't use <code>break</code>, <code>continue</code>, or <code>return</code> inside JSX expressions</li>
                                    </ul>
                                    Use conditional operators, IIFEs, or extract logic to helper functions for complex operations.
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
                            </section>
                          </article>
                
                          <article class="docs-article" id="section-5">
                            <header class="docs-header">
                              <h1 class="docs-heading">Components</h1>
                              <section class="docs-intro">
                                <p>
                                  Components are the building blocks of React applications. They let you split the UI into independent, reusable pieces, and think about each piece in isolation.
                                </p>
                              </section>
                              <!--//docs-intro-->
                            </header>
                            <section class="docs-section" id="item-5-1">
                              <h2 class="section-heading">Functional Components</h2>
                              <p>
                                Functional components are the modern, preferred way to write React components. They are JavaScript/TypeScript functions that return React elements.
                              </p>
                
                              <h4>Basic Functional Component</h4>
                              <pre><code class="language-typescript">import React from 'react';
                
                // Basic functional component
                function Welcome() {
                  return &lt;h1&gt;Hello, World!&lt;/h1&gt;;
                }
                
                export default Welcome;</code></pre>
                
                              <h4>Functional Component with Props</h4>
                              <pre><code class="language-typescript">import React from 'react';
                
                // Define the props interface
                interface WelcomeProps {
                  name: string;
                  greeting?: string; // Optional prop
                }
                
                // Functional component with typed props
                function Welcome(props: WelcomeProps) {
                  return &lt;h1&gt;{props.greeting || 'Hello'}, {props.name}!&lt;/h1&gt;;
                }
                
                export default Welcome;</code></pre>
                
                              <h4>Alternate Syntax: Arrow Functions</h4>
                              <pre><code class="language-typescript">import React from 'react';
                
                interface WelcomeProps {
                  name: string;
                  greeting?: string;
                }
                
                // Using arrow function syntax
                const Welcome: React.FC&lt;WelcomeProps&gt; = (props) => {
                  return &lt;h1&gt;{props.greeting || 'Hello'}, {props.name}!&lt;/h1&gt;;
                };
                
                // Using destructuring in the parameter list
                const WelcomeWithDestructuring: React.FC&lt;WelcomeProps&gt; = ({ name, greeting = 'Hello' }) => {
                  return &lt;h1&gt;{greeting}, {name}!&lt;/h1&gt;;
                };
                
                export default Welcome;</code></pre>
                
                              <div class="callout-block callout-block-info">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-info-circle"></i> </span
                                    ><!--//icon-holder-->
                                    React.FC vs Function Declaration
                                  </h4>
                                  <p>
                                    <code>React.FC</code> (or <code>React.FunctionComponent</code>) is a TypeScript type for functional components. Using <code>React.FC</code> provides implicit type definition for <code>children</code> props, but some developers prefer direct function declarations as they allow for more explicit return types and don't include the implicit children prop when not needed.
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
                            </section>
                
                            <section class="docs-section" id="item-5-2">
                              <h2 class="section-heading">Component File Structure</h2>
                              <p>
                                Organizing your React components properly helps maintain a clean and scalable codebase. Here are some common approaches to structuring React components:
                              </p>
                
                              <h4>Component File Organization</h4>
                              <p>A typical React component file structure might look like this:</p>
                
                              <pre><code class="language-text">src/
                ├── components/
                │   ├── common/
                │   │   ├── Button/
                │   │   │   ├── Button.tsx
                │   │   │   ├── Button.module.css
                │   │   │   └── index.ts
                │   │   ├── Input/
                │   │   └── ...
                │   ├── layout/
                │   │   ├── Header/
                │   │   ├── Footer/
                │   │   └── ...
                │   └── features/
                │       ├── UserProfile/
                │       ├── Dashboard/
                │       └── ...
                ├── hooks/
                ├── utils/
                ├── services/
                ├── types/
                ├── App.tsx
                └── main.tsx</code></pre>
                
                              <h4>Component File Examples</h4>
                              <p><strong>Button.tsx:</strong></p>
                              <pre><code class="language-typescript">import React from 'react';
                import styles from './Button.module.css';
                
                export interface ButtonProps {
                  variant?: 'primary' | 'secondary' | 'danger';
                  size?: 'small' | 'medium' | 'large';
                  label: string;
                  onClick?: () => void;
                  disabled?: boolean;
                }
                
                const Button: React.FC&lt;ButtonProps&gt; = ({
                  variant = 'primary',
                  size = 'medium',
                  label,
                  onClick,
                  disabled = false
                }) => {
                  return (
                    &lt;button
                      className={`${styles.button} ${styles[variant]} ${styles[size]}`}
                      onClick={onClick}
                      disabled={disabled}
                    &gt;
                      {label}
                    &lt;/button&gt;
                  );
                };
                
                export default Button;</code></pre>
                
                              <p><strong>index.ts (Re-export):</strong></p>
                              <pre><code class="language-typescript">export { default } from './Button';
                export type { ButtonProps } from './Button';</code></pre>
                
                              <h4>Component Organization Patterns</h4>
                              <ul>
                                <li>
                                  <strong>Feature-based Organization</strong>: Group components by feature or domain (e.g., UserProfile, Dashboard)
                                </li>
                                <li>
                                  <strong>Type-based Organization</strong>: Group components by their type (e.g., containers, components, pages)
                                </li>
                                <li>
                                  <strong>Atomic Design</strong>: Organize components as atoms, molecules, organisms, templates, and pages
                                </li>
                              </ul>
                
                              <div class="callout-block callout-block-success">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-thumbs-up"></i> </span
                                    ><!--//icon-holder-->
                                    Best Practices
                                  </h4>
                                  <p>
                                    <ul>
                                      <li>Keep components small and focused on a single responsibility</li>
                                      <li>Use clear, descriptive names for your components</li>
                                      <li>Co-locate related files (component, styles, tests)</li>
                                      <li>Use index files to simplify imports</li>
                                      <li>Define proper TypeScript interfaces for props and state</li>
                                      <li>Document complex components with comments or JSDoc</li>
                                    </ul>
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
                            </section>
                
                            <section class="docs-section" id="item-5-3">
                              <h2 class="section-heading">Passing Data Between Components</h2>
                              <p>
                                React components can communicate and share data in several ways. Props are the most common way to pass data from parent to child components.
                              </p>
                
                              <h4>Props: Parent to Child Communication</h4>
                              <pre><code class="language-typescript">// Parent component
                import React from 'react';
                import UserProfile from './UserProfile';
                
                const App: React.FC = () => {
                  const user = {
                    id: 1,
                    name: 'John Doe',
                    email: 'john@example.com',
                    isAdmin: true
                  };
                
                  return (
                    &lt;div&gt;
                      &lt;h1&gt;User Management&lt;/h1&gt;
                      &lt;UserProfile 
                        user={user} 
                        onUpdateUser={(updatedUser) => console.log('User updated:', updatedUser)} 
                      /&gt;
                    &lt;/div&gt;
                  );
                };
                
                // Child component
                interface User {
                  id: number;
                  name: string;
                  email: string;
                  isAdmin: boolean;
                }
                
                interface UserProfileProps {
                  user: User;
                  onUpdateUser: (user: User) => void;
                }
                
                const UserProfile: React.FC&lt;UserProfileProps&gt; = ({ user, onUpdateUser }) => {
                  return (
                    &lt;div&gt;
                      &lt;h2&gt;{user.name}'s Profile&lt;/h2&gt;
                      &lt;p&gt;Email: {user.email}&lt;/p&gt;
                      &lt;p&gt;Role: {user.isAdmin ? 'Administrator' : 'User'}&lt;/p&gt;
                      &lt;button onClick={() => onUpdateUser({ ...user, name: user.name + ' (Updated)' })}&gt;
                        Update Name
                      &lt;/button&gt;
                    &lt;/div&gt;
                  );
                };</code></pre>
                
                              <h4>Children Props</h4>
                              <p>The <code>children</code> prop allows you to pass components as data, creating wrapper or container components:</p>
                
                              <pre><code class="language-typescript">// Container component
                interface CardProps {
                  title: string;
                  children: React.ReactNode;
                }
                
                const Card: React.FC&lt;CardProps&gt; = ({ title, children }) => {
                  return (
                    &lt;div className="card"&gt;
                      &lt;div className="card-header"&gt;
                        &lt;h3&gt;{title}&lt;/h3&gt;
                      &lt;/div&gt;
                      &lt;div className="card-body"&gt;
                        {children}
                      &lt;/div&gt;
                    &lt;/div&gt;
                  );
                };
                
                // Usage
                function App() {
                  return (
                    &lt;Card title="Welcome"&gt;
                      &lt;p&gt;This is the card content.&lt;/p&gt;
                      &lt;button&gt;Click me&lt;/button&gt;
                    &lt;/Card&gt;
                  );
                }</code></pre>
                
                              <h4>Prop Drilling and Solutions</h4>
                              <p>Prop drilling occurs when props need to be passed through multiple levels of components. For complex applications, consider these alternatives:</p>
                
                              <ul>
                                <li><strong>Context API</strong>: For sharing data across many components without prop drilling</li>
                                <li><strong>State Management Libraries</strong>: Redux, Zustand, or Jotai for more complex state management</li>
                                <li><strong>Composition</strong>: Restructuring components to minimize the need for deep prop passing</li>
                              </ul>
                
                              <div class="callout-block callout-block-warning">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-exclamation-triangle"></i> </span
                                    ><!--//icon-holder-->
                                    Props are Read-Only
                                  </h4>
                                  <p>
                                    A component must never modify its props directly. React components must act like pure functions with respect to their props, meaning they should not attempt to change their inputs. For mutable state, use <code>useState</code> or other state management solutions.
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
                            </section>
                          </article>
                
                          <article class="docs-article" id="section-6">
                            <header class="docs-header">
                              <h1 class="docs-heading">Class Components</h1>
                              <section class="docs-intro">
                                <p>
                                  Class components are an older way of writing React components. While functional components are now preferred in most cases, understanding class components is still valuable, especially when working with legacy code.
                                </p>
                              </section>
                              <!--//docs-intro-->
                            </header>
                            <section class="docs-section" id="item-6-1">
                              <h2 class="section-heading">Creating Class Components</h2>
                              <p>
                                Class components are JavaScript/TypeScript classes that extend from <code>React.Component</code> and implement a <code>render()</code> method.
                              </p>
                
                              <h4>Basic Class Component</h4>
                              <pre><code class="language-typescript">import React, { Component } from 'react';
                
                // Basic class component
                class Welcome extends Component {
                  render() {
                    return &lt;h1&gt;Hello, World!&lt;/h1&gt;;
                  }
                }
                
                export default Welcome;</code></pre>
                
                              <h4>Class Component with Props</h4>
                              <pre><code class="language-typescript">import React, { Component } from 'react';
                
                // Define props interface
                interface WelcomeProps {
                  name: string;
                  greeting?: string;
                }
                
                // Class component with typed props
                class Welcome extends Component&lt;WelcomeProps&gt; {
                  render() {
                    const { name, greeting = 'Hello' } = this.props;
                    return &lt;h1&gt;{greeting}, {name}!&lt;/h1&gt;;
                  }
                }
                
                export default Welcome;</code></pre>
                
                              <h4>Class Component with State</h4>
                              <pre><code class="language-typescript">import React, { Component } from 'react';
                
                interface CounterProps {
                  initialCount?: number;
                }
                
                interface CounterState {
                  count: number;
                }
                
                class Counter extends Component&lt;CounterProps, CounterState&gt; {
                  // Constructor with state initialization
                  constructor(props: CounterProps) {
                    super(props);
                    // Initialize state
                    this.state = {
                      count: props.initialCount || 0
                    };
                    
                    // Bind methods to this instance
                    this.increment = this.increment.bind(this);
                    this.decrement = this.decrement.bind(this);
                  }
                  
                  // Class methods
                  increment() {
                    this.setState(prevState => ({
                      count: prevState.count + 1
                    }));
                  }
                  
                  decrement() {
                    this.setState(prevState => ({
                      count: prevState.count - 1
                    }));
                  }
                  
                  render() {
                    return (
                      &lt;div&gt;
                        &lt;h2&gt;Count: {this.state.count}&lt;/h2&gt;
                        &lt;button onClick={this.increment}&gt;Increment&lt;/button&gt;
                        &lt;button onClick={this.decrement}&gt;Decrement&lt;/button&gt;
                      &lt;/div&gt;
                    );
                  }
                }
                
                export default Counter;</code></pre>
                
                              <h4>Method Binding in Class Components</h4>
                              <p>There are several ways to handle method binding in class components:</p>
                
                              <pre><code class="language-typescript">class BindingExample extends Component {
                  constructor(props) {
                    super(props);
                    // Method 1: Bind in constructor (traditional approach)
                    this.handleClick1 = this.handleClick1.bind(this);
                  }
                
                  // Method 1: Method that needs binding
                  handleClick1() {
                    console.log('Method 1: This is:', this);
                  }
                  
                  // Method 2: Arrow function class property (modern approach, requires babel plugin)
                  handleClick2 = () => {
                    console.log('Method 2: This is:', this);
                  }
                  
                  render() {
                    return (
                      &lt;div&gt;
                        &lt;button onClick={this.handleClick1}&gt;Method 1&lt;/button&gt;
                        &lt;button onClick={this.handleClick2}&gt;Method 2&lt;/button&gt;
                        {/* Method 3: Inline arrow function (convenient but creates new function on each render) */}
                        &lt;button onClick={() => console.log('Method 3: This is:', this)}&gt;Method 3&lt;/button&gt;
                      &lt;/div&gt;
                    );
                  }
                }</code></pre>
                
                              <div class="callout-block callout-block-info">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-info-circle"></i> </span
                                    ><!--//icon-holder-->
                                    Class Properties Syntax
                                  </h4>
                                  <p>
                                    Using arrow functions as class properties (Method 2 above) is generally the preferred approach in modern class components as it automatically binds the method to the instance and is more concise. This syntax is enabled by TypeScript by default.
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
                            </section>
                
                            <section class="docs-section" id="item-6-2">
                              <h2 class="section-heading">Lifecycle Methods</h2>
                              <p>
                                Class components have lifecycle methods that get called at different stages of a component's existence. These methods let you run code at specific times in the component's lifecycle.
                              </p>
                
                              <h4>Key Lifecycle Methods</h4>
                              <div class="table-responsive">
                                <table class="table">
                                  <thead>
                                    <tr>
                                      <th>Lifecycle Phase</th>
                                      <th>Method</th>
                                      <th>Purpose</th>
                                    </tr>
                                  </thead>
                                  <tbody>
                                    <tr>
                                      <td rowspan="2">Mounting</td>
                                      <td><code>constructor()</code></td>
                                      <td>Initialize state, bind methods</td>
                                    </tr>
                                    <tr>
                                      <td><code>componentDidMount()</code></td>
                                      <td>Run after component is mounted to the DOM; good for API calls, subscriptions</td>
                                    </tr>
                                    <tr>
                                      <td rowspan="3">Updating</td>
                                      <td><code>shouldComponentUpdate()</code></td>
                                      <td>Decide if component should re-render; return false to prevent update</td>
                                    </tr>
                                    <tr>
                                      <td><code>getSnapshotBeforeUpdate()</code></td>
                                      <td>Capture information from DOM before it changes</td>
                                    </tr>
                                    <tr>
                                      <td><code>componentDidUpdate()</code></td>
                                      <td>Run after component updates; good for DOM operations based on prop/state changes</td>
                                    </tr>
                                    <tr>
                                      <td>Unmounting</td>
                                      <td><code>componentWillUnmount()</code></td>
                                      <td>Clean up resources (like timers or subscriptions) before component is removed</td>
                                    </tr>
                                    <tr>
                                      <td>Error Handling</td>
                                      <td><code>componentDidCatch()</code></td>
                                      <td>Catch JavaScript errors in child components</td>
                                    </tr>
                                  </tbody>
                                </table>
                              </div>
                
                              <h4>Lifecycle Methods Example</h4>
                              <pre><code class="language-typescript">import React, { Component } from 'react';
                
                interface TimerProps {
                  initialCount: number;
                }
                
                interface TimerState {
                  count: number;
                }
                
                class Timer extends Component&lt;TimerProps, TimerState&gt; {
                  private timerId?: number;
                
                  constructor(props: TimerProps) {
                    super(props);
                    // Initialize state in constructor
                    this.state = {
                      count: props.initialCount
                    };
                    console.log('Constructor: Component is being initialized');
                  }
                
                  componentDidMount() {
                    console.log('ComponentDidMount: Component has been mounted to the DOM');
                    // Start timer after component mounts
                    this.timerId = window.setInterval(() => {
                      this.setState(prevState => ({
                        count: prevState.count + 1
                      }));
                    }, 1000);
                  }
                
                  shouldComponentUpdate(nextProps: TimerProps, nextState: TimerState) {
                    console.log('ShouldComponentUpdate: Deciding whether to re-render');
                    // Only update if count changed by more than 1
                    return Math.abs(nextState.count - this.state.count) >= 1;
                  }
                
                  componentDidUpdate(prevProps: TimerProps, prevState: TimerState) {
                    console.log('ComponentDidUpdate: Component has been updated');
                    console.log('Previous count:', prevState.count);
                    console.log('Current count:', this.state.count);
                    
                    // You can perform side effects here based on state/prop changes
                    if (this.state.count >= 10 && prevState.count < 10) {
                      console.log('Count reached 10!');
                    }
                  }
                
                  componentWillUnmount() {
                    console.log('ComponentWillUnmount: Component is about to be removed');
                    // Clean up the timer when component unmounts
                    if (this.timerId) {
                      clearInterval(this.timerId);
                    }
                  }
                
                  render() {
                    console.log('Render: Component is rendering');
                    return (
                      &lt;div&gt;
                        &lt;h2&gt;Timer: {this.state.count}&lt;/h2&gt;
                      &lt;/div&gt;
                    );
                  }
                }
                
                export default Timer;</code></pre>
                
                              <div class="callout-block callout-block-warning">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-exclamation-triangle"></i> </span
                                    ><!--//icon-holder-->
                                    Deprecated Lifecycle Methods
                                  </h4>
                                  <p>
                                    Some lifecycle methods are deprecated and should be avoided in new code:
                                    <ul>
                                      <li><code>componentWillMount</code></li>
                                      <li><code>componentWillReceiveProps</code></li>
                                      <li><code>componentWillUpdate</code></li>
                                    </ul>
                                    These were replaced by newer methods or can be handled differently in the component lifecycle.
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
                            </section>
                
                            <section class="docs-section" id="item-6-3">
                              <h2 class="section-heading">Class vs Function Components</h2>
                              <p>
                                With the introduction of Hooks in React 16.8, functional components can now handle state and lifecycle features that were previously only available in class components. Let's compare both approaches:
                              </p>
                
                              <h4>Feature Comparison</h4>
                              <div class="table-responsive">
                                <table class="table">
                                  <thead>
                                    <tr>
                                      <th>Feature</th>
                                      <th>Class Components</th>
                                      <th>Functional Components (with Hooks)</th>
                                    </tr>
                                  </thead>
                                  <tbody>
                                    <tr>
                                      <td>State Management</td>
                                      <td><code>this.state</code> and <code>this.setState()</code></td>
                                      <td><code>useState()</code> Hook</td>
                                    </tr>
                                    <tr>
                                      <td>Lifecycle Methods</td>
                                      <td>Built-in lifecycle methods</td>
                                      <td><code>useEffect()</code>, <code>useLayoutEffect()</code> Hooks</td>
                                    </tr>
                                    <tr>
                                      <td>Refs</td>
                                      <td><code>createRef()</code> or callback refs</td>
                                      <td><code>useRef()</code> Hook</td>
                                    </tr>
                                    <tr>
                                      <td>Context</td>
                                      <td>Static <code>contextType</code> or <code>Context.Consumer</code></td>
                                      <td><code>useContext()</code> Hook</td>
                                    </tr>
                                    <tr>
                                      <td>Memoization</td>
                                      <td><code>PureComponent</code> or <code>shouldComponentUpdate()</code></td>
                                      <td><code>React.memo()</code>, <code>useMemo()</code>, <code>useCallback()</code></td>
                                    </tr>
                                    <tr>
                                      <td>Error Boundaries</td>
                                      <td>Supported with <code>componentDidCatch()</code></td>
                                      <td>Not directly supported (must use class)</td>
                                    </tr>
                                  </tbody>
                                </table>
                              </div>
                
                              <h4>Code Comparison</h4>
                              <p>Let's compare the same component implemented as both a class and a function:</p>
                
                              <p><strong>Class Component:</strong></p>
                              <pre><code class="language-typescript">import React, { Component } from 'react';
                
                interface CounterProps {
                  initialCount: number;
                }
                
                interface CounterState {
                  count: number;
                }
                
                class Counter extends Component&lt;CounterProps, CounterState&gt; {
                  constructor(props: CounterProps) {
                    super(props);
                    this.state = {
                      count: props.initialCount
                    };
                  }
                  
                  increment = () => {
                    this.setState(prevState => ({
                      count: prevState.count + 1
                    }));
                  };
                  
                  componentDidMount() {
                    console.log('Component mounted');
                  }
                  
                  componentDidUpdate(prevProps: CounterProps, prevState: CounterState) {
                    if (prevState.count !== this.state.count) {
                      console.log('Count updated:', this.state.count);
                    }
                  }
                  
                  componentWillUnmount() {
                    console.log('Component will unmount');
                  }
                  
                  render() {
                    return (
                      &lt;div&gt;
                        &lt;h2&gt;Count: {this.state.count}&lt;/h2&gt;
                        &lt;button onClick={this.increment}&gt;Increment&lt;/button&gt;
                      &lt;/div&gt;
                    );
                  }
                }</code></pre>
                
                              <p><strong>Function Component with Hooks:</strong></p>
                              <pre><code class="language-typescript">import React, { useState, useEffect } from 'react';
                
                interface CounterProps {
                  initialCount: number;
                }
                
                const Counter: React.FC&lt;CounterProps&gt; = ({ initialCount }) => {
                  // State management with useState
                  const [count, setCount] = useState(initialCount);
                  
                  // Equivalent to componentDidMount, componentDidUpdate, and componentWillUnmount
                  useEffect(() => {
                    console.log('Component mounted');
                    
                    return () => {
                      console.log('Component will unmount');
                    };
                  }, []); // Empty dependency array means run only on mount/unmount
                  
                  // Effect that runs when count changes (like componentDidUpdate)
                  useEffect(() => {
                    console.log('Count updated:', count);
                  }, [count]);
                  
                  const increment = () => {
                    setCount(prevCount => prevCount + 1);
                  };
                  
                  return (
                    &lt;div&gt;
                      &lt;h2&gt;Count: {count}&lt;/h2&gt;
                      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
                    &lt;/div&gt;
                  );
                };</code></pre>
                
                              <h4>Pros and Cons</h4>
                              <p><strong>Class Components:</strong></p>
                              <ul>
                                <li><strong>Pros:</strong> 
                                  <ul>
                                    <li>Familiar to developers coming from OOP backgrounds</li>
                                    <li>Clear lifecycle methods</li>
                                    <li>Required for error boundaries</li>
                                  </ul>
                                </li>
                                <li><strong>Cons:</strong>
                                  <ul>
                                    <li>More verbose and boilerplate code</li>
                                    <li>Complex components can be harder to understand</li>
                                    <li><code>this</code> binding can be confusing</li>
                                    <li>Logic reuse is more challenging (requires HOCs or render props)</li>
                                  </ul>
                                </li>
                              </ul>
                
                              <p><strong>Functional Components:</strong></p>
                              <ul>
                                <li><strong>Pros:</strong> 
                                  <ul>
                                    <li>More concise, less boilerplate</li>
                                    <li>Easier to test and debug</li>
                                    <li>Better performance in some cases</li>
                                    <li>Hooks enable better organization and reuse of stateful logic</li>
                                  </ul>
                                </li>
                                <li><strong>Cons:</strong>
                                  <ul>
                                    <li>Learning curve for Hooks</li>
                                    <li>Rules of Hooks must be followed (can't use in conditionals)</li>
                                    <li>Can't use for error boundaries (yet)</li>
                                  </ul>
                                </li>
                              </ul>
                
                              <div class="callout-block callout-block-success">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-thumbs-up"></i> </span
                                    ><!--//icon-holder-->
                                    Modern Recommendation
                                  </h4>
                                  <p>
                                    The React team recommends using functional components with Hooks for new code. They're more concise, easier to understand, and make reusing stateful logic between components much simpler. Class components are still supported for legacy reasons and specific use cases like error boundaries.
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
                            </section>
                          </article>
                
                          <article class="docs-article" id="section-7">
                            <header class="docs-header">
                              <h1 class="docs-heading">Props</h1>
                              <section class="docs-intro">
                                <p>
                                  Props (short for properties) are a way of passing data from parent to child components in React. They are the primary mechanism for component communication and help maintain the unidirectional data flow in React applications.
                                </p>
                              </section>
                              <!--//docs-intro-->
                            </header>
                            <section class="docs-section" id="item-7-1">
                              <h2 class="section-heading">Understanding Props</h2>
                              <p>
                                Props are read-only inputs to components. They allow you to customize a component's behavior or appearance when it's created. Props are passed to components similar to HTML attributes.
                              </p>
                
                              <h4>Passing Props</h4>
                              <pre><code class="language-typescript">// Parent component passing props
                function App() {
                  return (
                    &lt;div&gt;
                      {/* Passing string props */}
                      &lt;Greeting name="Alice" greeting="Welcome" /&gt;
                      
                      {/* Passing numeric props */}
                      &lt;Counter initialCount={5} step={2} /&gt;
                      
                      {/* Passing boolean props */}
                      &lt;ToggleButton isActive={true} /&gt;
                      
                      {/* Passing object props */}
                      &lt;UserProfile user={{ id: 1, name: 'John', email: 'john@example.com' }} /&gt;
                      
                      {/* Passing function props (callbacks) */}
                      &lt;Button onClick={() => console.log('Button clicked!')} label="Click Me" /&gt;
                      
                      {/* Passing React elements as props */}
                      &lt;Card 
                        header={&lt;h2&gt;Card Title&lt;/h2&gt;}
                        footer={&lt;small&gt;Footer text&lt;/small&gt;}
                      &gt;
                        &lt;p&gt;Main content&lt;/p&gt;
                      &lt;/Card&gt;
                    &lt;/div&gt;
                  );
                }</code></pre>
                
                              <h4>Receiving Props in Functional Components</h4>
                              <pre><code class="language-typescript">interface GreetingProps {
                  name: string;
                  greeting?: string;
                }
                
                // Receiving and using props
                function Greeting(props: GreetingProps) {
                  return &lt;h1&gt;{props.greeting || 'Hello'}, {props.name}!&lt;/h1&gt;;
                }
                
                // With destructuring (more common)
                function GreetingDestructured({ name, greeting = 'Hello' }: GreetingProps) {
                  return &lt;h1&gt;{greeting}, {name}!&lt;/h1&gt;;
                }</code></pre>
                
                              <h4>Spreading Props</h4>
                              <p>Props can be spread to pass all properties of an object:</p>
                
                              <pre><code class="language-typescript">interface ButtonProps {
                  type?: 'button' | 'submit' | 'reset';
                  className?: string;
                  disabled?: boolean;
                  onClick?: () => void;
                  children: React.ReactNode;
                }
                
                function Button({ children, ...rest }: ButtonProps) {
                  return (
                    &lt;button {...rest}&gt;
                      {children}
                    &lt;/button&gt;
                  );
                }
                
                // Usage
                function App() {
                  const buttonProps = {
                    type: 'submit' as const,
                    className: 'primary-button',
                    disabled: false,
                    onClick: () => console.log('Submitted!')
                  };
                  
                  return (
                    &lt;Button {...buttonProps}&gt;Submit&lt;/Button&gt;
                  );
                }</code></pre>
                
                              <div class="callout-block callout-block-warning">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-exclamation-triangle"></i> </span
                                    ><!--//icon-holder-->
                                    Props Are Read-Only
                                  </h4>
                                  <p>
                                    A component must never modify its own props. React is designed around a unidirectional data flow where props are passed down from parent to child components. Treating props as read-only helps maintain this flow and prevents unexpected behavior.
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
                            </section>
                
                            <section class="docs-section" id="item-7-2">
                              <h2 class="section-heading">PropTypes and TypeScript</h2>
                              <p>
                                TypeScript provides strong type-checking for props, making the older <code>PropTypes</code> library largely unnecessary in TypeScript projects. However, understanding both approaches is valuable.
                              </p>
                
                              <h4>TypeScript Interface for Props</h4>
                              <pre><code class="language-typescript">// Define an interface for the component props
                interface UserCardProps {
                  id: number;
                  name: string;
                  email: string;
                  isActive: boolean;
                  role?: 'admin' | 'user' | 'guest'; // Optional prop with specific values
                  score: number;
                  onClick: (id: number) => void;
                  children?: React.ReactNode;
                }
                
                // Use the interface for type checking
                const UserCard: React.FC&lt;UserCardProps&gt; = ({
                  id,
                  name,
                  email,
                  isActive,
                  role = 'user',
                  score,
                  onClick,
                  children
                }) => {
                  return (
                    &lt;div className={`user-card ${isActive ? 'active' : 'inactive'}`}&gt;
                      &lt;h3&gt;{name} ({role})&lt;/h3&gt;
                      &lt;p&gt;Email: {email}&lt;/p&gt;
                      &lt;p&gt;Score: {score}&lt;/p&gt;
                      {children}
                      &lt;button onClick={() => onClick(id)}&gt;View Profile&lt;/button&gt;
                    &lt;/div&gt;
                  );
                };</code></pre>
                
                              <h4>PropTypes Library (for JavaScript or non-TypeScript projects)</h4>
                              <pre><code class="language-jsx">import PropTypes from 'prop-types';
                
                function UserCard({ id, name, email, isActive, role, score, onClick, children }) {
                  return (
                    &lt;div className={`user-card ${isActive ? 'active' : 'inactive'}`}&gt;
                      &lt;h3&gt;{name} ({role})&lt;/h3&gt;
                      &lt;p&gt;Email: {email}&lt;/p&gt;
                      &lt;p&gt;Score: {score}&lt;/p&gt;
                      {children}
                      &lt;button onClick={() => onClick(id)}&gt;View Profile&lt;/button&gt;
                    &lt;/div&gt;
                  );
                }
                
                // Define PropTypes for runtime type checking
                UserCard.propTypes = {
                  id: PropTypes.number.isRequired,
                  name: PropTypes.string.isRequired,
                  email: PropTypes.string.isRequired,
                  isActive: PropTypes.bool.isRequired,
                  role: PropTypes.oneOf(['admin', 'user', 'guest']),
                  score: PropTypes.number.isRequired,
                  onClick: PropTypes.func.isRequired,
                  children: PropTypes.node
                };
                
                // Default props
                UserCard.defaultProps = {
                  role: 'user'
                };</code></pre>
                
                              <h4>Complex Props Types in TypeScript</h4>
                              <pre><code class="language-typescript">// Advanced TypeScript types for props
                
                // Union types
                type ButtonVariant = 'primary' | 'secondary' | 'danger' | 'success';
                
                // Interface with optional fields
                interface Address {
                  street: string;
                  city: string;
                  state?: string;
                  country: string;
                  zipCode?: string;
                }
                
                // Interface extending another interface
                interface User {
                  id: number;
                  name: string;
                  email: string;
                }
                
                interface UserWithAddress extends User {
                  address: Address;
                }
                
                // Generic components
                interface SelectProps&lt;T&gt; {
                  options: T[];
                  value: T;
                  onChange: (newValue: T) => void;
                  renderOption: (option: T) => React.ReactNode;
                }
                
                function Select&lt;T&gt;({ options, value, onChange, renderOption }: SelectProps&lt;T&gt;) {
                  return (
                    &lt;select value={String(value)} onChange={(e) => onChange(options[Number(e.target.value)])}&gt;
                      {options.map((option, index) => (
                        &lt;option key={index} value={index}&gt;
                          {renderOption(option)}
                        &lt;/option&gt;
                      ))}
                    &lt;/select&gt;
                  );
                }</code></pre>
                
                              <div class="callout-block callout-block-info">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-info-circle"></i> </span
                                    ><!--//icon-holder-->
                                    TypeScript vs PropTypes
                                  </h4>
                                  <p>
                                    <ul>
                                      <li><strong>TypeScript</strong> provides compile-time type checking, catching errors before the code runs</li>
                                      <li><strong>PropTypes</strong> provides runtime type checking, showing warnings in the console during development</li>
                                      <li>In TypeScript projects, PropTypes are generally redundant and add unnecessary code</li>
                                      <li>Consider using both only if you're creating a library that will be used in both TypeScript and JavaScript projects</li>
                                    </ul>
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
                            </section>
                
                            <section class="docs-section" id="item-7-3">
                              <h2 class="section-heading">Default Props</h2>
                              <p>
                                Default props provide fallback values for props that aren't specified by the parent component. There are several ways to define default props in React components.
                              </p>
                
                              <h4>Default Props in TypeScript</h4>
                              <p>In TypeScript, the most common ways to define default props are:</p>
                
                              <p><strong>1. Default Parameter Values (Recommended for Functional Components)</strong></p>
                              <pre><code class="language-typescript">interface ButtonProps {
                  variant?: 'primary' | 'secondary' | 'danger';
                  size?: 'small' | 'medium' | 'large';
                  label: string;
                  onClick?: () => void;
                  disabled?: boolean;
                }
                
                function Button({
                  variant = 'primary',
                  size = 'medium',
                  label,
                  onClick = () => {},
                  disabled = false
                }: ButtonProps) {
                  return (
                    &lt;button
                      className={`btn btn-${variant} btn-${size}`}
                      onClick={onClick}
                      disabled={disabled}
                    &gt;
                      {label}
                    &lt;/button&gt;
                  );
                }</code></pre>
                
                              <p><strong>2. Using the defaultProps Static Property</strong></p>
                              <pre><code class="language-typescript">interface ButtonProps {
                  variant: 'primary' | 'secondary' | 'danger';
                  size: 'small' | 'medium' | 'large';
                  label: string;
                  onClick: () => void;
                  disabled: boolean;
                }
                
                function Button(props: ButtonProps) {
                  const { variant, size, label, onClick, disabled } = props;
                  
                  return (
                    &lt;button
                      className={`btn btn-${variant} btn-${size}`}
                      onClick={onClick}
                      disabled={disabled}
                    &gt;
                      {label}
                    &lt;/button&gt;
                  );
                }
                
                // Define default props
                Button.defaultProps = {
                  variant: 'primary',
                  size: 'medium',
                  onClick: () => {},
                  disabled: false
                };</code></pre>
                
                              <p><strong>3. For Class Components</strong></p>
                              <pre><code class="language-typescript">interface ButtonProps {
                  variant: 'primary' | 'secondary' | 'danger';
                  size: 'small' | 'medium' | 'large';
                  label: string;
                  onClick: () => void;
                  disabled: boolean;
                }
                
                class Button extends React.Component&lt;ButtonProps&gt; {
                  // Define default props as static property
                  static defaultProps: Partial&lt;ButtonProps&gt; = {
                    variant: 'primary',
                    size: 'medium',
                    onClick: () => {},
                    disabled: false
                  };
                  
                  render() {
                    const { variant, size, label, onClick, disabled } = this.props;
                    
                    return (
                      &lt;button
                        className={`btn btn-${variant} btn-${size}`}
                        onClick={onClick}
                        disabled={disabled}
                      &gt;
                        {label}
                      &lt;/button&gt;
                    );
                  }
                }</code></pre>
                
                              <h4>Making Props Optional in TypeScript</h4>
                              <p>There are two ways to make props optional:</p>
                
                              <p><strong>1. Using the Optional Property Operator (?)</strong></p>
                              <pre><code class="language-typescript">interface UserProps {
                  name: string;       // Required
                  age?: number;       // Optional
                  email?: string;     // Optional
                }</code></pre>
                
                              <p><strong>2. Using Union Types with undefined</strong></p>
                              <pre><code class="language-typescript">interface UserProps {
                  name: string;                // Required
                  age: number | undefined;     // Required in props, but can be undefined
                  email: string | undefined;   // Required in props, but can be undefined
                }</code></pre>
                
                              <div class="callout-block callout-block-info">
                                <div class="content">
                                  <h4 class="callout-title">
                                    <span class="callout-icon-holder me-1">
                                      <i class="fas fa-info-circle"></i> </span
                                    ><!--//icon-holder-->
                                    Best Practice
                                  </h4>
                                  <p>
                                    For functional components, using default parameter values is generally preferred over <code>defaultProps</code> because:
                                    <ul>
                                      <li>It's more inline with JavaScript's native parameter defaults</li>
                                      <li>The defaults are visible right in the function signature</li>
                                      <li>TypeScript handles the types correctly without additional work</li>
                                      <li>In the future, <code>defaultProps</code> might be deprecated for function components</li>
                                    </ul>
                                  </p>
                                </div>
                                <!--//content-->
                              </div>
                              <!--//callout-block-->
            </section>
        </article>

        <article class="docs-article" id="section-8">
          <header class="docs-header">
            <h1 class="docs-heading">Events</h1>
            <section class="docs-intro">
              <p>
                Handling events in React is similar to handling events in DOM, but with some syntax differences. React events are named using camelCase and passed as functions rather than strings.
              </p>
            </section>
            <!--//docs-intro-->
          </header>
          <section class="docs-section" id="item-8-1">
            <h2 class="section-heading">Handling Events</h2>
            <p>
              Event handling in React follows a declarative approach, where you define what should happen when an event occurs rather than directly manipulating the DOM.
            </p>

            <h4>Basic Event Handling</h4>
            <pre><code class="language-typescript">function Button() {
// Event handler function
const handleClick = () => {
  console.log('Button was clicked!');
};

return (
  &lt;button onClick={handleClick}&gt;
    Click Me
  &lt;/button&gt;
);
}</code></pre>

            <h4>Common React Events</h4>
            <div class="table-responsive">
              <table class="table">
                <thead>
                  <tr>
                    <th>React Event</th>
                    <th>DOM Equivalent</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>onClick</code></td>
                    <td><code>click</code></td>
                    <td>Triggered when an element is clicked</td>
                  </tr>
                  <tr>
                    <td><code>onChange</code></td>
                    <td><code>change</code></td>
                    <td>Triggered when the value of an input element changes</td>
                  </tr>
                  <tr>
                    <td><code>onSubmit</code></td>
                    <td><code>submit</code></td>
                    <td>Triggered when a form is submitted</td>
                  </tr>
                  <tr>
                    <td><code>onMouseEnter</code></td>
                    <td><code>mouseenter</code></td>
                    <td>Triggered when the mouse enters an element</td>
                  </tr>
                  <tr>
                    <td><code>onMouseLeave</code></td>
                    <td><code>mouseleave</code></td>
                    <td>Triggered when the mouse leaves an element</td>
                  </tr>
                  <tr>
                    <td><code>onFocus</code></td>
                    <td><code>focus</code></td>
                    <td>Triggered when an element receives focus</td>
                  </tr>
                  <tr>
                    <td><code>onBlur</code></td>
                    <td><code>blur</code></td>
                    <td>Triggered when an element loses focus</td>
                  </tr>
                  <tr>
                    <td><code>onKeyDown</code></td>
                    <td><code>keydown</code></td>
                    <td>Triggered when a key is pressed down</td>
                  </tr>
                  <tr>
                    <td><code>onKeyUp</code></td>
                    <td><code>keyup</code></td>
                    <td>Triggered when a key is released</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <h4>Event Handling in Forms</h4>
            <pre><code class="language-typescript">function LoginForm() {
const [username, setUsername] = useState('');
const [password, setPassword] = useState('');

// Handle input changes
const handleUsernameChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
  setUsername(event.target.value);
};

const handlePasswordChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
  setPassword(event.target.value);
};

// Handle form submission
const handleSubmit = (event: React.FormEvent&lt;HTMLFormElement&gt;) => {
  event.preventDefault(); // Prevent default form submission
  console.log('Login attempted with:', username, password);
  // Perform login logic here
};

return (
  &lt;form onSubmit={handleSubmit}&gt;
    &lt;div&gt;
      &lt;label htmlFor="username"&gt;Username:&lt;/label&gt;
      &lt;input
        type="text"
        id="username"
        value={username}
        onChange={handleUsernameChange}
      /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;label htmlFor="password"&gt;Password:&lt;/label&gt;
      &lt;input
        type="password"
        id="password"
        value={password}
        onChange={handlePasswordChange}
      /&gt;
    &lt;/div&gt;
    &lt;button type="submit"&gt;Login&lt;/button&gt;
  &lt;/form&gt;
);
}</code></pre>

            <div class="callout-block callout-block-info">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-info-circle"></i> </span
                  ><!--//icon-holder-->
                  Synthetic Events
                </h4>
                <p>
                  React wraps native DOM events in a cross-browser wrapper called SyntheticEvent. These synthetic events have the same interface as native events but work consistently across different browsers. For performance reasons, React reuses event objects, so the event's properties cannot be accessed in an asynchronous way without explicitly calling <code>event.persist()</code>.
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>

          <section class="docs-section" id="item-8-2">
            <h2 class="section-heading">Event Types in TypeScript</h2>
            <p>
              TypeScript provides type definitions for React's synthetic events, making it easier to handle events correctly.
            </p>

            <h4>Common Event Types</h4>
            <div class="table-responsive">
              <table class="table">
                <thead>
                  <tr>
                    <th>Event Type</th>
                    <th>Usage</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>React.MouseEvent</code></td>
                    <td>onClick, onMouseOver, etc.</td>
                    <td>For mouse events</td>
                  </tr>
                  <tr>
                    <td><code>React.ChangeEvent</code></td>
                    <td>onChange</td>
                    <td>For input, select, and textarea changes</td>
                  </tr>
                  <tr>
                    <td><code>React.FormEvent</code></td>
                    <td>onSubmit</td>
                    <td>For form submission events</td>
                  </tr>
                  <tr>
                    <td><code>React.KeyboardEvent</code></td>
                    <td>onKeyDown, onKeyUp, onKeyPress</td>
                    <td>For keyboard events</td>
                  </tr>
                  <tr>
                    <td><code>React.FocusEvent</code></td>
                    <td>onFocus, onBlur</td>
                    <td>For focus-related events</td>
                  </tr>
                  <tr>
                    <td><code>React.DragEvent</code></td>
                    <td>onDrag, onDrop</td>
                    <td>For drag and drop events</td>
                  </tr>
                  <tr>
                    <td><code>React.ClipboardEvent</code></td>
                    <td>onCopy, onPaste, onCut</td>
                    <td>For clipboard events</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <h4>Type Generic Parameter</h4>
            <p>
              Each event type takes a generic parameter indicating the type of element that triggered the event:
            </p>

            <pre><code class="language-typescript">// Common event handler types in TypeScript
import React from 'react';

function EventDemo() {
// Button click handler
const handleButtonClick = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) => {
  console.log('Button clicked', event.currentTarget.name);
};

// Input change handler
const handleInputChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
  console.log('Input value changed to:', event.target.value);
};

// Form submit handler
const handleFormSubmit = (event: React.FormEvent&lt;HTMLFormElement&gt;) => {
  event.preventDefault();
  console.log('Form submitted');
};

// Keyboard event handler
const handleKeyDown = (event: React.KeyboardEvent&lt;HTMLInputElement&gt;) => {
  if (event.key === 'Enter') {
    console.log('Enter key pressed');
  }
};

// Focus event handler
const handleFocus = (event: React.FocusEvent&lt;HTMLInputElement&gt;) => {
  console.log('Input focused');
};

return (
  &lt;form onSubmit={handleFormSubmit}&gt;
    &lt;input 
      type="text" 
      onChange={handleInputChange}
      onKeyDown={handleKeyDown}
      onFocus={handleFocus}
    /&gt;
    &lt;button 
      type="button" 
      name="actionButton"
      onClick={handleButtonClick}
    &gt;
      Click Me
    &lt;/button&gt;
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
);
}</code></pre>

            <h4>Custom Event Handler Types</h4>
            <p>
              You can define your own event handler types for improved code readability:
            </p>

            <pre><code class="language-typescript">// Define reusable event handler types
type ButtonClickHandler = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) => void;
type InputChangeHandler = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => void;
type FormSubmitHandler = (event: React.FormEvent&lt;HTMLFormElement&gt;) => void;

// Use the custom types
const handleButtonClick: ButtonClickHandler = (event) => {
console.log('Button clicked', event.currentTarget.name);
};

const handleInputChange: InputChangeHandler = (event) => {
console.log('Input value changed to:', event.target.value);
};

const handleFormSubmit: FormSubmitHandler = (event) => {
event.preventDefault();
console.log('Form submitted');
};</code></pre>

            <div class="callout-block callout-block-warning">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-exclamation-triangle"></i> </span
                  ><!--//icon-holder-->
                  Common TypeScript Event Issues
                </h4>
                <p>
                  <ul>
                    <li>Use <code>event.target</code> when you need the specific element that triggered the event (e.g., an input field)</li>
                    <li>Use <code>event.currentTarget</code> when you need the element that the event handler is attached to</li>
                    <li>If you need properties that are only available on specific elements (like <code>value</code> on inputs), you must use the correct element type in your event handler</li>
                    <li>When using <code>event.target</code>, you might need to perform type assertions or type guards to access element-specific properties safely</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>

          <section class="docs-section" id="item-8-3">
            <h2 class="section-heading">Passing Arguments</h2>
            <p>
              Sometimes you need to pass additional arguments to event handlers. There are several ways to accomplish this.
            </p>

            <h4>Method 1: Using Arrow Functions</h4>
            <pre><code class="language-typescript">function ItemList() {
const items = [
  { id: 1, name: 'Item 1' },
  { id: 2, name: 'Item 2' },
  { id: 3, name: 'Item 3' }
];

// Handler that needs an ID parameter
const handleItemClick = (id: number, event: React.MouseEvent&lt;HTMLButtonElement&gt;) => {
  console.log(`Item ${id} clicked`, event.currentTarget);
};

return (
  &lt;div&gt;
    &lt;h2&gt;Items&lt;/h2&gt;
    &lt;ul&gt;
      {items.map(item => (
        &lt;li key={item.id}&gt;
          {item.name}
          {/* Use arrow function to pass parameters */}
          &lt;button onClick={(e) => handleItemClick(item.id, e)}&gt;
            View Details
          &lt;/button&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Method 2: Using bind() (Less Common in Modern React)</h4>
            <pre><code class="language-typescript">function ItemList() {
const items = [
  { id: 1, name: 'Item 1' },
  { id: 2, name: 'Item 2' },
  { id: 3, name: 'Item 3' }
];

// Handler that needs an ID parameter
const handleItemClick = (id: number, event: React.MouseEvent&lt;HTMLButtonElement&gt;) => {
  console.log(`Item ${id} clicked`, event.currentTarget);
};

return (
  &lt;div&gt;
    &lt;h2&gt;Items&lt;/h2&gt;
    &lt;ul&gt;
      {items.map(item => (
        &lt;li key={item.id}&gt;
          {item.name}
          {/* Use bind to pre-configure arguments */}
          &lt;button onClick={handleItemClick.bind(null, item.id)}&gt;
            View Details
          &lt;/button&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Method 3: Using Data Attributes</h4>
            <pre><code class="language-typescript">function ItemList() {
const items = [
  { id: 1, name: 'Item 1' },
  { id: 2, name: 'Item 2' },
  { id: 3, name: 'Item 3' }
];

// Handler that extracts ID from data attribute
const handleItemClick = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) => {
  const id = event.currentTarget.dataset.itemId;
  console.log(`Item ${id} clicked`, event.currentTarget);
};

return (
  &lt;div&gt;
    &lt;h2&gt;Items&lt;/h2&gt;
    &lt;ul&gt;
      {items.map(item => (
        &lt;li key={item.id}&gt;
          {item.name}
          {/* Use data attributes to store additional data */}
          &lt;button 
            data-item-id={item.id.toString()} 
            onClick={handleItemClick}
          &gt;
            View Details
          &lt;/button&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Method 4: Closures with Factory Functions</h4>
            <pre><code class="language-typescript">function ItemList() {
const items = [
  { id: 1, name: 'Item 1' },
  { id: 2, name: 'Item 2' },
  { id: 3, name: 'Item 3' }
];

// Factory function that creates an event handler for a specific ID
const createItemClickHandler = (id: number) => {
  return (event: React.MouseEvent&lt;HTMLButtonElement&gt;) => {
    console.log(`Item ${id} clicked`, event.currentTarget);
  };
};

return (
  &lt;div&gt;
    &lt;h2&gt;Items&lt;/h2&gt;
    &lt;ul&gt;
      {items.map(item => (
        &lt;li key={item.id}&gt;
          {item.name}
          {/* Use a factory function to create a handler */}
          &lt;button onClick={createItemClickHandler(item.id)}&gt;
            View Details
          &lt;/button&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  &lt;/div&gt;
);
}</code></pre>

            <div class="callout-block callout-block-info">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-info-circle"></i> </span
                  ><!--//icon-holder-->
                  Performance Considerations
                </h4>
                <p>
                  <ul>
                    <li>Using inline arrow functions (<code>onClick={(e) => handleClick(id, e)}</code>) is the most readable approach, but creates a new function every render</li>
                    <li>For high-performance applications with many items, consider using the factory function or data attribute approach</li>
                    <li>If you're using the factory function approach, consider memoizing the handlers with <code>useCallback</code> to prevent unnecessary recreation</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>
        </article>

        <article class="docs-article" id="section-9">
          <header class="docs-header">
            <h1 class="docs-heading">Conditionals</h1>
            <section class="docs-intro">
              <p>
                Conditional rendering is a powerful feature in React that allows you to render different UI components based on certain conditions. This is essential for creating dynamic and interactive user interfaces.
              </p>
            </section>
            <!--//docs-intro-->
          </header>
          <section class="docs-section" id="item-9-1">
            <h2 class="section-heading">Conditional Rendering</h2>
            <p>
              There are several ways to implement conditional rendering in React components:
            </p>

            <h4>1. If/Else Statements</h4>
            <pre><code class="language-typescript">function UserGreeting({ isLoggedIn, username }: { isLoggedIn: boolean; username?: string }) {
if (isLoggedIn) {
  return &lt;h1&gt;Welcome back, {username}!&lt;/h1&gt;;
} else {
  return &lt;h1&gt;Please sign in&lt;/h1&gt;;
}
}</code></pre>

            <h4>2. Element Variables</h4>
            <pre><code class="language-typescript">function LoginControl({ isLoggedIn }: { isLoggedIn: boolean }) {
let button;

if (isLoggedIn) {
  button = &lt;LogoutButton /&gt;;
} else {
  button = &lt;LoginButton /&gt;;
}

return (
  &lt;div&gt;
    &lt;div&gt;{isLoggedIn ? 'Welcome back!' : 'Please sign in'}&lt;/div&gt;
    {button}
  &lt;/div&gt;
);
}</code></pre>

            <h4>3. Ternary Operator</h4>
            <pre><code class="language-typescript">function Notification({ count }: { count: number }) {
return (
  &lt;div&gt;
    {count > 0 
      ? &lt;p&gt;You have {count} unread messages&lt;/p&gt; 
      : &lt;p&gt;No new messages&lt;/p&gt;
    }
  &lt;/div&gt;
);
}</code></pre>

            <h4>4. Logical && Operator</h4>
            <pre><code class="language-typescript">function ItemList({ items }: { items: string[] }) {
return (
  &lt;div&gt;
    <h3>Items</h3>
    {items.length > 0 && (
      &lt;ul&gt;
        {items.map((item, index) => (
          &lt;li key={index}&gt;{item}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    )}
    {items.length === 0 && &lt;p&gt;No items found.&lt;/p&gt;}
  &lt;/div&gt;
);
}</code></pre>

            <h4>5. Switch Statement</h4>
            <pre><code class="language-typescript">function StatusMessage({ status }: { status: 'loading' | 'success' | 'error' }) {
let message;

switch (status) {
  case 'loading':
    message = &lt;p&gt;Loading...&lt;/p&gt;;
    break;
  case 'success':
    message = &lt;p className="success"&gt;Data loaded successfully!&lt;/p&gt;;
    break;
  case 'error':
    message = &lt;p className="error"&gt;Error loading data. Please try again.&lt;/p&gt;;
    break;
  default:
    message = null;
}

return &lt;div className="status-container"&gt;{message}&lt;/div&gt;;
}</code></pre>

            <h4>6. Immediately-Invoked Function Expressions (IIFE)</h4>
            <pre><code class="language-typescript">function ComplexCondition({ value, type }: { value: number; type: string }) {
return (
  &lt;div&gt;
    {(() => {
      if (value > 100 && type === 'premium') {
        return &lt;PremiumHighValueComponent value={value} /&gt;;
      } else if (value > 100) {
        return &lt;HighValueComponent value={value} /&gt;;
      } else if (value > 50) {
        return &lt;MediumValueComponent value={value} /&gt;;
      } else {
        return &lt;LowValueComponent value={value} /&gt;;
      }
    })()}
  &lt;/div&gt;
);
}</code></pre>

            <div class="callout-block callout-block-success">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-thumbs-up"></i> </span
                  ><!--//icon-holder-->
                  Best Practices
                </h4>
                <p>
                  <ul>
                    <li>Use ternary operators for simple conditions</li>
                    <li>Use logical && for conditional rendering of elements (when the condition is true)</li>
                    <li>Use if/else or switch statements for more complex conditions</li>
                    <li>Extract complex conditional logic into separate components or helper functions</li>
                    <li>Be careful with the && operator: ensure the left side evaluates to a boolean (not 0 or other falsy values that aren't false)</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>

          <section class="docs-section" id="item-9-2">
            <h2 class="section-heading">Advanced Conditional Rendering</h2>
            <p>
              For more complex conditional rendering scenarios, you can use advanced techniques:
            </p>

            <h4>Conditional Rendering with Maps</h4>
            <pre><code class="language-typescript">function FeatureList({ features }: { features: Array<{ id: string; enabled: boolean; name: string }> }) {
return (
  &lt;ul&gt;
    {features
      .filter(feature => feature.enabled)
      .map(feature => (
        &lt;li key={feature.id}&gt;{feature.name}&lt;/li&gt;
      ))}
  &lt;/ul&gt;
);
}</code></pre>

            <h4>Rendering Different Components Dynamically</h4>
            <pre><code class="language-typescript">type ComponentType = 'text' | 'button' | 'input';

interface ComponentProps {
type: ComponentType;
content?: string;
onClick?: () => void;
placeholder?: string;
}

function DynamicComponent({ type, content, onClick, placeholder }: ComponentProps) {
const componentMap: Record<ComponentType, React.ReactNode> = {
  text: &lt;p&gt;{content}&lt;/p&gt;,
  button: &lt;button onClick={onClick}&gt;{content}&lt;/button&gt;,
  input: &lt;input type="text" placeholder={placeholder} /&gt;
};

return &lt;div&gt;{componentMap[type]}&lt;/div&gt;;
}</code></pre>

            <h4>Using Objects for Conditional Rendering</h4>
            <pre><code class="language-typescript">function StatusIndicator({ status }: { status: 'online' | 'offline' | 'away' }) {
const statusConfig = {
  online: { label: 'Online', color: 'green', icon: '●' },
  offline: { label: 'Offline', color: 'gray', icon: '○' },
  away: { label: 'Away', color: 'orange', icon: '◐' }
};

const { label, color, icon } = statusConfig[status];

return (
  &lt;div className="status-indicator"&gt;
    &lt;span style={{ color }}&gt;{icon}&lt;/span&gt;
    &lt;span&gt;{label}&lt;/span&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Conditional CSS Classes</h4>
            <pre><code class="language-typescript">function Button({ 
variant = 'primary', 
size = 'medium',
isDisabled = false,
children 
}: {
variant?: 'primary' | 'secondary' | 'danger';
size?: 'small' | 'medium' | 'large';
isDisabled?: boolean;
children: React.ReactNode;
}) {
// Using template literals for conditional classes
const className = `
  btn 
  btn-${variant} 
  btn-${size} 
  ${isDisabled ? 'disabled' : ''}
`.trim();

return (
  &lt;button className={className} disabled={isDisabled}&gt;
    {children}
  &lt;/button&gt;
);
}</code></pre>

            <h4>Higher-Order Components for Conditional Rendering</h4>
            <pre><code class="language-typescript">// Higher-Order Component for conditional rendering
function withConditionalRendering&lt;P extends object&gt;(
Component: React.ComponentType&lt;P&gt;,
condition: (props: P) => boolean
) {
return (props: P) => {
  return condition(props) ? &lt;Component {...props} /&gt; : null;
};
}

// Usage
const AdminPanel = ({ user }: { user: { role: string } }) => {
return &lt;div&gt;Admin Panel Content&lt;/div&gt;;
};

const AdminPanelWithCondition = withConditionalRendering(
AdminPanel,
(props) => props.user.role === 'admin'
);</code></pre>

            <div class="callout-block callout-block-warning">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-exclamation-triangle"></i> </span
                  ><!--//icon-holder-->
                  Avoiding Common Pitfalls
                </h4>
                <p>
                  <ul>
                    <li><strong>Key prop in lists</strong>: Always use unique keys when rendering lists of components</li>
                    <li><strong>Rendering null</strong>: React can render <code>null</code>, <code>undefined</code>, <code>true</code>, and <code>false</code> as nothing</li>
                    <li><strong>Array rendering</strong>: If a condition might render an array, make sure it's flattened or mapped properly</li>
                    <li><strong>Avoid complex logic in render</strong>: Extract complex conditional logic to helper functions or custom hooks</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>
        </article>

        <article class="docs-article" id="section-10">
          <header class="docs-header">
            <h1 class="docs-heading">Lists</h1>
            <section class="docs-intro">
              <p>
                Lists are a common UI pattern in React applications. React provides powerful ways to render lists of data by combining JavaScript's array methods with JSX.
              </p>
            </section>
            <!--//docs-intro-->
          </header>
          <section class="docs-section" id="item-10-1">
            <h2 class="section-heading">Rendering Lists</h2>
            <p>
              In React, you can render lists of items by using JavaScript's <code>map()</code> method to transform an array of data into an array of elements.
            </p>

            <h4>Basic List Rendering</h4>
            <pre><code class="language-typescript">function SimpleList() {
const fruits = ['Apple', 'Banana', 'Cherry', 'Durian', 'Elderberry'];

return (
  &lt;ul&gt;
    {fruits.map((fruit, index) => (
      &lt;li key={index}&gt;{fruit}&lt;/li&gt;
    ))}
  &lt;/ul&gt;
);
}</code></pre>

            <h4>Rendering List of Objects</h4>
            <pre><code class="language-typescript">interface User {
id: number;
name: string;
email: string;
}

function UserList() {
const users: User[] = [
  { id: 1, name: 'John Doe', email: 'john@example.com' },
  { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
  { id: 3, name: 'Bob Johnson', email: 'bob@example.com' }
];

return (
  &lt;div&gt;
    &lt;h2&gt;User List&lt;/h2&gt;
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;ID&lt;/th&gt;
          &lt;th&gt;Name&lt;/th&gt;
          &lt;th&gt;Email&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        {users.map(user => (
          &lt;tr key={user.id}&gt;
            &lt;td&gt;{user.id}&lt;/td&gt;
            &lt;td&gt;{user.name}&lt;/td&gt;
            &lt;td&gt;{user.email}&lt;/td&gt;
          &lt;/tr&gt;
        ))}
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Nested Lists</h4>
            <pre><code class="language-typescript">interface Department {
id: number;
name: string;
employees: {
  id: number;
  name: string;
  role: string;
}[];
}

function OrganizationChart() {
const departments: Department[] = [
  {
    id: 1,
    name: 'Engineering',
    employees: [
      { id: 101, name: 'Alice', role: 'Software Engineer' },
      { id: 102, name: 'Bob', role: 'DevOps Engineer' }
    ]
  },
  {
    id: 2,
    name: 'Marketing',
    employees: [
      { id: 201, name: 'Carol', role: 'Marketing Specialist' },
      { id: 202, name: 'Dave', role: 'Content Writer' }
    ]
  }
];

return (
  &lt;div&gt;
    &lt;h2&gt;Organization Chart&lt;/h2&gt;
    &lt;ul&gt;
      {departments.map(dept => (
        &lt;li key={dept.id}&gt;
          &lt;h3&gt;{dept.name}&lt;/h3&gt;
          &lt;ul&gt;
            {dept.employees.map(employee => (
              &lt;li key={employee.id}&gt;
                {employee.name} - {employee.role}
              &lt;/li&gt;
            ))}
          &lt;/ul&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  &lt;/div&gt;
);
}</code></pre>

            <div class="callout-block callout-block-danger">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-exclamation-circle"></i> </span
                  ><!--//icon-holder-->
                  Keys Are Critical
                </h4>
                <p>
                  When rendering lists, each item needs a unique "key" prop to help React identify which items have changed, been added, or been removed. Using array indices as keys (as in the first example) is only recommended for static lists that won't change. For dynamic lists, use unique and stable identifiers from your data (like IDs).
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>

          <section class="docs-section" id="item-10-2">
            <h2 class="section-heading">List Manipulation</h2>
            <p>
              React's declarative nature makes it easy to manipulate lists with techniques like filtering, sorting, and transforming data.
            </p>

            <h4>Filtering Lists</h4>
            <pre><code class="language-typescript">import { useState } from 'react';

interface Product {
id: number;
name: string;
category: string;
price: number;
}

function FilterableProductList() {
const [filterCategory, setFilterCategory] = useState<string>('all');

const products: Product[] = [
  { id: 1, name: 'Laptop', category: 'electronics', price: 999 },
  { id: 2, name: 'Headphones', category: 'electronics', price: 99 },
  { id: 3, name: 'Shirt', category: 'clothing', price: 29 },
  { id: 4, name: 'Jeans', category: 'clothing', price: 59 },
  { id: 5, name: 'Coffee Mug', category: 'kitchen', price: 15 }
];

// Get unique categories for the filter
const categories = ['all', ...new Set(products.map(product => product.category))];

// Filter products based on selected category
const filteredProducts = filterCategory === 'all'
  ? products
  : products.filter(product => product.category === filterCategory);

return (
  &lt;div&gt;
    &lt;h2&gt;Product List&lt;/h2&gt;
    
    &lt;div&gt;
      &lt;label htmlFor="category-filter"&gt;Filter by Category: &lt;/label&gt;
      &lt;select 
        id="category-filter"
        value={filterCategory}
        onChange={(e) => setFilterCategory(e.target.value)}
      &gt;
        {categories.map(category => (
          &lt;option key={category} value={category}&gt;
            {category.charAt(0).toUpperCase() + category.slice(1)}
          &lt;/option&gt;
        ))}
      &lt;/select&gt;
    &lt;/div&gt;
    
    &lt;ul&gt;
      {filteredProducts.map(product => (
        &lt;li key={product.id}&gt;
          {product.name} - ${product.price} ({product.category})
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Sorting Lists</h4>
            <pre><code class="language-typescript">import { useState } from 'react';

interface Person {
id: number;
name: string;
age: number;
}

type SortField = 'name' | 'age';
type SortDirection = 'asc' | 'desc';

function SortablePersonList() {
const [sortField, setSortField] = useState<SortField>('name');
const [sortDirection, setSortDirection] = useState<SortDirection>('asc');

const people: Person[] = [
  { id: 1, name: 'Alice', age: 32 },
  { id: 2, name: 'Bob', age: 28 },
  { id: 3, name: 'Charlie', age: 45 },
  { id: 4, name: 'Diana', age: 23 },
  { id: 5, name: 'Edward', age: 35 }
];

// Sort the list based on current sort field and direction
const sortedPeople = [...people].sort((a, b) => {
  if (sortField === 'name') {
    return sortDirection === 'asc' 
      ? a.name.localeCompare(b.name) 
      : b.name.localeCompare(a.name);
  } else {
    return sortDirection === 'asc' 
      ? a.age - b.age 
      : b.age - a.age;
  }
});

// Toggle sort direction or change sort field
const handleSort = (field: SortField) => {
  if (field === sortField) {
    // If same field, toggle direction
    setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
  } else {
    // If new field, set it and default to ascending
    setSortField(field);
    setSortDirection('asc');
  }
};

return (
  &lt;div&gt;
    &lt;h2&gt;Person List&lt;/h2&gt;
    
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th onClick={() => handleSort('name')} style={{ cursor: 'pointer' }}&gt;
            Name {sortField === 'name' && (sortDirection === 'asc' ? '↑' : '↓')}
          &lt;/th&gt;
          &lt;th onClick={() => handleSort('age')} style={{ cursor: 'pointer' }}&gt;
            Age {sortField === 'age' && (sortDirection === 'asc' ? '↑' : '↓')}
          &lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        {sortedPeople.map(person => (
          &lt;tr key={person.id}&gt;
            &lt;td&gt;{person.name}&lt;/td&gt;
            &lt;td&gt;{person.age}&lt;/td&gt;
          &lt;/tr&gt;
        ))}
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Paginated Lists</h4>
            <pre><code class="language-typescript">import { useState } from 'react';

interface Post {
id: number;
title: string;
body: string;
}

function PaginatedPostList() {
const [currentPage, setCurrentPage] = useState(1);
const [postsPerPage] = useState(3);

// Sample data
const posts: Post[] = Array.from({ length: 20 }, (_, i) => ({
  id: i + 1,
  title: `Post ${i + 1}`,
  body: `This is the content of post ${i + 1}. It contains some sample text.`
}));

// Calculate pagination
const indexOfLastPost = currentPage * postsPerPage;
const indexOfFirstPost = indexOfLastPost - postsPerPage;
const currentPosts = posts.slice(indexOfFirstPost, indexOfLastPost);
const totalPages = Math.ceil(posts.length / postsPerPage);

// Generate page numbers
const pageNumbers = [];
for (let i = 1; i <= totalPages; i++) {
  pageNumbers.push(i);
}

return (
  &lt;div&gt;
    &lt;h2&gt;Blog Posts&lt;/h2&gt;
    
    &lt;div className="posts"&gt;
      {currentPosts.map(post => (
        &lt;div key={post.id} className="post"&gt;
          &lt;h3&gt;{post.title}&lt;/h3&gt;
          &lt;p&gt;{post.body}&lt;/p&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
    
    &lt;div className="pagination"&gt;
      &lt;button 
        onClick={() => setCurrentPage(prev => Math.max(prev - 1, 1))}
        disabled={currentPage === 1}
      &gt;
        Previous
      &lt;/button&gt;
      
      {pageNumbers.map(number => (
        &lt;button
          key={number}
          onClick={() => setCurrentPage(number)}
          className={currentPage === number ? 'active' : ''}
        &gt;
          {number}
        &lt;/button&gt;
      ))}
      
      &lt;button 
        onClick={() => setCurrentPage(prev => Math.min(prev + 1, totalPages))}
        disabled={currentPage === totalPages}
      &gt;
        Next
      &lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
}</code></pre>

            <div class="callout-block callout-block-info">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-info-circle"></i> </span
                  ><!--//icon-holder-->
                  Performance Tips
                </h4>
                <p>
                  <ul>
                    <li>For very large lists, consider techniques like windowing/virtualization using libraries such as <code>react-window</code> or <code>react-virtualized</code></li>
                    <li>Memoize list items with <code>React.memo</code> if rendering is expensive</li>
                    <li>Use <code>useMemo</code> to avoid unnecessary re-computations of filtered or sorted lists</li>
                    <li>Don't create new handler functions for each list item in the render method; use curried functions or data attributes</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>

          <section class="docs-section" id="item-10-3">
            <h2 class="section-heading">List Components</h2>
            <p>
              Creating reusable and flexible list components can help keep your code DRY (Don't Repeat Yourself).
            </p>

            <h4>Generic List Component</h4>
            <pre><code class="language-typescript">import React from 'react';

interface GenericListProps&lt;T&gt; {
items: T[];
renderItem: (item: T, index: number) => React.ReactNode;
keyExtractor: (item: T, index: number) => string | number;
ListEmptyComponent?: React.ReactNode;
ListHeaderComponent?: React.ReactNode;
ListFooterComponent?: React.ReactNode;
ItemSeparatorComponent?: React.ComponentType;
}

function GenericList&lt;T&gt;({
items,
renderItem,
keyExtractor,
ListEmptyComponent,
ListHeaderComponent,
ListFooterComponent,
ItemSeparatorComponent
}: GenericListProps&lt;T&gt;) {
if (items.length === 0 && ListEmptyComponent) {
  return (
    &lt;&gt;
      {ListHeaderComponent}
      {ListEmptyComponent}
      {ListFooterComponent}
    &lt;/&gt;
  );
}

return (
  &lt;&gt;
    {ListHeaderComponent}
    {items.map((item, index) => (
      &lt;React.Fragment key={keyExtractor(item, index)}&gt;
        {index > 0 && ItemSeparatorComponent && &lt;ItemSeparatorComponent /&gt;}
        {renderItem(item, index)}
      &lt;/React.Fragment&gt;
    ))}
    {ListFooterComponent}
  &lt;/&gt;
);
}

// Example usage
function App() {
const users = [
  { id: 1, name: 'John Doe', email: 'john@example.com' },
  { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
  { id: 3, name: 'Bob Johnson', email: 'bob@example.com' }
];

const Separator = () => &lt;hr /&gt;;

return (
  &lt;div&gt;
    &lt;GenericList
      items={users}
      keyExtractor={(user) => user.id}
      renderItem={(user) => (
        &lt;div&gt;
          &lt;h3&gt;{user.name}&lt;/h3&gt;
          &lt;p&gt;{user.email}&lt;/p&gt;
        &lt;/div&gt;
      )}
      ListHeaderComponent={&lt;h2&gt;User List&lt;/h2&gt;}
      ListEmptyComponent={&lt;p&gt;No users found&lt;/p&gt;}
      ListFooterComponent={&lt;p&gt;End of list&lt;/p&gt;}
      ItemSeparatorComponent={Separator}
    /&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>List with Search and Filtering</h4>
            <pre><code class="language-typescript">import { useState, useEffect } from 'react';

interface Product {
id: number;
name: string;
category: string;
price: number;
}

interface ProductListProps {
products: Product[];
}

function ProductList({ products }: ProductListProps) {
const [searchTerm, setSearchTerm] = useState('');
const [selectedCategory, setSelectedCategory] = useState('all');
const [filteredProducts, setFilteredProducts] = useState(products);

// Get unique categories
const categories = ['all', ...Array.from(new Set(products.map(p => p.category)))];

// Update filtered products when filters change
useEffect(() => {
  let results = [...products];
  
  // Apply category filter
  if (selectedCategory !== 'all') {
    results = results.filter(product => product.category === selectedCategory);
  }
  
  // Apply search filter
  if (searchTerm.trim() !== '') {
    const searchTermLower = searchTerm.toLowerCase();
    results = results.filter(product => 
      product.name.toLowerCase().includes(searchTermLower) ||
      product.category.toLowerCase().includes(searchTermLower)
    );
  }
  
  setFilteredProducts(results);
}, [searchTerm, selectedCategory, products]);

return (
  &lt;div className="product-list-container"&gt;
    &lt;div className="filters"&gt;
      &lt;input
        type="text"
        placeholder="Search products..."
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
      /&gt;
      
      &lt;select
        value={selectedCategory}
        onChange={(e) => setSelectedCategory(e.target.value)}
      &gt;
        {categories.map(category => (
          &lt;option key={category} value={category}&gt;
            {category === 'all' ? 'All Categories' : category}
          &lt;/option&gt;
        ))}
      &lt;/select&gt;
    &lt;/div&gt;
    
    {filteredProducts.length > 0 ? (
      &lt;div className="product-grid"&gt;
        {filteredProducts.map(product => (
          &lt;div key={product.id} className="product-card"&gt;
            &lt;h3&gt;{product.name}&lt;/h3&gt;
            &lt;p className="category"&gt;{product.category}&lt;/p&gt;
            &lt;p className="price"&gt;${product.price.toFixed(2)}&lt;/p&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
    ) : (
      &lt;p className="no-results"&gt;No products found matching your criteria.&lt;/p&gt;
    )}
  &lt;/div&gt;
);
}</code></pre>

            <div class="callout-block callout-block-success">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-thumbs-up"></i> </span
                  ><!--//icon-holder-->
                  Component Composition
                </h4>
                <p>
                  For complex lists, break down your components into smaller, more focused components:
                  <ul>
                    <li>Create separate components for list items</li>
                    <li>Create separate components for filters, sorting controls, and pagination</li>
                    <li>Use composition to build the complete list UI</li>
                    <li>Consider using the "compound component" pattern for highly flexible list components</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>
        </article>

        <article class="docs-article" id="section-11">
          <header class="docs-header">
            <h1 class="docs-heading">Forms</h1>
            <section class="docs-intro">
              <p>
                Forms are a crucial part of many web applications. React provides flexible ways to handle form inputs, validation, and submission.
              </p>
            </section>
            <!--//docs-intro-->
          </header>
          <section class="docs-section" id="item-11-1">
            <h2 class="section-heading">Controlled Components</h2>
            <p>
              In React, form elements like <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, and <code>&lt;select&gt;</code> maintain their own state in the DOM. With controlled components, React state becomes the "single source of truth" for form elements.
            </p>

            <h4>Basic Controlled Form</h4>
            <pre><code class="language-typescript">import { useState, FormEvent, ChangeEvent } from 'react';

function SimpleForm() {
const [name, setName] = useState('');
const [email, setEmail] = useState('');

const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  console.log('Form submitted with:', { name, email });
  // Here you would typically send the data to a server
};

return (
  &lt;form onSubmit={handleSubmit}&gt;
    &lt;div&gt;
      &lt;label htmlFor="name"&gt;Name:&lt;/label&gt;
      &lt;input
        type="text"
        id="name"
        value={name}
        onChange={(e: ChangeEvent<HTMLInputElement>) => setName(e.target.value)}
      /&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;label htmlFor="email"&gt;Email:&lt;/label&gt;
      &lt;input
        type="email"
        id="email"
        value={email}
        onChange={(e: ChangeEvent<HTMLInputElement>) => setEmail(e.target.value)}
      /&gt;
    &lt;/div&gt;
    
    &lt;button type="submit"&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
);
}</code></pre>

            <h4>Form with Multiple Input Types</h4>
            <pre><code class="language-typescript">import { useState, FormEvent, ChangeEvent } from 'react';

interface FormData {
fullName: string;
email: string;
age: number;
gender: string;
interests: string[];
comments: string;
agreeToTerms: boolean;
}

function ComplexForm() {
const [formData, setFormData] = useState<FormData>({
  fullName: '',
  email: '',
  age: 18,
  gender: '',
  interests: [],
  comments: '',
  agreeToTerms: false
});

const handleChange = (e: ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
  const { name, value, type } = e.target as HTMLInputElement;
  
  // Handle checkboxes
  if (type === 'checkbox') {
    const { checked } = e.target as HTMLInputElement;
    setFormData(prev => ({ ...prev, [name]: checked }));
  } 
  // Handle multiple select (interests)
  else if (name === 'interests') {
    const { checked } = e.target as HTMLInputElement;
    const updatedInterests = [...formData.interests];
    
    if (checked) {
      updatedInterests.push(value);
    } else {
      const index = updatedInterests.indexOf(value);
      if (index !== -1) {
        updatedInterests.splice(index, 1);
      }
    }
    
    setFormData(prev => ({ ...prev, interests: updatedInterests }));
  }
  // Handle other input types
  else {
    setFormData(prev => ({ ...prev, [name]: value }));
  }
};

const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  console.log('Form data:', formData);
  // Here you would typically send the data to a server
};

return (
  &lt;form onSubmit={handleSubmit}&gt;
    &lt;div&gt;
      &lt;label htmlFor="fullName"&gt;Full Name:&lt;/label&gt;
      &lt;input
        type="text"
        id="fullName"
        name="fullName"
        value={formData.fullName}
        onChange={handleChange}
        required
      /&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;label htmlFor="email"&gt;Email:&lt;/label&gt;
      &lt;input
        type="email"
        id="email"
        name="email"
        value={formData.email}
        onChange={handleChange}
        required
      /&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;label htmlFor="age"&gt;Age:&lt;/label&gt;
      &lt;input
        type="number"
        id="age"
        name="age"
        min="18"
        max="120"
        value={formData.age}
        onChange={handleChange}
      /&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;label htmlFor="gender"&gt;Gender:&lt;/label&gt;
      &lt;select
        id="gender"
        name="gender"
        value={formData.gender}
        onChange={handleChange}
      &gt;
        &lt;option value=""&gt;Select Gender&lt;/option&gt;
        &lt;option value="male"&gt;Male&lt;/option&gt;
        &lt;option value="female"&gt;Female&lt;/option&gt;
        &lt;option value="other"&gt;Other&lt;/option&gt;
        &lt;option value="prefer-not-to-say"&gt;Prefer not to say&lt;/option&gt;
      &lt;/select&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;p&gt;Interests:&lt;/p&gt;
      &lt;label&gt;
        &lt;input
          type="checkbox"
          name="interests"
          value="technology"
          checked={formData.interests.includes('technology')}
          onChange={handleChange}
        /&gt;
        Technology
      &lt;/label&gt;
      &lt;label&gt;
        &lt;input
          type="checkbox"
          name="interests"
          value="sports"
          checked={formData.interests.includes('sports')}
          onChange={handleChange}
        /&gt;
        Sports
      &lt;/label&gt;
      &lt;label&gt;
        &lt;input
          type="checkbox"
          name="interests"
          value="music"
          checked={formData.interests.includes('music')}
          onChange={handleChange}
        /&gt;
        Music
      &lt;/label&gt;
      &lt;label&gt;
        &lt;input
          type="checkbox"
          name="interests"
          value="reading"
          checked={formData.interests.includes('reading')}
          onChange={handleChange}
        /&gt;
        Reading
      &lt;/label&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;label htmlFor="comments"&gt;Comments:&lt;/label&gt;
      &lt;textarea
        id="comments"
        name="comments"
        value={formData.comments}
        onChange={handleChange}
      /&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;label&gt;
        &lt;input
          type="checkbox"
          name="agreeToTerms"
          checked={formData.agreeToTerms}
          onChange={handleChange}
          required
        /&gt;
        I agree to the terms and conditions
      &lt;/label&gt;
    &lt;/div&gt;
    
    &lt;button type="submit" disabled={!formData.agreeToTerms}&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
);
}</code></pre>

            <div class="callout-block callout-block-info">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-info-circle"></i> </span
                  ><!--//icon-holder-->
                  Controlled vs Uncontrolled Components
                </h4>
                <p>
                  React supports two approaches to handling form inputs:
                  <ul>
                    <li><strong>Controlled Components</strong>: Form data is handled by React state. The value of the form element is set by React state, and changes are handled through event handlers.</li>
                    <li><strong>Uncontrolled Components</strong>: Form data is handled by the DOM itself. You can use React refs to get values from the DOM instead of using event handlers.</li>
                  </ul>
                  Controlled components offer more control and are generally recommended for most use cases.
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>

            <section class="docs-section" id="item-11-2">
              <h2 class="section-heading">Form Validation</h2>
              <p>
                Form validation is an essential part of creating user-friendly forms. React allows you to implement form validation in various ways.
              </p>

              <h4>Basic Form Validation</h4>
              <pre><code class="language-typescript">import { useState, FormEvent, ChangeEvent } from 'react';

interface FormData {
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
}

interface FormErrors {
  username?: string;
  email?: string;
  password?: string;
  confirmPassword?: string;
}

function ValidatedForm() {
  const [formData, setFormData] = useState<FormData>({
    username: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  
  const [errors, setErrors] = useState<FormErrors>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };
  
  const validateForm = (): boolean => {
    const newErrors: FormErrors = {};
    
    // Username validation
    if (!formData.username.trim()) {
      newErrors.username = 'Username is required';
    } else if (formData.username.length < 3) {
      newErrors.username = 'Username must be at least 3 characters';
    }
    
    // Email validation
    if (!formData.email.trim()) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }
    
    // Password validation
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }
    
    // Confirm password validation
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsSubmitting(true);
    
    if (validateForm()) {
      console.log('Form submitted successfully:', formData);
      // Process form data (e.g., API call)
      
      // Reset form after successful submission
      setFormData({
        username: '',
        email: '',
        password: '',
        confirmPassword: ''
      });
    } else {
      console.log('Form has errors');
    }
    
    setIsSubmitting(false);
  };
  
  return (
    &lt;form onSubmit={handleSubmit} noValidate&gt;
      &lt;div&gt;
        &lt;label htmlFor="username"&gt;Username:&lt;/label&gt;
        &lt;input
          type="text"
          id="username"
          name="username"
          value={formData.username}
          onChange={handleChange}
          className={errors.username ? 'error' : ''}
        /&gt;
        {errors.username && &lt;p className="error-message"&gt;{errors.username}&lt;/p&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email:&lt;/label&gt;
        &lt;input
          type="email"
          id="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          className={errors.email ? 'error' : ''}
        /&gt;
        {errors.email && &lt;p className="error-message"&gt;{errors.email}&lt;/p&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="password"&gt;Password:&lt;/label&gt;
        &lt;input
          type="password"
          id="password"
          name="password"
          value={formData.password}
          onChange={handleChange}
          className={errors.password ? 'error' : ''}
        /&gt;
        {errors.password && &lt;p className="error-message"&gt;{errors.password}&lt;/p&gt;}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="confirmPassword"&gt;Confirm Password:&lt;/label&gt;
        &lt;input
          type="password"
          id="confirmPassword"
          name="confirmPassword"
          value={formData.confirmPassword}
          onChange={handleChange}
          className={errors.confirmPassword ? 'error' : ''}
        /&gt;
        {errors.confirmPassword && &lt;p className="error-message"&gt;{errors.confirmPassword}&lt;/p&gt;}
      &lt;/div&gt;
      
      &lt;button type="submit" disabled={isSubmitting}&gt;
        {isSubmitting ? 'Submitting...' : 'Register'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

              <h4>Real-time Validation</h4>
              <pre><code class="language-typescript">import { useState, useEffect, ChangeEvent } from 'react';

interface FormData {
  username: string;
  email: string;
  password: string;
}

interface FormErrors {
  username?: string;
  email?: string;
  password?: string;
}

function RealtimeValidationForm() {
  const [formData, setFormData] = useState<FormData>({
    username: '',
    email: '',
    password: ''
  });
  
  const [touched, setTouched] = useState<Record<string, boolean>>({
    username: false,
    email: false,
    password: false
  });
  
  const [errors, setErrors] = useState<FormErrors>({});
  
  // Validate on data change
  useEffect(() => {
    const validateField = (name: keyof FormData, value: string) => {
      let error = '';
      
      switch (name) {
        case 'username':
          if (value.trim() === '') {
            error = 'Username is required';
          } else if (value.length < 3) {
            error = 'Username must be at least 3 characters';
          }
          break;
          
        case 'email':
          if (value.trim() === '') {
            error = 'Email is required';
          } else if (!/\S+@\S+\.\S+/.test(value)) {
            error = 'Email is invalid';
          }
          break;
          
        case 'password':
          if (value === '') {
            error = 'Password is required';
          } else if (value.length < 6) {
            error = 'Password must be at least 6 characters';
          } else if (!/\d/.test(value)) {
            error = 'Password must contain at least one number';
          } else if (!/[A-Z]/.test(value)) {
            error = 'Password must contain at least one uppercase letter';
          }
          break;
          
        default:
          break;
      }
      
      return error;
    };
    
    // Only validate touched fields
    const newErrors: FormErrors = {};
    Object.keys(touched).forEach((key) => {
      const fieldName = key as keyof FormData;
      if (touched[fieldName]) {
        const error = validateField(fieldName, formData[fieldName]);
        if (error) {
          newErrors[fieldName] = error;
        }
      }
    });
    
    setErrors(newErrors);
  }, [formData, touched]);
  
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };
  
  const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    const { name } = e.target;
    setTouched(prev => ({ ...prev, [name]: true }));
  };
  
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    
    // Mark all fields as touched
    const allTouched = Object.keys(formData).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {} as Record<string, boolean>);
    
    setTouched(allTouched);
    
    // If no errors, submit the form
    if (Object.keys(errors).length === 0) {
      console.log('Form submitted successfully:', formData);
    }
  };
  
  const isFormValid = () => {
    // Check if all fields are touched and there are no errors
    return (
      Object.keys(touched).every(key => touched[key]) && 
      Object.keys(errors).length === 0
    );
  };
  
  return (
    &lt;form onSubmit={handleSubmit} noValidate&gt;
      &lt;div&gt;
        &lt;label htmlFor="username"&gt;Username:&lt;/label&gt;
        &lt;input
          type="text"
          id="username"
          name="username"
          value={formData.username}
          onChange={handleChange}
          onBlur={handleBlur}
          className={touched.username && errors.username ? 'error' : ''}
        /&gt;
        {touched.username && errors.username && (
          &lt;p className="error-message"&gt;{errors.username}&lt;/p&gt;
        )}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email:&lt;/label&gt;
        &lt;input
          type="email"
          id="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          onBlur={handleBlur}
          className={touched.email && errors.email ? 'error' : ''}
        /&gt;
        {touched.email && errors.email && (
          &lt;p className="error-message"&gt;{errors.email}&lt;/p&gt;
        )}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="password"&gt;Password:&lt;/label&gt;
        &lt;input
          type="password"
          id="password"
          name="password"
          value={formData.password}
          onChange={handleChange}
          onBlur={handleBlur}
          className={touched.password && errors.password ? 'error' : ''}
        /&gt;
        {touched.password && errors.password && (
          &lt;p className="error-message"&gt;{errors.password}&lt;/p&gt;
        )}
      &lt;/div&gt;
      
      &lt;button type="submit" disabled={!isFormValid()}&gt;
        Register
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-warning">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-exclamation-triangle"></i> </span
                    ><!--//icon-holder-->
                    Form Libraries
                  </h4>
                  <p>
                    For complex forms, consider using form libraries like:
                    <ul>
                      <li><strong>Formik</strong>: Simplifies form handling with built-in support for validation, error messages, and form submission</li>
                      <li><strong>React Hook Form</strong>: Performance-focused form library with minimal re-renders</li>
                      <li><strong>Yup</strong>: Schema validation library that works well with both Formik and React Hook Form</li>
                      <li><strong>Zod</strong>: TypeScript-first schema validation with static type inference</li>
                    </ul>
                    These libraries can significantly reduce boilerplate code and provide more robust form handling.
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>
          </article>

          <article class="docs-article" id="section-12">
            <header class="docs-header">
              <h1 class="docs-heading">CSS Styling</h1>
              <section class="docs-intro">
                <p>
                  React offers several approaches to styling components. Each has its own advantages and use cases.
                </p>
              </section>
              <!--//docs-intro-->
            </header>
            <section class="docs-section" id="item-12-1">
              <h2 class="section-heading">Styling Options</h2>
              <p>
                React applications can be styled using various techniques, from traditional CSS to more React-specific approaches.
              </p>

              <h4>1. Inline Styles</h4>
              <pre><code class="language-typescript">function InlineStyleExample() {
  // Styles are defined as JavaScript objects
  const containerStyle = {
    backgroundColor: '#f0f0f0',
    padding: '20px',
    borderRadius: '8px',
    boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)'
  };
  
  const headingStyle = {
    color: '#333',
    fontSize: '24px',
    marginBottom: '10px'
  };
  
  const paragraphStyle = {
    color: '#666',
    lineHeight: 1.5
  };
  
  return (
    &lt;div style={containerStyle}&gt;
      &lt;h2 style={headingStyle}&gt;Inline Styles in React&lt;/h2&gt;
      &lt;p style={paragraphStyle}&gt;
        This component is styled using inline styles defined as JavaScript objects.
        Note that property names use camelCase instead of kebab-case.
      &lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>2. Regular CSS Files</h4>
              <p><strong>styles.css:</strong></p>
              <pre><code class="language-css">/* styles.css */
.container {
  background-color: #f0f0f0;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.heading {
  color: #333;
  font-size: 24px;
  margin-bottom: 10px;
}

.paragraph {
  color: #666;
  line-height: 1.5;
}</code></pre>

              <p><strong>Component:</strong></p>
              <pre><code class="language-typescript">// Import CSS file
import './styles.css';

function RegularCssExample() {
  return (
    &lt;div className="container"&gt;
      &lt;h2 className="heading"&gt;Regular CSS in React&lt;/h2&gt;
      &lt;p className="paragraph"&gt;
        This component is styled using a regular CSS file that has been imported.
        Classes are applied using the className attribute.
      &lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>3. CSS Modules</h4>
              <p><strong>styles.module.css:</strong></p>
              <pre><code class="language-css">/* styles.module.css */
.container {
  background-color: #f0f0f0;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.heading {
  color: #333;
  font-size: 24px;
  margin-bottom: 10px;
}

.paragraph {
  color: #666;
  line-height: 1.5;
}</code></pre>

              <p><strong>Component:</strong></p>
              <pre><code class="language-typescript">// Import CSS Module
import styles from './styles.module.css';

function CssModulesExample() {
  return (
    &lt;div className={styles.container}&gt;
      &lt;h2 className={styles.heading}&gt;CSS Modules in React&lt;/h2&gt;
      &lt;p className={styles.paragraph}&gt;
        This component is styled using CSS Modules. Classes are locally scoped
        and imported as a JavaScript object.
      &lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>4. Styled Components</h4>
              <pre><code class="language-typescript">import styled from 'styled-components';

// Define styled components
const Container = styled.div`
  background-color: #f0f0f0;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
`;

const Heading = styled.h2`
  color: #333;
  font-size: 24px;
  margin-bottom: 10px;
`;

const Paragraph = styled.p`
  color: #666;
  line-height: 1.5;
`;

function StyledComponentsExample() {
  return (
    &lt;Container&gt;
      &lt;Heading&gt;Styled Components in React&lt;/Heading&gt;
      &lt;Paragraph&gt;
        This component is styled using styled-components, a CSS-in-JS library.
        It allows you to write actual CSS in your JavaScript.
      &lt;/Paragraph&gt;
    &lt;/Container&gt;
  );
}</code></pre>

              <h4>5. Tailwind CSS</h4>
              <pre><code class="language-typescript">// Assuming Tailwind CSS is set up in your project
function TailwindExample() {
  return (
    &lt;div className="bg-gray-100 p-5 rounded-lg shadow-md"&gt;
      &lt;h2 className="text-gray-800 text-2xl mb-3"&gt;Tailwind CSS in React&lt;/h2&gt;
      &lt;p className="text-gray-600 leading-relaxed"&gt;
        This component is styled using Tailwind CSS utility classes.
        Tailwind provides low-level utility classes that let you build
        custom designs without leaving your HTML.
      &lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-success">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-thumbs-up"></i> </span
                    ><!--//icon-holder-->
                    Choosing the Right Styling Approach
                  </h4>
                  <p>
                    <ul>
                      <li><strong>Inline Styles</strong>: Good for dynamic styles that depend on component state, but limited (no media queries, pseudoselectors)</li>
                      <li><strong>Regular CSS</strong>: Familiar approach, but global scope can lead to naming conflicts</li>
                      <li><strong>CSS Modules</strong>: Provides local scoping without extra libraries, good for component-based styling</li>
                      <li><strong>Styled Components/Emotion</strong>: Powerful CSS-in-JS with theming support and dynamic styling</li>
                      <li><strong>Tailwind CSS</strong>: Utility-first approach with fast development and consistent design constraints</li>
                    </ul>
                    Modern React applications often use a mix of these approaches depending on the specific needs of each component.
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>

            <section class="docs-section" id="item-12-2">
              <h2 class="section-heading">Conditional Styling</h2>
              <p>
                React makes it easy to apply styles conditionally based on props, state, or other conditions.
              </p>

              <h4>Conditional Class Names</h4>
              <pre><code class="language-typescript">import { useState } from 'react';
import './Button.css';

interface ButtonProps {
  primary?: boolean;
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  children: React.ReactNode;
  onClick?: () => void;
}

function Button({ 
  primary = false, 
  size = 'medium', 
  disabled = false, 
  children,
  onClick
}: ButtonProps) {
  
  // Constructing class names conditionally
  const className = [
    'button',
    primary ? 'button-primary' : 'button-secondary',
    `button-${size}`,
    disabled ? 'button-disabled' : ''
  ].filter(Boolean).join(' ');
  
  return (
    &lt;button 
      className={className} 
      disabled={disabled}
      onClick={onClick}
    &gt;
      {children}
    &lt;/button&gt;
  );
}</code></pre>

              <h4>Conditional Styles with CSS Modules</h4>
              <pre><code class="language-typescript">import { useState } from 'react';
import styles from './Card.module.css';

interface CardProps {
  variant?: 'default' | 'highlighted' | 'warning';
  isActive?: boolean;
  children: React.ReactNode;
}

function Card({ variant = 'default', isActive = false, children }: CardProps) {
  // Using CSS Modules for conditional styling
  const cardClasses = [
    styles.card,
    styles[`card-${variant}`],
    isActive ? styles.active : ''
  ].filter(Boolean).join(' ');
  
  return (
    &lt;div className={cardClasses}&gt;
      {children}
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Dynamic Inline Styles</h4>
              <pre><code class="language-typescript">import { useState } from 'react';

interface ProgressBarProps {
  progress: number; // 0 to 100
  height?: number;
  color?: string;
}

function ProgressBar({ 
  progress, 
  height = 10, 
  color = '#4caf50' 
}: ProgressBarProps) {
  
  // Ensure progress is between 0 and 100
  const validProgress = Math.min(100, Math.max(0, progress));
  
  // Calculate color based on progress
  let dynamicColor = color;
  if (!color) {
    if (validProgress < 30) dynamicColor = '#f44336'; // Red
    else if (validProgress < 70) dynamicColor = '#ff9800'; // Orange
    else dynamicColor = '#4caf50'; // Green
  }
  
  const containerStyle: React.CSSProperties = {
    width: '100%',
    backgroundColor: '#e0e0e0',
    borderRadius: height / 2,
    height: `${height}px`,
    overflow: 'hidden'
  };
  
  const fillerStyle: React.CSSProperties = {
    height: '100%',
    width: `${validProgress}%`,
    backgroundColor: dynamicColor,
    borderRadius: 'inherit',
    transition: 'width 0.5s ease-in-out'
  };
  
  return (
    &lt;div style={containerStyle}&gt;
      &lt;div style={fillerStyle}&gt;&lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Styled Components with Props</h4>
              <pre><code class="language-typescript">import styled, { css } from 'styled-components';

interface ButtonProps {
  primary?: boolean;
  size?: 'small' | 'medium' | 'large';
  outlined?: boolean;
}

// Create a styled button with prop-based styling
const StyledButton = styled.button<ButtonProps>`
  border-radius: 4px;
  padding: 8px 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  
  /* Size variants */
  ${props => props.size === 'small' && css`
    padding: 4px 8px;
    font-size: 0.8rem;
  `}
  
  ${props => props.size === 'large' && css`
    padding: 12px 24px;
    font-size: 1.2rem;
  `}
  
  /* Primary vs Secondary */
  ${props => props.primary 
    ? css`
      background-color: #007bff;
      color: white;
      border: 2px solid #007bff;
      
      &:hover {
        background-color: #0069d9;
        border-color: #0069d9;
      }
    `
    : css`
      background-color: #6c757d;
      color: white;
      border: 2px solid #6c757d;
      
      &:hover {
        background-color: #5a6268;
        border-color: #5a6268;
      }
    `}
  
  /* Outlined variant */
  ${props => props.outlined && css`
    background-color: transparent;
    color: ${props.primary ? '#007bff' : '#6c757d'};
    
    &:hover {
      background-color: ${props.primary ? 'rgba(0, 123, 255, 0.1)' : 'rgba(108, 117, 125, 0.1)'};
    }
  `}
`;

// Usage
function ButtonExample() {
  return (
    &lt;div&gt;
      &lt;StyledButton&gt;Default Button&lt;/StyledButton&gt;
      &lt;StyledButton primary&gt;Primary Button&lt;/StyledButton&gt;
      &lt;StyledButton outlined&gt;Outlined Button&lt;/StyledButton&gt;
      &lt;StyledButton primary outlined size="large"&gt;
        Large Primary Outlined
      &lt;/StyledButton&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-info">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-info-circle"></i> </span
                    ><!--//icon-holder-->
                    Helpful Libraries
                  </h4>
                  <p>
                    <ul>
                      <li><strong>classnames</strong>: A utility for conditionally joining class names</li>
                      <li><strong>clsx</strong>: Alternative to classnames with slightly different API</li>
                      <li><strong>tailwind-merge</strong>: For merging Tailwind CSS classes without conflicts</li>
                      <li><strong>styled-system</strong>: Style props for rapid UI development with styled-components</li>
                    </ul>
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>
          </article>

          <article class="docs-article" id="section-13">
            <header class="docs-header">
              <h1 class="docs-heading">SASS Styling</h1>
              <section class="docs-intro">
                <p>
                  SASS (Syntactically Awesome Style Sheets) is a CSS preprocessor that extends CSS with features like variables, nested rules, mixins, and more. It can make your styling more maintainable and organized.
                </p>
              </section>
              <!--//docs-intro-->
            </header>
            <section class="docs-section" id="item-13-1">
              <h2 class="section-heading">Using SASS in React</h2>
              <p>
                To use SASS in a React project, you first need to install the sass package:
              </p>

              <pre><code class="language-bash">npm install sass</code></pre>

              <p>Once installed, you can create and import .scss or .sass files in your components.</p>

              <h4>Basic SASS File</h4>
              <p><strong>Button.scss:</strong></p>
              <pre><code class="language-scss">// Variables
$primary-color: #007bff;
$secondary-color: #6c757d;
$border-radius: 4px;

// Mixins
@mixin button-base {
  border-radius: $border-radius;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  padding: 8px 16px;
}

@mixin button-variant($bg-color, $text-color) {
  background-color: $bg-color;
  color: $text-color;
  border: 2px solid $bg-color;
  
  &:hover {
    background-color: darken($bg-color, 10%);
    border-color: darken($bg-color, 10%);
  }
  
  &.outlined {
    background-color: transparent;
    color: $bg-color;
    
    &:hover {
      background-color: rgba($bg-color, 0.1);
    }
  }
}

// Button styles
.button {
  @include button-base;
  
  // Variants
  &.primary {
    @include button-variant($primary-color, white);
  }
  
  &.secondary {
    @include button-variant($secondary-color, white);
  }
  
  // Sizes
  &.small {
    padding: 4px 8px;
    font-size: 0.8rem;
  }
  
  &.large {
    padding: 12px 24px;
    font-size: 1.2rem;
  }
  
  // Disabled state
  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
}</code></pre>

              <h4>Using SASS in a Component</h4>
              <pre><code class="language-typescript">import './Button.scss';

interface ButtonProps {
  variant?: 'primary' | 'secondary';
  size?: 'small' | 'medium' | 'large';
  outlined?: boolean;
  disabled?: boolean;
  children: React.ReactNode;
  onClick?: () => void;
}

function Button({
  variant = 'primary',
  size,
  outlined = false,
  disabled = false,
  children,
  onClick
}: ButtonProps) {
  // Compose class names
  const buttonClass = [
    'button',
    variant,
    size,
    outlined ? 'outlined' : ''
  ].filter(Boolean).join(' ');
  
  return (
    &lt;button 
      className={buttonClass}
      disabled={disabled}
      onClick={onClick}
    &gt;
      {children}
    &lt;/button&gt;
  );
}</code></pre>

              <h4>SASS Modules</h4>
              <p>You can also use SASS with CSS Modules by naming your files with <code>.module.scss</code> extension:</p>

              <p><strong>Card.module.scss:</strong></p>
              <pre><code class="language-scss">// Variables
$card-bg: #fff;
$card-border: #e0e0e0;
$card-shadow: rgba(0, 0, 0, 0.1);
$card-border-radius: 8px;

// Card styles
.card {
  background-color: $card-bg;
  border: 1px solid $card-border;
  border-radius: $card-border-radius;
  padding: 16px;
  box-shadow: 0 2px 4px $card-shadow;
  
  // Card variants
  &.primary {
    border-left: 4px solid #007bff;
  }
  
  &.success {
    border-left: 4px solid #28a745;
  }
  
  &.warning {
    border-left: 4px solid #ffc107;
  }
  
  &.danger {
    border-left: 4px solid #dc3545;
  }
  
  // Card elements
  .cardHeader {
    margin-bottom: 12px;
    border-bottom: 1px solid $card-border;
    padding-bottom: 8px;
    
    h3 {
      margin: 0;
      font-size: 1.25rem;
    }
  }
  
  .cardBody {
    color: #333;
  }
  
  .cardFooter {
    margin-top: 12px;
    border-top: 1px solid $card-border;
    padding-top: 8px;
    display: flex;
    justify-content: flex-end;
  }
}</code></pre>

              <p><strong>Card Component:</strong></p>
              <pre><code class="language-typescript">import styles from './Card.module.scss';

interface CardProps {
  title: string;
  variant?: 'primary' | 'success' | 'warning' | 'danger';
  children: React.ReactNode;
  footer?: React.ReactNode;
}

function Card({ title, variant, children, footer }: CardProps) {
  const cardClass = [
    styles.card,
    variant ? styles[variant] : ''
  ].filter(Boolean).join(' ');
  
  return (
    &lt;div className={cardClass}&gt;
      &lt;div className={styles.cardHeader}&gt;
        &lt;h3&gt;{title}&lt;/h3&gt;
      &lt;/div&gt;
      &lt;div className={styles.cardBody}&gt;
        {children}
      &lt;/div&gt;
      {footer && (
        &lt;div className={styles.cardFooter}&gt;
          {footer}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

              <h4>SASS with Styled Components</h4>
              <p>You can also use SASS-like syntax with styled-components:</p>

              <pre><code class="language-typescript">import styled from 'styled-components';

// Variables in JavaScript
const theme = {
  colors: {
    primary: '#007bff',
    secondary: '#6c757d',
    success: '#28a745',
    warning: '#ffc107',
    danger: '#dc3545',
    cardBg: '#fff',
    cardBorder: '#e0e0e0'
  },
  borderRadius: '8px',
  spacing: {
    sm: '8px',
    md: '16px',
    lg: '24px'
  }
};

// Styled components with SASS-like nesting
const CardContainer = styled.div`
  background-color: ${props => theme.colors.cardBg};
  border: 1px solid ${props => theme.colors.cardBorder};
  border-radius: ${props => theme.borderRadius};
  padding: ${props => theme.spacing.md};
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  
  // Variant styles
  ${props => props.variant && `
    border-left: 4px solid ${theme.colors[props.variant]};
  `}
`;

const CardHeader = styled.div`
  margin-bottom: 12px;
  border-bottom: 1px solid ${props => theme.colors.cardBorder};
  padding-bottom: ${props => theme.spacing.sm};
  
  h3 {
    margin: 0;
    font-size: 1.25rem;
  }
`;

const CardBody = styled.div`
  color: #333;
`;

const CardFooter = styled.div`
  margin-top: 12px;
  border-top: 1px solid ${props => theme.colors.cardBorder};
  padding-top: ${props => theme.spacing.sm};
  display: flex;
  justify-content: flex-end;
`;

// Card component
function Card({ 
  title, 
  variant, 
  children, 
  footer 
}: {
  title: string;
  variant?: 'primary' | 'secondary' | 'success' | 'warning' | 'danger';
  children: React.ReactNode;
  footer?: React.ReactNode;
}) {
  return (
    &lt;CardContainer variant={variant}&gt;
      &lt;CardHeader&gt;
        &lt;h3&gt;{title}&lt;/h3&gt;
      &lt;/CardHeader&gt;
      &lt;CardBody&gt;{children}&lt;/CardBody&gt;
      {footer && &lt;CardFooter&gt;{footer}&lt;/CardFooter&gt;}
    &lt;/CardContainer&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-success">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-thumbs-up"></i> </span
                    ><!--//icon-holder-->
                    SASS Benefits
                  </h4>
                  <p>
                    <ul>
                      <li><strong>Variables</strong>: Reuse values throughout your stylesheets</li>
                      <li><strong>Nesting</strong>: Write less code with nested selectors</li>
                      <li><strong>Mixins</strong>: Reuse sets of styles across selectors</li>
                      <li><strong>Functions</strong>: Perform calculations and manipulations</li>
                      <li><strong>Partials & Import</strong>: Split CSS into smaller, maintainable files</li>
                      <li><strong>Inheritance</strong>: Share properties between selectors (@extend)</li>
                      <li><strong>Operators</strong>: Perform math operations within your CSS</li>
                    </ul>
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>
          </article>

          <article class="docs-article" id="section-14">
            <header class="docs-header">
              <h1 class="docs-heading">useState Hook</h1>
              <section class="docs-intro">
                <p>
                  The <code>useState</code> hook is one of the most important React hooks. It allows functional components to manage state, which was previously only possible with class components.
                </p>
              </section>
              <!--//docs-intro-->
            </header>
            <section class="docs-section" id="item-14-1">
              <h2 class="section-heading">Basic Usage</h2>
              <p>
                The <code>useState</code> hook lets you add state to functional components. It returns an array with two elements: the current state value and a function to update it.
              </p>

              <h4>Simple Counter Example</h4>
              <pre><code class="language-typescript">import { useState } from 'react';

function Counter() {
  // Declare a state variable called "count" with initial value 0
  const [count, setCount] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Multiple State Variables</h4>
              <pre><code class="language-typescript">import { useState } from 'react';

function ProfileForm() {
  // Separate state variables for each form field
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [bio, setBio] = useState('');
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log({ name, email, bio });
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label htmlFor="name"&gt;Name:&lt;/label&gt;
        &lt;input
          id="name"
          value={name}
          onChange={(e) => setName(e.target.value)}
        /&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email:&lt;/label&gt;
        &lt;input
          id="email"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        /&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="bio"&gt;Bio:&lt;/label&gt;
        &lt;textarea
          id="bio"
          value={bio}
          onChange={(e) => setBio(e.target.value)}
        /&gt;
      &lt;/div&gt;
      
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

              <h4>Using Object State</h4>
              <pre><code class="language-typescript">import { useState } from 'react';

interface FormState {
  name: string;
  email: string;
  bio: string;
}

function ProfileFormWithObjectState() {
  // Using an object to manage all form fields
  const [formData, setFormData] = useState<FormState>({
    name: '',
    email: '',
    bio: ''
  });
  
  // Update a specific field while preserving other fields
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    
    setFormData(prevData => ({
      ...prevData,
      [name]: value
    }));
  };
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log(formData);
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label htmlFor="name"&gt;Name:&lt;/label&gt;
        &lt;input
          id="name"
          name="name"
          value={formData.name}
          onChange={handleChange}
        /&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email:&lt;/label&gt;
        &lt;input
          id="email"
          name="email"
          type="email"
          value={formData.email}
          onChange={handleChange}
        /&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="bio"&gt;Bio:&lt;/label&gt;
        &lt;textarea
          id="bio"
          name="bio"
          value={formData.bio}
          onChange={handleChange}
        /&gt;
      &lt;/div&gt;
      
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-info">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-info-circle"></i> </span
                    ><!--//icon-holder-->
                    State Updates in React
                  </h4>
                  <p>
                    <ul>
                      <li>State updates in React are <strong>not</strong> immediate; they're scheduled.</li>
                      <li>React batches state updates for performance reasons.</li>
                      <li>When you need the updated state for calculations, use the functional form of the state setter.</li>
                      <li>State updates that depend on previous state should always use the functional form: <code>setCount(prevCount => prevCount + 1)</code>.</li>
                      <li>Object and array state should be updated immutably (create new copies rather than mutating the original).</li>
                    </ul>
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>

            <section class="docs-section" id="item-14-2">
              <h2 class="section-heading">Complex State Management</h2>
              <p>
                For more complex state management scenarios, you can combine <code>useState</code> with more advanced patterns.
              </p>

              <h4>Lazy Initial State</h4>
              <pre><code class="language-typescript">import { useState } from 'react';

function ExpensiveInitialState() {
  // Expensive computation for initial state
  const calculateInitialState = () => {
    console.log('Calculating initial state...');
    // Simulate expensive computation
    return Array.from({ length: 1000 }, (_, i) => i).reduce((sum, val) => sum + val, 0);
  };
  
  // Pass a function to useState to ensure the calculation runs only once
  const [sum, setSum] = useState(() => calculateInitialState());
  
  return (
    &lt;div&gt;
      &lt;p&gt;Sum: {sum}&lt;/p&gt;
      &lt;button onClick={() => setSum(0)}&gt;Reset&lt;/button&gt;
      &lt;button onClick={() => setSum(calculateInitialState)}&gt;Recalculate&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Previous State in Updates</h4>
              <pre><code class="language-typescript">import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => {
    // Using previous state
    setCount(prevCount => prevCount + 1);
  };
  
  const incrementThree = () => {
    // These updates will be batched, but each uses the latest previous state
    increment();
    increment();
    increment();
  };
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
      &lt;button onClick={incrementThree}&gt;Increment by 3&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Working with Arrays in State</h4>
              <pre><code class="language-typescript">import { useState } from 'react';

interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

function TodoList() {
  const [todos, setTodos] = useState<Todo[]>([]);
  const [input, setInput] = useState('');
  
  const addTodo = () => {
    if (input.trim() === '') return;
    
    // Create a new array with the new todo
    setTodos(prevTodos => [
      ...prevTodos,
      {
        id: Date.now(),
        text: input,
        completed: false
      }
    ]);
    
    setInput('');
  };
  
  const toggleTodo = (id: number) => {
    // Map to a new array, updating the matching todo
    setTodos(prevTodos => 
      prevTodos.map(todo => 
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    );
  };
  
  const deleteTodo = (id: number) => {
    // Filter out the todo to be deleted
    setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id));
  };
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Todo List&lt;/h2&gt;
      &lt;div&gt;
        &lt;input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Add a new todo"
        /&gt;
        &lt;button onClick={addTodo}&gt;Add&lt;/button&gt;
      &lt;/div&gt;
      
      &lt;ul&gt;
        {todos.map(todo => (
          &lt;li key={todo.id}&gt;
            &lt;input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            /&gt;
            &lt;span style={{ 
              textDecoration: todo.completed ? 'line-through' : 'none' 
            }}&gt;
              {todo.text}
            &lt;/span&gt;
            &lt;button onClick={() => deleteTodo(todo.id)}&gt;Delete&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Working with Deep Nested Objects</h4>
              <pre><code class="language-typescript">import { useState } from 'react';

interface User {
  name: string;
  address: {
    street: string;
    city: string;
    state: string;
    zip: string;
  };
  contacts: {
    email: string;
    phone: string;
  };
}

function UserProfile() {
  const [user, setUser] = useState<User>({
    name: 'John Doe',
    address: {
      street: '123 Main St',
      city: 'Anytown',
      state: 'CA',
      zip: '12345'
    },
    contacts: {
      email: 'john@example.com',
      phone: '(555) 123-4567'
    }
  });
  
  // Update a nested field
  const updateAddress = (field: keyof User['address'], value: string) => {
    setUser(prevUser => ({
      ...prevUser,
      address: {
        ...prevUser.address,
        [field]: value
      }
    }));
  };
  
  const updateContact = (field: keyof User['contacts'], value: string) => {
    setUser(prevUser => ({
      ...prevUser,
      contacts: {
        ...prevUser.contacts,
        [field]: value
      }
    }));
  };
  
  return (
    &lt;div&gt;
      &lt;h2&gt;User Profile&lt;/h2&gt;
      
      &lt;div&gt;
        &lt;label&gt;Name:&lt;/label&gt;
        &lt;input
          value={user.name}
          onChange={(e) => setUser({...user, name: e.target.value})}
        /&gt;
      &lt;/div&gt;
      
      &lt;h3&gt;Address&lt;/h3&gt;
      &lt;div&gt;
        &lt;label&gt;Street:&lt;/label&gt;
        &lt;input
          value={user.address.street}
          onChange={(e) => updateAddress('street', e.target.value)}
        /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;City:&lt;/label&gt;
        &lt;input
          value={user.address.city}
          onChange={(e) => updateAddress('city', e.target.value)}
        /&gt;
      &lt;/div&gt;
      
      &lt;h3&gt;Contact&lt;/h3&gt;
      &lt;div&gt;
        &lt;label&gt;Email:&lt;/label&gt;
        &lt;input
          value={user.contacts.email}
          onChange={(e) => updateContact('email', e.target.value)}
        /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;Phone:&lt;/label&gt;
        &lt;input
          value={user.contacts.phone}
          onChange={(e) => updateContact('phone', e.target.value)}
        /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-warning">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-exclamation-triangle"></i> </span
                    ><!--//icon-holder-->
                    Common useState Pitfalls
                  </h4>
                  <p>
                    <ul>
                      <li><strong>Mutating State Directly</strong>: Never mutate state objects or arrays directly. Create new copies with the changes applied.</li>
                      <li><strong>Ignoring Previous State</strong>: When updates depend on previous state, always use the functional form.</li>
                      <li><strong>Overusing State</strong>: Not all values need to be in state. Consider using variables for derived values.</li>
                      <li><strong>Too Many useState Calls</strong>: If you have many related state values, consider using an object state or useReducer.</li>
                      <li><strong>Expensive Initial State</strong>: For computationally expensive initial state, use the lazy initialization pattern.</li>
                    </ul>
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>
          </article>

          <article class="docs-article" id="section-15">
            <header class="docs-header">
              <h1 class="docs-heading">useEffect Hook</h1>
              <section class="docs-intro">
                <p>
                  The <code>useEffect</code> hook lets you perform side effects in functional components. It replaces lifecycle methods like <code>componentDidMount</code>, <code>componentDidUpdate</code>, and <code>componentWillUnmount</code> from class components.
                </p>
              </section>
              <!--//docs-intro-->
            </header>
            <section class="docs-section" id="item-15-1">
              <h2 class="section-heading">Basic Usage</h2>
              <p>
                The <code>useEffect</code> hook takes two arguments: a function that contains the effect code, and an optional dependencies array.
              </p>

              <h4>Effect After Every Render</h4>
              <pre><code class="language-typescript">import { useState, useEffect } from 'react';

function DocumentTitleExample() {
  const [count, setCount] = useState(0);
  
  // Effect runs after every render
  useEffect(() => {
    // Update the document title
    document.title = `You clicked ${count} times`;
    
    // Log when effect runs
    console.log('Effect ran');
  });
  
  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Effect with Dependencies</h4>
              <pre><code class="language-typescript">import { useState, useEffect } from 'react';

function CounterWithDependencies() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  
  // Effect runs only when count changes
  useEffect(() => {
    console.log(`Count changed to ${count}`);
    document.title = `Count: ${count}`;
  }, [count]); // Only re-run the effect if count changes
  
  return (
    &lt;div&gt;
      &lt;input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Enter your name"
      /&gt;
      &lt;p&gt;Hello, {name || 'Guest'}!&lt;/p&gt;
      
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Running an Effect Only Once</h4>
              <pre><code class="language-typescript">import { useState, useEffect } from 'react';

function DataFetchingExample() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // Effect runs only once (on mount)
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        
        // Simulate API call
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        setData(result);
        setError(null);
      } catch (e) {
        setError(`Error fetching data: ${e.message}`);
        setData(null);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, []); // Empty dependency array means this effect runs once on mount
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Data Fetching Example&lt;/h2&gt;
      {loading && &lt;p&gt;Loading...&lt;/p&gt;}
      {error && &lt;p className="error"&gt;{error}&lt;/p&gt;}
      {data && (
        &lt;div&gt;
          &lt;h3&gt;{data.title}&lt;/h3&gt;
          &lt;p&gt;{data.body}&lt;/p&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-info">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-info-circle"></i> </span
                    ><!--//icon-holder-->
                    Understanding useEffect Dependencies
                  </h4>
                  <p>
                    The dependency array controls when the effect runs:
                    <ul>
                      <li><strong>No dependency array</strong>: Effect runs after every render</li>
                      <li><strong>Empty array []</strong>: Effect runs only once after the initial render (like componentDidMount)</li>
                      <li><strong>With dependencies [a, b]</strong>: Effect runs after initial render and whenever any dependency changes</li>
                    </ul>
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>

            <section class="docs-section" id="item-15-2">
              <h2 class="section-heading">Cleanup Functions</h2>
              <p>
                Effects can return a cleanup function that runs before the component unmounts or before the effect runs again.
              </p>

              <h4>Basic Cleanup Example</h4>
              <pre><code class="language-typescript">import { useState, useEffect } from 'react';

function TimerExample() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    console.log('Setting up timer...');
    
    // Set up the interval
    const intervalId = setInterval(() => {
      setSeconds(prevSeconds => prevSeconds + 1);
    }, 1000);
    
    // Return a cleanup function
    return () => {
      console.log('Cleaning up timer...');
      clearInterval(intervalId);
    };
  }, []); // Empty array means this runs once on mount
  
  return &lt;p&gt;Seconds: {seconds}&lt;/p&gt;;
}</code></pre>

              <h4>Cleanup for Event Listeners</h4>
              <pre><code class="language-typescript">import { useState, useEffect } from 'react';

function WindowResizeExample() {
  const [windowWidth, setWindowWidth] = useState(window.innerWidth);
  
  useEffect(() => {
    // Defined inside useEffect to ensure closure has access to current state
    const handleResize = () => {
      setWindowWidth(window.innerWidth);
    };
    
    // Add event listener
    window.addEventListener('resize', handleResize);
    
    // Cleanup: remove event listener
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []); // Empty array: only add/remove the event listener once
  
  return &ltp>Window width: {windowWidth}px&lt;/p>;
}</code></pre>

              <h4>Cleanup with Dynamic Dependencies</h4>
              <pre><code class="language-typescript">import { useState, useEffect } from 'react';

function UserProfileFetcher({ userId }: { userId: string }) {
  const [userData, setUserData] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    let isMounted = true; // Flag to prevent state updates if component unmounts
    
    const fetchUserData = async () => {
      setLoading(true);
      
      try {
        // Simulate API call
        const response = await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`);
        const data = await response.json();
        
        // Only update state if component is still mounted
        if (isMounted) {
          setUserData(data);
          setLoading(false);
        }
      } catch (error) {
        console.error('Error fetching user data:', error);
        
        if (isMounted) {
          setLoading(false);
        }
      }
    };
    
    fetchUserData();
    
    // Cleanup function
    return () => {
      isMounted = false; // Set flag to false when component unmounts or userId changes
    };
  }, [userId]); // Re-run effect when userId changes
  
  if (loading) return &lt;p&gt;Loading user data...&lt;/p&gt;;
  
  return (
    &lt;div&gt;
      {userData ? (
        &lt;&gt;
          &lt;h2&gt;{userData.name}&lt;/h2&gt;
          &lt;p&gt;Email: {userData.email}&lt;/p&gt;
          &lt;p&gt;Phone: {userData.phone}&lt;/p&gt;
        &lt;/&gt;
      ) : (
        &lt;p&gt;No user data found&lt;/p&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-warning">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-exclamation-triangle"></i> </span
                    ><!--//icon-holder-->
                    Common useEffect Mistakes
                  </h4>
                  <p>
                    <ul>
                      <li><strong>Missing Dependencies</strong>: React's linter warns about missing dependencies. Don't ignore these warnings.</li>
                      <li><strong>Overly Broad Dependencies</strong>: Including too many dependencies can cause unnecessary effect runs.</li>
                      <li><strong>Not Cleaning Up</strong>: Always clean up subscriptions, timers, and event listeners to prevent memory leaks.</li>
                      <li><strong>Infinite Loops</strong>: Updating state in an effect without proper dependencies can cause infinite render loops.</li>
                      <li><strong>Data Fetching</strong>: Consider using a library like React Query for data fetching to avoid common pitfalls.</li>
                    </ul>
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>

            <section class="docs-section" id="item-15-3">
              <h2 class="section-heading">Advanced useEffect Patterns</h2>
              <p>
                Beyond basic usage, there are several advanced patterns that can help solve common problems with <code>useEffect</code>.
              </p>

              <h4>Debouncing</h4>
              <pre><code class="language-typescript">import { useState, useEffect } from 'react';

function SearchComponent() {
  const [searchTerm, setSearchTerm] = useState('');
  const [debouncedTerm, setDebouncedTerm] = useState(searchTerm);
  const [results, setResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);
  
  // Update debounced value after a delay
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedTerm(searchTerm);
    }, 500); // 500ms delay
    
    // Clean up timeout
    return () => clearTimeout(timer);
  }, [searchTerm]);
  
  // Effect to search whenever debouncedTerm changes
  useEffect(() => {
    if (debouncedTerm) {
      const search = async () => {
        setIsSearching(true);
        
        try {
          // Simulate API call
          const response = await fetch(
            `https://jsonplaceholder.typicode.com/posts?q=${debouncedTerm}`
          );
          const data = await response.json();
          setResults(data);
        } catch (error) {
          console.error('Search error:', error);
        } finally {
          setIsSearching(false);
        }
      };
      
      search();
    } else {
      setResults([]);
    }
  }, [debouncedTerm]);
  
  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      /&gt;
      
      {isSearching && &lt;p&gt;Searching...&lt;/p&gt;}
      
      &lt;ul&gt;
        {results.map((item) => (
          &lt;li key={item.id}&gt;{item.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Handling Race Conditions</h4>
              <pre><code class="language-typescript">import { useState, useEffect } from 'react';

function UserPosts({ userId }: { userId: string }) {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Create an AbortController for this effect instance
    const controller = new AbortController();
    const signal = controller.signal;
    
    async function fetchPosts() {
      setLoading(true);
      
      try {
        // Use the signal in fetch
        const response = await fetch(
          `https://jsonplaceholder.typicode.com/posts?userId=${userId}`,
          { signal }
        );
        
        // If fetch was aborted, this will throw an AbortError
        const data = await response.json();
        
        // Only update state if the request wasn't aborted
        if (!signal.aborted) {
          setPosts(data);
          setLoading(false);
        }
      } catch (error) {
        // Handle errors, excluding AbortError
        if (error.name !== 'AbortError') {
          console.error('Fetch error:', error);
          setLoading(false);
        }
      }
    }
    
    fetchPosts();
    
    // Cleanup: abort the fetch when component unmounts or userId changes
    return () => {
      controller.abort();
    };
  }, [userId]);
  
  if (loading) return &lt;p&gt;Loading posts...&lt;/p&gt;;
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Posts by User {userId}&lt;/h2&gt;
      {posts.length > 0 ? (
        &lt;ul&gt;
          {posts.map(post => (
            &lt;li key={post.id}&gt;
              &lt;h3&gt;{post.title}&lt;/h3&gt;
              &lt;p&gt;{post.body}&lt;/p&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      ) : (
        &lt;p&gt;No posts found.&lt;/p&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Implementing Polling</h4>
              <pre><code class="language-typescript">import { useState, useEffect } from 'react';

function LiveStockPrices() {
  const [prices, setPrices] = useState({});
  const [isPolling, setIsPolling] = useState(true);
  const [pollingInterval, setPollingInterval] = useState(5000); // 5 seconds
  
  useEffect(() => {
    if (!isPolling) return;
    
    // Function to fetch the latest data
    const fetchLatestPrices = async () => {
      try {
        // Simulate API call
        const response = await fetch('https://api.example.com/stocks');
        const data = await response.json();
        setPrices(data);
      } catch (error) {
        console.error('Failed to fetch stock prices:', error);
      }
    };
    
    // Fetch immediately on mount
    fetchLatestPrices();
    
    // Set up polling interval
    const intervalId = setInterval(fetchLatestPrices, pollingInterval);
    
    // Clean up polling on unmount or when polling is turned off
    return () => {
      clearInterval(intervalId);
    };
  }, [isPolling, pollingInterval]);
  
  // Toggle polling on/off
  const togglePolling = () => {
    setIsPolling(prev => !prev);
  };
  
  // Change polling interval
  const handleIntervalChange = (e) => {
    setPollingInterval(Number(e.target.value) * 1000);
  };
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Live Stock Prices&lt;/h2&gt;
      
      &lt;div&gt;
        &lt;label&gt;
          &lt;input
            type="checkbox"
            checked={isPolling}
            onChange={togglePolling}
          /&gt;
          Enable live updates
        &lt;/label&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label&gt;
          Update every:
          &lt;select value={pollingInterval / 1000} onChange={handleIntervalChange}&gt;
            &lt;option value="1"&gt;1 second&lt;/option&gt;
            &lt;option value="5"&gt;5 seconds&lt;/option&gt;
            &lt;option value="10"&gt;10 seconds&lt;/option&gt;
            &lt;option value="30"&gt;30 seconds&lt;/option&gt;
          &lt;/select&gt;
        &lt;/label&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        {Object.keys(prices).length > 0 ? (
          &lt;ul&gt;
            {Object.entries(prices).map(([symbol, price]) => (
              &lt;li key={symbol}&gt;
                {symbol}: ${price}
              &lt;/li&gt;
            ))}
          &lt;/ul&gt;
        ) : (
          &lt;p&gt;Loading stock prices...&lt;/p&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-success">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-thumbs-up"></i> </span
                    ><!--//icon-holder-->
                    Custom Hooks for Effects
                  </h4>
                  <p>
                    Consider extracting complex effect logic into custom hooks for reusability and cleaner components:
                    <pre><code class="language-typescript">// Custom hook for debounced value
function useDebounce(value: string, delay: number) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);
  
  return debouncedValue;
}

// Custom hook for data fetching
function useFetch(url: string) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    let isMounted = true;
    const controller = new AbortController();
    
    async function fetchData() {
      try {
        setLoading(true);
        const response = await fetch(url, { signal: controller.signal });
        const result = await response.json();
        
        if (isMounted) {
          setData(result);
          setError(null);
        }
      } catch (error) {
        if (isMounted && error.name !== 'AbortError') {
          setError('An error occurred: ' + error.message);
          setData(null);
        }
      } finally {
        if (isMounted) {
          setLoading(false);
        }
      }
    }
    
    fetchData();
    
    return () => {
      isMounted = false;
      controller.abort();
    };
  }, [url]);
  
  return { data, loading, error };
}</code></pre>
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>
          </article>

          <article class="docs-article" id="section-16">
            <header class="docs-header">
              <h1 class="docs-heading">useContext Hook</h1>
              <section class="docs-intro">
                <p>
                  The <code>useContext</code> hook provides a way to share data between components without having to explicitly pass props through every level of the component tree. It's perfect for global state or theme data that many components need access to.
                </p>
              </section>
              <!--//docs-intro-->
            </header>
            <section class="docs-section" id="item-16-1">
              <h2 class="section-heading">Creating and Using Context</h2>
              <p>
                Context consists of three parts: the context object, a provider, and consumers.
              </p>

              <h4>Basic Context Example</h4>
              <pre><code class="language-typescript">// ThemeContext.tsx
import { createContext, useState, ReactNode } from 'react';

// Define the context shape
interface ThemeContextType {
  darkMode: boolean;
  toggleTheme: () => void;
}

// Create context with a default value
export const ThemeContext = createContext<ThemeContextType>({
  darkMode: false,
  toggleTheme: () => {}
});

// Create a provider component
interface ThemeProviderProps {
  children: ReactNode;
}

export function ThemeProvider({ children }: ThemeProviderProps) {
  const [darkMode, setDarkMode] = useState(false);
  
  const toggleTheme = () => {
    setDarkMode(prevMode => !prevMode);
  };
  
  // The value passed to the provider is what will be available to consumers
  return (
    &lt;ThemeContext.Provider value={{ darkMode, toggleTheme }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}</code></pre>

              <h4>Using Context in Components</h4>
              <pre><code class="language-typescript">// App.tsx
import { ThemeProvider } from './ThemeContext';
import Header from './Header';
import Content from './Content';

function App() {
  return (
    &lt;ThemeProvider&gt;
      &lt;div className="app"&gt;
        &lt;Header /&gt;
        &lt;Content /&gt;
      &lt;/div&gt;
    &lt;/ThemeProvider&gt;
  );
}

// Header.tsx
import { useContext } from 'react';
import { ThemeContext } from './ThemeContext';

function Header() {
  // Consume the context using useContext hook
  const { darkMode, toggleTheme } = useContext(ThemeContext);
  
  return (
    &lt;header className={darkMode ? 'header-dark' : 'header-light'}&gt;
      &lt;h1&gt;My App&lt;/h1&gt;
      &lt;button onClick={toggleTheme}&gt;
        {darkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'}
      &lt;/button&gt;
    &lt;/header&gt;
  );
}

// Content.tsx
import { useContext } from 'react';
import { ThemeContext } from './ThemeContext';

function Content() {
  // Consume the context in a deeply nested component
  const { darkMode } = useContext(ThemeContext);
  
  return (
    &lt;main className={darkMode ? 'content-dark' : 'content-light'}&gt;
      &lt;p&gt;This content adapts to the current theme.&lt;/p&gt;
    &lt;/main&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-info">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-info-circle"></i> </span
                    ><!--//icon-holder-->
                    Context Consumer Alternative
                  </h4>
                  <p>
                    Before hooks, you had to use the Context.Consumer component. While this approach is less common now, you might still see it in legacy code:
                    <pre><code class="language-tsx">// Using Context.Consumer (pre-hooks approach)
function Header() {
  return (
    &lt;ThemeContext.Consumer&gt;
      {({ darkMode, toggleTheme }) => (
        &lt;header className={darkMode ? 'header-dark' : 'header-light'}&gt;
          &lt;h1&gt;My App&lt;/h1&gt;
          &lt;button onClick={toggleTheme}&gt;
            {darkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'}
          &lt;/button&gt;
        &lt;/header&gt;
      )}
    &lt;/ThemeContext.Consumer&gt;
  );
}</code></pre>
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>

            <section class="docs-section" id="item-16-2">
              <h2 class="section-heading">Advanced Context Patterns</h2>
              <p>
                For more complex applications, you can implement advanced context patterns to better manage state.
              </p>

              <h4>Multiple Contexts</h4>
              <pre><code class="language-typescript">// UserContext.tsx
import { createContext, useState, ReactNode } from 'react';

interface User {
  id: number;
  username: string;
  email: string;
}

interface UserContextType {
  user: User | null;
  loading: boolean;
  login: (username: string, password: string) => Promise<void>;
  logout: () => void;
}

export const UserContext = createContext<UserContextType>({
  user: null,
  loading: false,
  login: async () => {},
  logout: () => {}
});

export function UserProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(false);
  
  const login = async (username: string, password: string) => {
    setLoading(true);
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Mock successful login
      setUser({
        id: 1,
        username,
        email: `${username}@example.com`
      });
    } catch (error) {
      console.error('Login failed:', error);
    } finally {
      setLoading(false);
    }
  };
  
  const logout = () => {
    setUser(null);
  };
  
  return (
    &lt;UserContext.Provider value={{ user, loading, login, logout }}&gt;
      {children}
    &lt;/UserContext.Provider&gt;
  );
}

// App.tsx
import { ThemeProvider } from './ThemeContext';
import { UserProvider } from './UserContext';

function App() {
  return (
    &lt;ThemeProvider&gt;
      &lt;UserProvider&gt;
        &lt;div className="app"&gt;
          {/* App contents */}
        &lt;/div&gt;
      &lt;/UserProvider&gt;
    &lt;/ThemeProvider&gt;
  );
}</code></pre>

              <h4>Context with Reducer</h4>
              <pre><code class="language-typescript">import { createContext, useReducer, ReactNode, useContext } from 'react';

// Define state type
interface CartState {
  items: CartItem[];
  total: number;
}

interface CartItem {
  id: number;
  name: string;
  price: number;
  quantity: number;
}

// Define action types
type CartAction =
  | { type: 'ADD_ITEM'; payload: { id: number; name: string; price: number } }
  | { type: 'REMOVE_ITEM'; payload: { id: number } }
  | { type: 'UPDATE_QUANTITY'; payload: { id: number; quantity: number } }
  | { type: 'CLEAR_CART' };

// Create initial state
const initialState: CartState = {
  items: [],
  total: 0
};

// Create reducer function
function cartReducer(state: CartState, action: CartAction): CartState {
  switch (action.type) {
    case 'ADD_ITEM': {
      const existingItem = state.items.find(item => item.id === action.payload.id);
      
      if (existingItem) {
        // Update quantity if item already exists
        const updatedItems = state.items.map(item =>
          item.id === action.payload.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        );
        
        return {
          items: updatedItems,
          total: state.total + action.payload.price
        };
      } else {
        // Add new item
        const newItem: CartItem = {
          id: action.payload.id,
          name: action.payload.name,
          price: action.payload.price,
          quantity: 1
        };
        
        return {
          items: [...state.items, newItem],
          total: state.total + action.payload.price
        };
      }
    }
    
    case 'REMOVE_ITEM': {
      const itemToRemove = state.items.find(item => item.id === action.payload.id);
      
      if (!itemToRemove) return state;
      
      return {
        items: state.items.filter(item => item.id !== action.payload.id),
        total: state.total - (itemToRemove.price * itemToRemove.quantity)
      };
    }
    
    case 'UPDATE_QUANTITY': {
      const item = state.items.find(item => item.id === action.payload.id);
      
      if (!item) return state;
      
      const priceDifference = item.price * (action.payload.quantity - item.quantity);
      
      const updatedItems = state.items.map(item =>
        item.id === action.payload.id
          ? { ...item, quantity: action.payload.quantity }
          : item
      );
      
      return {
        items: updatedItems,
        total: state.total + priceDifference
      };
    }
    
    case 'CLEAR_CART':
      return initialState;
    
    default:
      return state;
  }
}

// Create context
interface CartContextType {
  state: CartState;
  addItem: (id: number, name: string, price: number) => void;
  removeItem: (id: number) => void;
  updateQuantity: (id: number, quantity: number) => void;
  clearCart: () => void;
}

const CartContext = createContext<CartContextType | undefined>(undefined);

// Create provider
export function CartProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(cartReducer, initialState);
  
  const addItem = (id: number, name: string, price: number) => {
    dispatch({ type: 'ADD_ITEM', payload: { id, name, price } });
  };
  
  const removeItem = (id: number) => {
    dispatch({ type: 'REMOVE_ITEM', payload: { id } });
  };
  
  const updateQuantity = (id: number, quantity: number) => {
    if (quantity <= 0) {
      removeItem(id);
    } else {
      dispatch({ type: 'UPDATE_QUANTITY', payload: { id, quantity } });
    }
  };
  
  const clearCart = () => {
    dispatch({ type: 'CLEAR_CART' });
  };
  
  return (
    &lt;CartContext.Provider value={{ state, addItem, removeItem, updateQuantity, clearCart }}&gt;
      {children}
    &lt;/CartContext.Provider&gt;
  );
}

// Custom hook to use cart context
export function useCart() {
  const context = useContext(CartContext);
  
  if (context === undefined) {
    throw new Error('useCart must be used within a CartProvider');
  }
  
  return context;
}</code></pre>

              <h4>Custom Hooks for Context</h4>
              <pre><code class="language-typescript">// ThemeContext with custom hook
import { createContext, useContext, useState, ReactNode } from 'react';

interface ThemeContextType {
  darkMode: boolean;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [darkMode, setDarkMode] = useState(false);
  
  const toggleTheme = () => {
    setDarkMode(prev => !prev);
  };
  
  return (
    &lt;ThemeContext.Provider value={{ darkMode, toggleTheme }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// Custom hook for accessing theme context
export function useTheme() {
  const context = useContext(ThemeContext);
  
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  
  return context;
}

// Usage in components
function Header() {
  const { darkMode, toggleTheme } = useTheme();
  
  return (
    &lt;header className={darkMode ? 'dark' : 'light'}&gt;
      &lt;button onClick={toggleTheme}&gt;Toggle Theme&lt;/button&gt;
    &lt;/header&gt;
  );
}</code></pre>

              <div class="callout-block callout-block-warning">
                <div class="content">
                  <h4 class="callout-title">
                    <span class="callout-icon-holder me-1">
                      <i class="fas fa-exclamation-triangle"></i> </span
                    ><!--//icon-holder-->
                    Context Performance Considerations
                  </h4>
                  <p>
                    <ul>
                      <li><strong>Re-renders</strong>: When context value changes, all components that use that context will re-render, even if they only use part of the context.</li>
                      <li><strong>Splitting Contexts</strong>: For better performance, split contexts by functionality rather than having one large context.</li>
                      <li><strong>Memoization</strong>: Use <code>React.memo</code>, <code>useMemo</code>, and <code>useCallback</code> to prevent unnecessary re-renders.</li>
                      <li><strong>Value Stability</strong>: Make sure context values don't change unnecessarily.</li>
                    </ul>
                  </p>
                </div>
                <!--//content-->
              </div>
              <!--//callout-block-->
            </section>
          </article>

          <article class="docs-article" id="section-17">
            <header class="docs-header">
              <h1 class="docs-heading">useRef Hook</h1>
              <section class="docs-intro">
                <p>
                  The <code>useRef</code> hook provides a way to create a mutable reference that persists across renders. It's commonly used to access DOM elements directly, but can also store any mutable value that shouldn't trigger re-renders when changed.
                </p>
              </section>
              <!--//docs-intro-->
            </header>
            <section class="docs-section" id="item-17-1">
              <h2 class="section-heading">Basic Usage</h2>
              <p>
                The <code>useRef</code> hook returns a mutable ref object with a <code>.current</code> property that can be initialized and updated.
              </p>

              <h4>DOM References</h4>
              <pre><code class="language-typescript">import { useRef, useEffect } from 'react';

function TextInputWithFocus() {
  // Create a ref - initializing with null
  const inputRef = useRef<HTMLInputElement>(null);
  
  // Focus the input after component mounts
  useEffect(() => {
    // Current will be the DOM element after render
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, []);
  
  return (
    &lt;div&gt;
      &lt;input ref={inputRef} type="text" placeholder="This input will be focused" /&gt;
    &lt;/div&gt;
  );
}</code></pre>

              <h4>Storing Mutable Values</h4>
              <pre><code class="language-typescript">import { useRef, useState, useEffect } from 'react';

function IntervalCounter() {
  const [count, setCount] = useState(0);
  
  // Use ref to store the interval ID
  const intervalRef = useRef<number | null>(null);
  
  // Start timer
  const startTimer = () => {
    if (intervalRef.current !== null) return;
    
    intervalRef.current = window.setInterval(() => {
      setCount(prevCount => prevCount + 1);
    }, 1000);
  };
  
  // Stop timer
  const stopTimer = () => {
    if (intervalRef.current === null) return;
    
    clearInterval(intervalRef.current);
    intervalRef.current = null;
  };
  
  // Clean up interval on unmount
  useEffect(() => {
    return () => {
      if (intervalRef.current !== null) {
        clearInterval(intervalRef.current);
    }
  };
}, []);

return (
  &lt;div&gt;
    &lt;p&gt;Count: {count}&lt;/p&gt;
    &lt;button onClick={startTimer}&gt;Start&lt;/button&gt;
    &lt;button onClick={stopTimer}&gt;Stop&lt;/button&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Tracking Previous Values</h4>
            <pre><code class="language-typescript">import { useRef, useState, useEffect } from 'react';

function Counter() {
const [count, setCount] = useState(0);

// Use ref to track previous value
const prevCountRef = useRef<number>(0);

// Update ref after render
useEffect(() => {
  prevCountRef.current = count;
}, [count]);

return (
  &lt;div&gt;
    &lt;p&gt;Current count: {count}&lt;/p&gt;
    &lt;p&gt;Previous count: {prevCountRef.current}&lt;/p&gt;
    &lt;button onClick={() => setCount(count + 1)}&gt;Increment&lt;/button&gt;
  &lt;/div&gt;
);
}</code></pre>

            <div class="callout-block callout-block-info">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-info-circle"></i> </span
                  ><!--//icon-holder-->
                  useRef vs useState
                </h4>
                <p>
                  <ul>
                    <li><strong>useRef</strong>: Changing <code>ref.current</code> value does <em>not</em> cause a re-render</li>
                    <li><strong>useState</strong>: Changing state with the setter function <em>does</em> cause a re-render</li>
                    <li>Use <code>useRef</code> for values that need to persist between renders without triggering updates</li>
                    <li>Use <code>useState</code> for values that should cause the component to re-render when changed</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>

          <section class="docs-section" id="item-17-2">
            <h2 class="section-heading">Advanced useRef Patterns</h2>
            <p>
              Beyond basic DOM access, <code>useRef</code> enables several advanced patterns in React applications.
            </p>

            <h4>Measuring Element Dimensions</h4>
            <pre><code class="language-typescript">import { useRef, useState, useEffect } from 'react';

function MeasureElement() {
const elementRef = useRef<HTMLDivElement>(null);
const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

// Set up measurement after render
useEffect(() => {
  if (!elementRef.current) return;
  
  // Initial measurement
  measureElement();
  
  // Measure on resize
  const handleResize = () => {
    measureElement();
  };
  
  window.addEventListener('resize', handleResize);
  
  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []);

const measureElement = () => {
  if (elementRef.current) {
    const { width, height } = elementRef.current.getBoundingClientRect();
    setDimensions({ width, height });
  }
};

return (
  &lt;div&gt;
    &lt;div
      ref={elementRef}
      style={{
        width: '50%',
        padding: '20px',
        margin: '20px',
        border: '1px solid black',
        background: '#f0f0f0'
      }}
    &gt;
      This element is being measured
    &lt;/div&gt;
    
    &lt;p&gt;
      Element width: {dimensions.width.toFixed(2)}px, 
      height: {dimensions.height.toFixed(2)}px
    &lt;/p&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Implementing Forwarded Refs</h4>
            <pre><code class="language-typescript">import { forwardRef, useRef, useImperativeHandle, ForwardedRef } from 'react';

// Define the methods you want to expose
interface CustomInputHandle {
focus: () => void;
clear: () => void;
setValue: (value: string) => void;
}

interface CustomInputProps {
label: string;
defaultValue?: string;
}

// forwardRef lets this component receive a ref from its parent
const CustomInput = forwardRef(function CustomInput(
props: CustomInputProps,
ref: ForwardedRef<CustomInputHandle>
) {
// Internal ref for the input element
const inputRef = useRef<HTMLInputElement>(null);

// Expose a limited API to the parent component
useImperativeHandle(ref, () => ({
  focus: () => {
    inputRef.current?.focus();
  },
  clear: () => {
    if (inputRef.current) {
      inputRef.current.value = '';
    }
  },
  setValue: (value: string) => {
    if (inputRef.current) {
      inputRef.current.value = value;
    }
  }
}));

return (
  &lt;div&gt;
    &lt;label&gt;{props.label}&lt;/label&gt;
    &lt;input
      ref={inputRef}
      type="text"
      defaultValue={props.defaultValue}
    /&gt;
  &lt;/div&gt;
);
});

// Parent component using the forwarded ref
function FormWithRefs() {
// Create a ref for the custom input
const inputRef = useRef<CustomInputHandle>(null);

const handleFocus = () => {
  inputRef.current?.focus();
};

const handleClear = () => {
  inputRef.current?.clear();
};

const handleSetValue = () => {
  inputRef.current?.setValue('Hello from parent!');
};

return (
  &lt;div&gt;
    &lt;CustomInput ref={inputRef} label="Enter text:" /&gt;
    
    &lt;div&gt;
      &lt;button onClick={handleFocus}&gt;Focus&lt;/button&gt;
      &lt;button onClick={handleClear}&gt;Clear&lt;/button&gt;
      &lt;button onClick={handleSetValue}&gt;Set Value&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Creating a Scroll Position Hook</h4>
            <pre><code class="language-typescript">import { useRef, useState, useEffect } from 'react';

// Custom hook for tracking scroll position
function useScrollPosition() {
const [scrollPosition, setScrollPosition] = useState({ x: 0, y: 0 });
const ticking = useRef(false);

useEffect(() => {
  const handleScroll = () => {
    if (!ticking.current) {
      // Use requestAnimationFrame to limit updates for performance
      window.requestAnimationFrame(() => {
        setScrollPosition({
          x: window.scrollX,
          y: window.scrollY
        });
        ticking.current = false;
      });
      
      ticking.current = true;
    }
  };
  
  window.addEventListener('scroll', handleScroll);
  
  return () => {
    window.removeEventListener('scroll', handleScroll);
  };
}, []);

return scrollPosition;
}

// Usage example
function ScrollTracker() {
const { x, y } = useScrollPosition();

return (
  &lt;div style={{
    position: 'fixed',
    bottom: 20,
    right: 20,
    padding: '8px 12px',
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    color: 'white',
    borderRadius: 4
  }}&gt;
    Scroll X: {Math.round(x)}px, Y: {Math.round(y)}px
  &lt;/div&gt;
);
}</code></pre>

            <div class="callout-block callout-block-warning">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-exclamation-triangle"></i> </span
                  ><!--//icon-holder-->
                  useRef Gotchas
                </h4>
                <p>
                  <ul>
                    <li><strong>Initialization Timing</strong>: The <code>ref.current</code> value is <code>null</code> until the component mounts</li>
                    <li><strong>No Render Triggering</strong>: Changing <code>ref.current</code> won't trigger re-renders, so UI changes won't be reflected</li>
                    <li><strong>Type Safety</strong>: Always provide proper TypeScript types when using <code>useRef</code></li>
                    <li><strong>Stale Closures</strong>: Ref values inside callbacks may be stale if not handled properly</li>
                    <li><strong>Refs in Custom Hooks</strong>: Refs should often be created in the component, not inside custom hooks, unless the hook explicitly manages that ref</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>
        </article>

        <article class="docs-article" id="section-18">
          <header class="docs-header">
            <h1 class="docs-heading">useReducer Hook</h1>
            <section class="docs-intro">
              <p>
                The <code>useReducer</code> hook is an alternative to <code>useState</code> for managing complex state logic. It follows the reducer pattern popular in Redux, where state updates are handled by a reducer function.
              </p>
            </section>
            <!--//docs-intro-->
          </header>
          <section class="docs-section" id="item-18-1">
            <h2 class="section-heading">Basic Usage</h2>
            <p>
              The <code>useReducer</code> hook takes a reducer function and initial state, returning the current state and a dispatch function.
            </p>

            <h4>Simple Counter Example</h4>
            <pre><code class="language-typescript">import { useReducer } from 'react';

// Define action types
type CounterAction = 
| { type: 'INCREMENT' }
| { type: 'DECREMENT' }
| { type: 'RESET' }
| { type: 'SET'; payload: number };

// Initial state
const initialState = { count: 0 };

// Reducer function
function counterReducer(state: { count: number }, action: CounterAction) {
switch (action.type) {
  case 'INCREMENT':
    return { count: state.count + 1 };
  case 'DECREMENT':
    return { count: state.count - 1 };
  case 'RESET':
    return { count: 0 };
  case 'SET':
    return { count: action.payload };
  default:
    return state;
}
}

function Counter() {
// useReducer returns current state and dispatch function
const [state, dispatch] = useReducer(counterReducer, initialState);

return (
  &lt;div&gt;
    &lt;h2&gt;Count: {state.count}&lt;/h2&gt;
    &lt;button onClick={() => dispatch({ type: 'INCREMENT' })}&gt;+&lt;/button&gt;
    &lt;button onClick={() => dispatch({ type: 'DECREMENT' })}&gt;-&lt;/button&gt;
    &lt;button onClick={() => dispatch({ type: 'RESET' })}&gt;Reset&lt;/button&gt;
    &lt;button onClick={() => dispatch({ type: 'SET', payload: 10 })}&gt;Set to 10&lt;/button&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Lazy Initialization</h4>
            <pre><code class="language-typescript">import { useReducer } from 'react';

// Initialize state from local storage
function init(initialCount: number) {
try {
  // Try to get saved count from localStorage
  const savedCount = localStorage.getItem('count');
  return { count: savedCount ? parseInt(savedCount, 10) : initialCount };
} catch {
  // Fallback to initial count if localStorage fails
  return { count: initialCount };
}
}

function counterReducer(state: { count: number }, action: CounterAction) {
// ... same as before
}

function PersistentCounter() {
// The third argument to useReducer is the initialization function
const [state, dispatch] = useReducer(counterReducer, 0, init);

// Save count to localStorage when it changes
useEffect(() => {
  localStorage.setItem('count', state.count.toString());
}, [state.count]);

// ... rest of component
}</code></pre>

            <div class="callout-block callout-block-info">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-info-circle"></i> </span
                  ><!--//icon-holder-->
                  useState vs useReducer
                </h4>
                <p>
                  <ul>
                    <li><strong>useState</strong>: Good for simple independent state values</li>
                    <li><strong>useReducer</strong>: Better for complex state logic where next state depends on previous state, or where multiple sub-values are related</li>
                  </ul>
                  <strong>Use useReducer when:</strong>
                  <ul>
                    <li>State involves complex objects or arrays</li>
                    <li>State transitions are numerous or complex</li>
                    <li>State logic involves multiple sub-values that change together</li>
                    <li>You need more predictable state transitions</li>
                    <li>You need to pass state update logic to deeply nested components (dispatch can be passed instead of multiple callbacks)</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>

          <section class="docs-section" id="item-18-2">
            <h2 class="section-heading">Complex State Management</h2>
            <p>
              The <code>useReducer</code> hook really shines when managing complex state with multiple fields and operations.
            </p>

            <h4>Todo List Example</h4>
            <pre><code class="language-typescript">import { useReducer, useState } from 'react';

// Define todo item interface
interface Todo {
id: number;
text: string;
completed: boolean;
}

// Define state interface
interface TodoState {
todos: Todo[];
filter: 'all' | 'active' | 'completed';
}

// Define action types
type TodoAction =
| { type: 'ADD_TODO'; payload: string }
| { type: 'TOGGLE_TODO'; payload: number }
| { type: 'DELETE_TODO'; payload: number }
| { type: 'SET_FILTER'; payload: 'all' | 'active' | 'completed' }
| { type: 'CLEAR_COMPLETED' };

// Initial state
const initialState: TodoState = {
todos: [],
filter: 'all'
};

// Reducer function
function todoReducer(state: TodoState, action: TodoAction): TodoState {
switch (action.type) {
  case 'ADD_TODO':
    return {
      ...state,
      todos: [
        ...state.todos,
        {
          id: Date.now(),
          text: action.payload,
          completed: false
        }
      ]
    };
    
  case 'TOGGLE_TODO':
    return {
      ...state,
      todos: state.todos.map(todo =>
        todo.id === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    };
    
  case 'DELETE_TODO':
    return {
      ...state,
      todos: state.todos.filter(todo => todo.id !== action.payload)
    };
    
  case 'SET_FILTER':
    return {
      ...state,
      filter: action.payload
    };
    
  case 'CLEAR_COMPLETED':
    return {
      ...state,
      todos: state.todos.filter(todo => !todo.completed)
    };
    
  default:
    return state;
}
}

function TodoApp() {
const [state, dispatch] = useReducer(todoReducer, initialState);
const [newTodo, setNewTodo] = useState('');

// Add a new todo
const handleAddTodo = (e: React.FormEvent) => {
  e.preventDefault();
  if (newTodo.trim()) {
    dispatch({ type: 'ADD_TODO', payload: newTodo.trim() });
    setNewTodo('');
  }
};

// Get filtered todos
const getFilteredTodos = () => {
  switch (state.filter) {
    case 'active':
      return state.todos.filter(todo => !todo.completed);
    case 'completed':
      return state.todos.filter(todo => todo.completed);
    default:
      return state.todos;
  }
};

const filteredTodos = getFilteredTodos();

return (
  &lt;div className="todo-app"&gt;
    &lt;h1&gt;Todo List&lt;/h1&gt;
    
    &lt;form onSubmit={handleAddTodo}&gt;
      &lt;input
        type="text"
        value={newTodo}
        onChange={(e) => setNewTodo(e.target.value)}
        placeholder="Add a new todo..."
      /&gt;
      &lt;button type="submit"&gt;Add&lt;/button&gt;
    &lt;/form&gt;
    
    &lt;div className="filters"&gt;
      &lt;button
        onClick={() => dispatch({ type: 'SET_FILTER', payload: 'all' })}
        className={state.filter === 'all' ? 'active' : ''}
      &gt;
        All
      &lt;/button&gt;
      &lt;button
        onClick={() => dispatch({ type: 'SET_FILTER', payload: 'active' })}
        className={state.filter === 'active' ? 'active' : ''}
      &gt;
        Active
      &lt;/button&gt;
      &lt;button
        onClick={() => dispatch({ type: 'SET_FILTER', payload: 'completed' })}
        className={state.filter === 'completed' ? 'active' : ''}
      &gt;
        Completed
      &lt;/button&gt;
      &lt;button onClick={() => dispatch({ type: 'CLEAR_COMPLETED' })}&gt;
        Clear Completed
      &lt;/button&gt;
    &lt;/div&gt;
    
    &lt;ul className="todo-list"&gt;
      {filteredTodos.length === 0 ? (
        &lt;li className="empty-message"&gt;No todos found&lt;/li&gt;
      ) : (
        filteredTodos.map(todo => (
          &lt;li key={todo.id} className={todo.completed ? 'completed' : ''}&gt;
            &lt;input
              type="checkbox"
              checked={todo.completed}
              onChange={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })}
            /&gt;
            &lt;span&gt;{todo.text}&lt;/span&gt;
            &lt;button
              onClick={() => dispatch({ type: 'DELETE_TODO', payload: todo.id })}
              className="delete-btn"
            &gt;
              &times;
            &lt;/button&gt;
          &lt;/li&gt;
        ))
      )}
    &lt;/ul&gt;
    
    &lt;div className="todo-stats"&gt;
      &lt;p&gt;
        {state.todos.filter(todo => !todo.completed).length} items left
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Combining useReducer with Context</h4>
            <pre><code class="language-typescript">import React, { useReducer, createContext, useContext, ReactNode } from 'react';

// Same Todo interfaces and reducer as before...

// Create context
interface TodoContextType {
state: TodoState;
dispatch: React.Dispatch<TodoAction>;
}

const TodoContext = createContext<TodoContextType | undefined>(undefined);

// Provider component
function TodoProvider({ children }: { children: ReactNode }) {
const [state, dispatch] = useReducer(todoReducer, initialState);

return (
  &lt;TodoContext.Provider value={{ state, dispatch }}&gt;
    {children}
  &lt;/TodoContext.Provider&gt;
);
}

// Custom hook to use the todo context
function useTodo() {
const context = useContext(TodoContext);

if (context === undefined) {
  throw new Error('useTodo must be used within a TodoProvider');
}

return context;
}

// Components can now be split up
function TodoForm() {
const { dispatch } = useTodo();
const [text, setText] = useState('');

const handleSubmit = (e: React.FormEvent) => {
  e.preventDefault();
  if (text.trim()) {
    dispatch({ type: 'ADD_TODO', payload: text });
    setText('');
  }
};

return (
  &lt;form onSubmit={handleSubmit}&gt;
    &lt;input
      value={text}
      onChange={(e) => setText(e.target.value)}
      placeholder="Add a todo..."
    /&gt;
    &lt;button type="submit"&gt;Add&lt;/button&gt;
  &lt;/form&gt;
);
}

function FilterButtons() {
const { state, dispatch } = useTodo();

return (
  &lt;div className="filters"&gt;
    &lt;button
      onClick={() => dispatch({ type: 'SET_FILTER', payload: 'all' })}
      className={state.filter === 'all' ? 'active' : ''}
    &gt;
      All
    &lt;/button&gt;
    {/* Other filter buttons */}
  &lt;/div&gt;
);
}

function TodoList() {
const { state, dispatch } = useTodo();

// Filter logic...

return (
  &lt;ul&gt;
    {/* Todo items */}
  &lt;/ul&gt;
);
}

// Main app component with providers
function App() {
return (
  &lt;TodoProvider&gt;
    &lt;div className="todo-app"&gt;
      &lt;h1&gt;Todo App&lt;/h1&gt;
      &lt;TodoForm /&gt;
      &lt;FilterButtons /&gt;
      &lt;TodoList /&gt;
    &lt;/div&gt;
  &lt;/TodoProvider&gt;
);
}</code></pre>

            <div class="callout-block callout-block-success">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-thumbs-up"></i> </span
                  ><!--//icon-holder-->
                  useReducer Best Practices
                </h4>
                <p>
                  <ul>
                    <li><strong>Separate reducer logic</strong>: Keep your reducer functions outside of your components for better testing and reusability</li>
                    <li><strong>Use TypeScript</strong>: Define proper types for state and actions to catch errors early</li>
                    <li><strong>Use action constants</strong>: Define action types as constants to avoid typos</li>
                    <li><strong>Combine with context</strong>: For global state, combine useReducer with context</li>
                    <li><strong>Create action creators</strong>: For complex actions, create functions that return properly formatted actions</li>
                    <li><strong>Keep reducers pure</strong>: Reducers should not have side effects; handle those in useEffect or event handlers</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>
        </article>

        <article class="docs-article" id="section-19">
          <header class="docs-header">
            <h1 class="docs-heading">useCallback Hook</h1>
            <section class="docs-intro">
              <p>
                The <code>useCallback</code> hook returns a memoized callback function. This optimization helps prevent unnecessary renders in child components that rely on callback function props.
              </p>
            </section>
            <!--//docs-intro-->
          </header>
          <section class="docs-section" id="item-19-1">
            <h2 class="section-heading">Basic Usage</h2>
            <p>
              <code>useCallback</code> returns a memoized version of the callback that only changes if one of the dependencies has changed.
            </p>

            <h4>Simple Example</h4>
            <pre><code class="language-typescript">import { useState, useCallback } from 'react';

function ParentComponent() {
const [count, setCount] = useState(0);
const [text, setText] = useState('');

// Without useCallback, this function would be recreated on every render
// With useCallback, it's only recreated when 'count' changes
const incrementCount = useCallback(() => {
  setCount(prevCount => prevCount + 1);
}, []);

return (
  &lt;div&gt;
    &lt;input
      value={text}
      onChange={(e) => setText(e.target.value)}
      placeholder="Type something..."
    /&gt;
    
    &lt;p&gt;Count: {count}&lt;/p&gt;
    
    {/* ChildComponent receives the memoized callback */}
    &lt;ChildComponent onIncrement={incrementCount} /&gt;
  &lt;/div&gt;
);
}

// Child component that should only re-render when its props change
const ChildComponent = React.memo(function ChildComponent({ 
onIncrement 
}: { 
onIncrement: () => void 
}) {
console.log('ChildComponent rendered');

return (
  &lt;button onClick={onIncrement}&gt;
    Increment Counter
  &lt;/button&gt;
);
});</code></pre>

            <h4>With Dependencies</h4>
            <pre><code class="language-typescript">import { useState, useCallback } from 'react';

function SearchComponent() {
const [searchTerm, setSearchTerm] = useState('');
const [searchResults, setSearchResults] = useState([]);

// This callback depends on searchTerm and will be recreated
// only when searchTerm changes
const handleSearch = useCallback(() => {
  console.log(`Searching for: ${searchTerm}`);
  
  // Simulate API call
  fetch(`https://api.example.com/search?q=${searchTerm}`)
    .then(response => response.json())
    .then(data => setSearchResults(data));
}, [searchTerm]); // dependency array

return (
  &lt;div&gt;
    &lt;input
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      placeholder="Search..."
    /&gt;
    
    &lt;SearchButton onSearch={handleSearch} /&gt;
    
    &lt;ResultsList results={searchResults} /&gt;
  &lt;/div&gt;
);
}

// Child components
const SearchButton = React.memo(function SearchButton({ 
onSearch 
}: { 
onSearch: () => void 
}) {
console.log('SearchButton rendered');

return (
  &lt;button onClick={onSearch}&gt;
    Search
  &lt;/button&gt;
);
});

const ResultsList = React.memo(function ResultsList({ 
results 
}: { 
results: any[] 
}) {
console.log('ResultsList rendered');

return (
  &lt;ul&gt;
    {results.map(result => (
      &lt;li key={result.id}&gt;{result.title}&lt;/li&gt;
    ))}
  &lt;/ul&gt;
);
});</code></pre>

            <div class="callout-block callout-block-info">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-info-circle"></i> </span
                  ><!--//icon-holder-->
                  useCallback and React.memo
                </h4>
                <p>
                  <code>useCallback</code> is most effective when used with <code>React.memo</code> or <code>useMemo</code>. Without these optimizations, memoizing a callback function may not provide much benefit:
                  <ul>
                    <li><code>useCallback</code> memoizes the function itself</li>
                    <li><code>React.memo</code> memoizes a component, preventing re-renders when props don't change</li>
                    <li>Together, they prevent unnecessary re-renders of child components when a parent renders</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>

          <section class="docs-section" id="item-19-2">
            <h2 class="section-heading">Performance Optimization</h2>
            <p>
              <code>useCallback</code> is primarily a performance optimization tool. Here are some scenarios where it's most useful:
            </p>

            <h4>Event Handlers in Lists</h4>
            <pre><code class="language-typescript">import { useState, useCallback } from 'react';

interface Todo {
id: number;
text: string;
completed: boolean;
}

function TodoList() {
const [todos, setTodos] = useState<Todo[]>([
  { id: 1, text: 'Learn React', completed: false },
  { id: 2, text: 'Build a project', completed: false },
  { id: 3, text: 'Deploy to production', completed: false }
]);

// Memoize the toggle handler to prevent recreation for each todo item
const handleToggle = useCallback((id: number) => {
  setTodos(prevTodos =>
    prevTodos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    )
  );
}, []);

// Memoize the delete handler
const handleDelete = useCallback((id: number) => {
  setTodos(prevTodos => prevTodos.filter(todo => todo.id !== id));
}, []);

return (
  &lt;ul&gt;
    {todos.map(todo => (
      &lt;TodoItem
        key={todo.id}
        todo={todo}
        onToggle={handleToggle}
        onDelete={handleDelete}
      /&gt;
    ))}
  &lt;/ul&gt;
);
}

// Memoized child component
const TodoItem = React.memo(function TodoItem({
todo,
onToggle,
onDelete
}: {
todo: Todo;
onToggle: (id: number) => void;
onDelete: (id: number) => void;
}) {
console.log(`TodoItem rendered: ${todo.text}`);

return (
  &lt;li&gt;
    &lt;input
      type="checkbox"
      checked={todo.completed}
      onChange={() => onToggle(todo.id)}
    /&gt;
    &lt;span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}&gt;
      {todo.text}
    &lt;/span&gt;
    &lt;button onClick={() => onDelete(todo.id)}&gt;Delete&lt;/button&gt;
  &lt;/li&gt;
);
});</code></pre>

            <h4>Custom Hook with Callbacks</h4>
            <pre><code class="language-typescript">import { useState, useCallback } from 'react';

// Custom hook for form field management
function useField(initialValue: string = '') {
const [value, setValue] = useState(initialValue);

// Reset function is memoized and won't change
const reset = useCallback(() => {
  setValue(initialValue);
}, [initialValue]);

// Input props object with stable onChange handler
const inputProps = {
  value,
  onChange: useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value);
  }, [])
};

return {
  value,
  setValue,
  reset,
  inputProps
};
}

// Usage example
function SignupForm() {
const username = useField('');
const email = useField('');
const password = useField('');

const handleSubmit = useCallback((e: React.FormEvent) => {
  e.preventDefault();
  
  // Form submission logic
  console.log({
    username: username.value,
    email: email.value,
    password: password.value
  });
  
  // Reset all fields
  username.reset();
  email.reset();
  password.reset();
}, [username, email, password]);

return (
  &lt;form onSubmit={handleSubmit}&gt;
    &lt;div&gt;
      &lt;label&gt;Username:&lt;/label&gt;
      &lt;input type="text" {...username.inputProps} /&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;label&gt;Email:&lt;/label&gt;
      &lt;input type="email" {...email.inputProps} /&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;label&gt;Password:&lt;/label&gt;
      &lt;input type="password" {...password.inputProps} /&gt;
    &lt;/div&gt;
    
    &lt;button type="submit"&gt;Sign Up&lt;/button&gt;
    &lt;button type="button" onClick={() => {
      username.reset();
      email.reset();
      password.reset();
    }}&gt;Reset&lt;/button&gt;
  &lt;/form&gt;
);
}</code></pre>

            <div class="callout-block callout-block-warning">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-exclamation-triangle"></i> </span
                  ><!--//icon-holder-->
                  Avoiding Premature Optimization
                </h4>
                <p>
                  <ul>
                    <li><code>useCallback</code> itself has a performance cost, so it's not always beneficial</li>
                    <li>Only use <code>useCallback</code> when it provides a clear performance benefit</li>
                    <li>Focus on memoizing callbacks that are passed to optimized child components</li>
                    <li>Most event handlers in typical React apps don't need <code>useCallback</code></li>
                    <li>Measure performance before and after optimization to ensure it's helping</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>
        </article>

        <article class="docs-article" id="section-20">
          <header class="docs-header">
            <h1 class="docs-heading">useMemo Hook</h1>
            <section class="docs-intro">
              <p>
                The <code>useMemo</code> hook is similar to <code>useCallback</code>, but instead of memoizing a function, it memoizes the result of a calculation. It's useful for expensive calculations that shouldn't be recomputed on every render.
              </p>
            </section>
            <!--//docs-intro-->
          </header>
          <section class="docs-section" id="item-20-1">
            <h2 class="section-heading">Basic Usage</h2>
            <p>
              <code>useMemo</code> takes a function and a dependencies array, and only recalculates the memoized value when one of the dependencies changes.
            </p>

            <h4>Simple Example</h4>
            <pre><code class="language-typescript">import { useState, useMemo } from 'react';

function ExpensiveCalculation() {
const [count, setCount] = useState(0);
const [todos, setTodos] = useState<string[]>([]);
const [todoInput, setTodoInput] = useState('');

// Expensive calculation that should only run when count changes
const expensiveResult = useMemo(() => {
  console.log('Performing expensive calculation...');
  
  // Simulate expensive operation
  let result = 0;
  for (let i = 0; i < 1000000000; i++) {
    result += count;
  }
  
  return result;
}, [count]); // Only re-run when count changes

const addTodo = () => {
  if (todoInput.trim()) {
    setTodos([...todos, todoInput]);
    setTodoInput('');
  }
};

return (
  &lt;div&gt;
    &lt;div&gt;
      &lt;h2&gt;Counter and Expensive Calculation&lt;/h2&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;p&gt;Calculation result: {expensiveResult}&lt;/p&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
    
    &lt;div&gt;
      &lt;h2&gt;Todo List&lt;/h2&gt;
      &lt;input
        value={todoInput}
        onChange={(e) => setTodoInput(e.target.value)}
        placeholder="Add todo"
      /&gt;
      &lt;button onClick={addTodo}&gt;Add Todo&lt;/button&gt;
      
      &lt;ul&gt;
        {todos.map((todo, index) => (
          &lt;li key={index}&gt;{todo}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Memoizing Derived State</h4>
            <pre><code class="language-typescript">import { useState, useMemo } from 'react';

interface Product {
id: number;
name: string;
price: number;
category: string;
}

function ProductList() {
const [products, setProducts] = useState<Product[]>([
  { id: 1, name: 'Laptop', price: 1200, category: 'Electronics' },
  { id: 2, name: 'Headphones', price: 100, category: 'Electronics' },
  { id: 3, name: 'Desk Chair', price: 250, category: 'Furniture' },
  { id: 4, name: 'Coffee Table', price: 300, category: 'Furniture' },
  { id: 5, name: 'Monitor', price: 400, category: 'Electronics' }
]);

const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('asc');

// Memoize filtered and sorted products
const filteredAndSortedProducts = useMemo(() => {
  console.log('Recalculating filtered and sorted products');
  
  // First, filter by category if one is selected
  let result = selectedCategory
    ? products.filter(product => product.category === selectedCategory)
    : products;
  
  // Then, sort by price
  return result.sort((a, b) => {
    if (sortOrder === 'asc') {
      return a.price - b.price;
    } else {
      return b.price - a.price;
    }
  });
}, [products, selectedCategory, sortOrder]);

// Memoize category stats
const categoryStats = useMemo(() => {
  console.log('Recalculating category stats');
  
  const stats: Record<string, { count: number; totalValue: number }> = {};
  
  for (const product of products) {
    if (!stats[product.category]) {
      stats[product.category] = { count: 0, totalValue: 0 };
    }
    
    stats[product.category].count += 1;
    stats[product.category].totalValue += product.price;
  }
  
  return stats;
}, [products]);

return (
  &lt;div&gt;
    &lt;div className="controls"&gt;
      &lt;div&gt;
        &lt;label&gt;Category:&lt;/label&gt;
        &lt;select
          value={selectedCategory || ''}
          onChange={(e) => setSelectedCategory(e.target.value || null)}
        &gt;
          &lt;option value=""&gt;All Categories&lt;/option&gt;
          {Object.keys(categoryStats).map(category => (
            &lt;option key={category} value={category}&gt;
              {category} ({categoryStats[category].count})
            &lt;/option&gt;
          ))}
        &lt;/select&gt;
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label&gt;Sort:&lt;/label&gt;
        &lt;select
          value={sortOrder}
          onChange={(e) => setSortOrder(e.target.value as 'asc' | 'desc')}
        &gt;
          &lt;option value="asc"&gt;Price: Low to High&lt;/option&gt;
          &lt;option value="desc"&gt;Price: High to Low&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div className="stats"&gt;
      &lt;h3&gt;Category Statistics&lt;/h3&gt;
      &lt;ul&gt;
        {Object.entries(categoryStats).map(([category, { count, totalValue }]) => (
          &lt;li key={category}&gt;
            {category}: {count} items, Total Value: ${totalValue}
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
    
    &lt;div className="products"&gt;
      &lt;h3&gt;Products ({filteredAndSortedProducts.length})&lt;/h3&gt;
      &lt;ul&gt;
        {filteredAndSortedProducts.map(product => (
          &lt;li key={product.id}&gt;
            {product.name} - ${product.price} ({product.category})
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
);
}</code></pre>

            <div class="callout-block callout-block-info">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-info-circle"></i> </span
                  ><!--//icon-holder-->
                  When to Use useMemo
                </h4>
                <p>
                  Good candidates for <code>useMemo</code> include:
                  <ul>
                    <li>Expensive calculations like complex filtering, sorting, or data transformations</li>
                    <li>Generating derived data from props or state that shouldn't be recalculated on every render</li>
                    <li>Creating objects that are passed as props to memoized child components</li>
                    <li>Processing large arrays or deeply nested objects</li>
                    <li>Calculations involving heavy mathematical operations</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>

          <section class="docs-section" id="item-20-2">
            <h2 class="section-heading">Advanced useMemo Patterns</h2>
            <p>
              <code>useMemo</code> can be used in more advanced scenarios to optimize complex applications.
            </p>

            <h4>Memoizing Component Props</h4>
            <pre><code class="language-typescript">import { useState, useMemo } from 'react';

interface User {
id: number;
name: string;
email: string;
}

interface UserListProps {
users: User[];
selectedUserId: number | null;
onSelectUser: (userId: number) => void;
}

// Child component with React.memo
const UserList = React.memo(function UserList({
users,
selectedUserId,
onSelectUser
}: UserListProps) {
console.log('UserList rendered');

return (
  &lt;ul&gt;
    {users.map(user => (
      &lt;li
        key={user.id}
        style={{ 
          backgroundColor: user.id === selectedUserId ? '#e0e0e0' : 'transparent',
          cursor: 'pointer',
          padding: '8px'
        }}
        onClick={() => onSelectUser(user.id)}
      &gt;
        {user.name} ({user.email})
      &lt;/li&gt;
    ))}
  &lt;/ul&gt;
);
});

// Parent component
function UserDirectory() {
const [users, setUsers] = useState<User[]>([
  { id: 1, name: 'John Doe', email: 'john@example.com' },
  { id: 2, name: 'Jane Smith', email: 'jane@example.com' },
  { id: 3, name: 'Bob Johnson', email: 'bob@example.com' }
]);

const [selectedUserId, setSelectedUserId] = useState<number | null>(null);
const [searchTerm, setSearchTerm] = useState('');

// Memoize filtered users
const filteredUsers = useMemo(() => {
  console.log('Filtering users');
  if (!searchTerm) return users;
  
  return users.filter(user => 
    user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    user.email.toLowerCase().includes(searchTerm.toLowerCase())
  );
}, [users, searchTerm]);

// Memoize the onSelectUser callback
const handleSelectUser = useCallback((userId: number) => {
  setSelectedUserId(prevId => prevId === userId ? null : userId);
}, []);

// Memoize the props object to prevent unnecessary renders of UserList
const userListProps = useMemo(() => ({
  users: filteredUsers,
  selectedUserId,
  onSelectUser: handleSelectUser
}), [filteredUsers, selectedUserId, handleSelectUser]);

return (
  &lt;div&gt;
    &lt;h2&gt;User Directory&lt;/h2&gt;
    
    &lt;div&gt;
      &lt;input
        type="text"
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search users..."
      /&gt;
    &lt;/div&gt;
    
    &lt;UserList {...userListProps} /&gt;
  &lt;/div&gt;
);
}</code></pre>

            <h4>Memoizing Complex Calculations and Custom Hooks</h4>
            <pre><code class="language-typescript">import { useState, useMemo } from 'react';

// Custom hook for data filtering and sorting
function useFilteredData<T>(
data: T[],
filterFn: (item: T) => boolean,
sortFn?: (a: T, b: T) => number
) {
// Memoize the filtered and sorted data
const processedData = useMemo(() => {
  console.log('Processing data...');
  
  // Filter the data
  const filtered = filterFn ? data.filter(filterFn) : data;
  
  // Sort the data if a sort function is provided
  return sortFn ? [...filtered].sort(sortFn) : filtered;
}, [data, filterFn, sortFn]);

// Return processed data and original data length for comparison
return {
  processedData,
  totalCount: data.length,
  filteredCount: processedData.length
};
}

// Component using the custom hook
function DataTable<T extends { id: number | string }>({
data,
renderRow,
filterFn,
sortFn
}: {
data: T[];
renderRow: (item: T) => React.ReactNode;
filterFn: (item: T) => boolean;
sortFn?: (a: T, b: T) => number;
}) {
const { processedData, totalCount, filteredCount } = useFilteredData(
  data,
  filterFn,
  sortFn
);

return (
  &lt;div&gt;
    &lt;div className="table-stats"&gt;
      Showing {filteredCount} of {totalCount} items
    &lt;/div&gt;
    
    &lt;table&gt;
      &lt;tbody&gt;
        {processedData.map(item => (
          &lt;tr key={item.id}&gt;{renderRow(item)}&lt;/tr&gt;
        ))}
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/div&gt;
);
}</code></pre>

            <div class="callout-block callout-block-warning">
              <div class="content">
                <h4 class="callout-title">
                  <span class="callout-icon-holder me-1">
                    <i class="fas fa-exclamation-triangle"></i> </span
                  ><!--//icon-holder-->
                  useMemo Limitations
                </h4>
                <p>
                  <ul>
                    <li><strong>Not guaranteed</strong>: React may discard memoized values in certain situations</li>
                    <li><strong>Memory usage</strong>: Memoization stores results in memory, which can be a concern for very large data structures</li>
                    <li><strong>Premature optimization</strong>: Using <code>useMemo</code> everywhere can harm performance and code readability</li>
                    <li><strong>Dependency arrays</strong>: Missing dependencies can lead to bugs with stale values</li>
                  </ul>
                </p>
              </div>
              <!--//content-->
            </div>
            <!--//callout-block-->
          </section>
        </article>

        <footer class="footer">
          <div class="container text-center py-5">
            <ul class="social-list list-unstyled pb-4 mb-0">
              <li class="list-inline-item">
                <a
                  href="https://www.facebook.com/AmpersandAcademy"
                  target="_blank"
                  ><i class="fab fa-facebook-f fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a
                  href="https://www.google.com/maps/place//data=!4m2!3m1!1s0x3a5267c7e2f583e1:0x2571d69e5709aacd?source=g.page.default"
                  target="_blank"
                  ><i class="fab fa-google fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a
                  href="https://www.linkedin.com/company/ampersandacademy/"
                  target="_blank"
                  ><i class="fab fa-linkedin fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a
                  href="https://www.instagram.com/ampersandacad/"
                  target="_blank"
                  ><i class="fab fa-instagram fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a
                  href="https://whatsapp.com/channel/0029Va9uvHh4Ui2ZTI70bH2w"
                  target="_blank"
                  ><i class="fab fa-whatsapp fa-fw"></i
                ></a>
              </li>
              <li class="list-inline-item">
                <a href="https://t.me/ampersandacad" target="_blank"
                  ><i class="fab fa-telegram fa-fw"></i
                ></a>
              </li>
            </ul>
            <!--//social-list-->
            <small class="copyright"
              ><a href="https://ampersandacademy.com" target="_blank"
                >Ampersand Academy</a
              >
              | All rights reserved</small
            >
          </div>
        </footer>
      </div>
      <!--//container-->
    </div>
    <!--//docs-content-->
  </div>
  <!--//docs-wrapper-->
  
  <!-- Javascript -->
  <script src="assets/plugins/popper.min.js"></script>
  <script src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>

  <!-- Page Specific JS -->
  <script src="assets/plugins/smoothscroll.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
  <script src="assets/js/highlight-custom.js"></script>
  <script src="assets/plugins/simplelightbox/simple-lightbox.min.js"></script>
  <script src="assets/plugins/gumshoe/gumshoe.polyfills.min.js"></script>
  <script src="assets/js/docs.js"></script>
</body>
</html>